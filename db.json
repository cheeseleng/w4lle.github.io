{"meta":{"version":1,"warehouse":"1.0.3"},"models":{"Asset":[{"_id":"themes/material/source/js/smoothscroll.js","path":"js/smoothscroll.js","modified":0},{"_id":"themes/material/source/js/nprogress.js","path":"js/nprogress.js","modified":0},{"_id":"themes/material/source/js/js.min.js","path":"js/js.min.js","modified":0},{"_id":"themes/material/source/js/js.js","path":"js/js.js","modified":0},{"_id":"themes/material/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","path":"js/ie-blocker.zhCN.js","modified":0},{"_id":"themes/material/source/js/ie-blocker.en.js","path":"js/ie-blocker.en.js","modified":0},{"_id":"themes/material/source/js/highlight.js","path":"js/highlight.js","modified":0},{"_id":"themes/material/source/js/gallery/util.min.js","path":"js/gallery/util.min.js","modified":0},{"_id":"themes/material/source/js/gallery/skel.min.js","path":"js/gallery/skel.min.js","modified":0},{"_id":"themes/material/source/js/gallery/main.min.js","path":"js/gallery/main.min.js","modified":0},{"_id":"themes/material/source/js/gallery/jquery.poptrox.min.js","path":"js/gallery/jquery.poptrox.min.js","modified":0},{"_id":"themes/material/source/img/upyun_logo.png","path":"img/upyun_logo.png","modified":0},{"_id":"themes/material/source/img/sidebar_header.png","path":"img/sidebar_header.png","modified":0},{"_id":"themes/material/source/img/random/5.png","path":"img/random/5.png","modified":0},{"_id":"themes/material/source/img/random/4.png","path":"img/random/4.png","modified":0},{"_id":"themes/material/source/img/random/3.png","path":"img/random/3.png","modified":0},{"_id":"themes/material/source/img/random/2.png","path":"img/random/2.png","modified":0},{"_id":"themes/material/source/img/random/1.png","path":"img/random/1.png","modified":0},{"_id":"themes/material/source/img/logo.png","path":"img/logo.png","modified":0},{"_id":"themes/material/source/img/gallery/spinner.svg","path":"img/gallery/spinner.svg","modified":0},{"_id":"themes/material/source/img/gallery/close.svg","path":"img/gallery/close.svg","modified":0},{"_id":"themes/material/source/img/gallery/arrow.svg","path":"img/gallery/arrow.svg","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-weibo.png","path":"img/footer/footer_ico-weibo.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-twitter.png","path":"img/footer/footer_ico-twitter.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.png","path":"img/footer/footer_ico-tumblr.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-instagram.png","path":"img/footer/footer_ico-instagram.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-gplus.png","path":"img/footer/footer_ico-gplus.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-github.png","path":"img/footer/footer_ico-github.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-facebook.png","path":"img/footer/footer_ico-facebook.png","modified":0},{"_id":"themes/material/source/img/footer/footer_ico-csdn.png","path":"img/footer/footer_ico-csdn.png","modified":0},{"_id":"themes/material/source/img/favicon.png","path":"img/favicon.png","modified":0},{"_id":"themes/material/source/img/daily_pic.png","path":"img/daily_pic.png","modified":0},{"_id":"themes/material/source/img/bg.png","path":"img/bg.png","modified":0},{"_id":"themes/material/source/img/avatar.png","path":"img/avatar.png","modified":0},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","path":"fonts/fontawesome-webfont.woff2","modified":0},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":0},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":0},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":0},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":0},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","path":"fonts/Roboto-Thin.ttf","modified":0},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","path":"fonts/Roboto-Regular.ttf","modified":0},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","path":"fonts/Roboto-Medium.ttf","modified":0},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","path":"fonts/Roboto-Light.ttf","modified":0},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","path":"fonts/Roboto-Bold.ttf","modified":0},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","path":"fonts/Roboto-Black.ttf","modified":0},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","path":"fonts/MaterialIcons-Regular.woff2","modified":0},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","path":"fonts/MaterialIcons-Regular.woff","modified":0},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","path":"fonts/MaterialIcons-Regular.ttf","modified":0},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","path":"fonts/MaterialIcons-Regular.eot","modified":0},{"_id":"themes/material/source/fonts/FontAwesome.otf","path":"fonts/FontAwesome.otf","modified":0},{"_id":"themes/material/source/css/uc.css","path":"css/uc.css","modified":0},{"_id":"themes/material/source/css/style.min.css","path":"css/style.min.css","modified":0},{"_id":"themes/material/source/css/style.css","path":"css/style.css","modified":0},{"_id":"themes/material/source/css/material.min.css","path":"css/material.min.css","modified":0},{"_id":"themes/material/source/css/material.css","path":"css/material.css","modified":0},{"_id":"themes/material/source/css/ie-blocker.css","path":"css/ie-blocker.css","modified":0},{"_id":"themes/material/source/css/highlight/solarized-light.css","path":"css/highlight/solarized-light.css","modified":0},{"_id":"themes/material/source/css/highlight/solarized-dark.css","path":"css/highlight/solarized-dark.css","modified":0},{"_id":"themes/material/source/css/gallery.min.css","path":"css/gallery.min.css","modified":0},{"_id":"themes/material/source/css/duoshuo.min.css","path":"css/duoshuo.min.css","modified":0},{"_id":"source/uploads/walle.jpg","path":"uploads/walle.jpg","modified":0},{"_id":"source/uploads/tab.png","path":"uploads/tab.png","modified":0},{"_id":"source/uploads/large_file1.png","path":"uploads/large_file1.png","modified":0},{"_id":"source/uploads/kill_tab.png","path":"uploads/kill_tab.png","modified":0},{"_id":"source/uploads/git-tab.png","path":"uploads/git-tab.png","modified":0},{"_id":"source/uploads/float3.png","path":"uploads/float3.png","modified":0},{"_id":"source/uploads/float2.png","path":"uploads/float2.png","modified":0},{"_id":"source/uploads/float1.png","path":"uploads/float1.png","modified":0},{"_id":"source/uploads/box-model.png","path":"uploads/box-model.png","modified":0},{"_id":"source/uploads/alias_git.png","path":"uploads/alias_git.png","modified":0},{"_id":"source/uploads/alias.png","path":"uploads/alias.png","modified":0},{"_id":"source/uploads/absolute.png","path":"uploads/absolute.png","modified":0},{"_id":"source/uploads/UP2.png","path":"uploads/UP2.png","modified":0},{"_id":"source/uploads/UP1.png","path":"uploads/UP1.png","modified":0},{"_id":"source/uploads/QQ20160131-1@2x.png","path":"uploads/QQ20160131-1@2x.png","modified":0},{"_id":"source/uploads/PWD-tab.png","path":"uploads/PWD-tab.png","modified":0},{"_id":"source/uploads/PWD-tab-done.png","path":"uploads/PWD-tab-done.png","modified":0},{"_id":"source/uploads/Classy_group_2.png","path":"uploads/Classy_group_2.png","modified":0},{"_id":"source/uploads/Classy_group.png","path":"uploads/Classy_group.png","modified":0},{"_id":"source/uploads/ClassyShark_com.png","path":"uploads/ClassyShark_com.png","modified":0},{"_id":"source/uploads/ClassyShark.png","path":"uploads/ClassyShark.png","modified":0},{"_id":"source/ife_baidu/img/team-logo.jpg","path":"ife_baidu/img/team-logo.jpg","modified":0}],"Cache":[{"_id":"source/_posts/Android关闭通知消息权限无法弹出Toast的问题解决方案.md","shasum":"fe418d9cf718ca978c28d2c8abec01708e9d1fe8","modified":1465207995000},{"_id":"source/_posts/AndFix支持multidex解决方案.md","shasum":"a497325e6c1509ecacb8e72f854223a68287b0c6","modified":1465207995000},{"_id":"source/_posts/Android-Color.md","shasum":"df94d675cce6951a6be3058849685f180c957928","modified":1465207995000},{"_id":"source/_posts/Android热补丁之AndFix原理解析.md","shasum":"1f85c9aa6e13a965e20026381aa472136a62a86a","modified":1465207995000},{"_id":"source/_posts/Android自定义View之刻度尺.md","shasum":"58e04291fa9ef111e86165e5c3192c46cfe7ced9","modified":1465207995000},{"_id":"source/_posts/Android进程保活之绑定系统服务.md","shasum":"97a072a0ba402da499f94562d566a9cb47b8f44c","modified":1469366639000},{"_id":"source/_posts/Apk包瘦身笔记.md","shasum":"f6e137ee518f0187058a8ec8b58e50ba203877fa","modified":1465207995000},{"_id":"source/_posts/AsyncTask.md","shasum":"ef9318a19b0c4c1edeac5d346ee93530428dc8aa","modified":1469963551000},{"_id":"source/_posts/ClassyShark——分析apk利器.md","shasum":"575275a82988a2153a884f29c6e7ada1886f4e28","modified":1465207995000},{"_id":"source/_posts/Hexo-themes.md","shasum":"07e89f82cd0942ded187ebe7b315223dc30bc13b","modified":1465216868000},{"_id":"source/_posts/hello-world.md","shasum":"d6f352b85b1e7546b91ede63e17aa2ba1dae559a","modified":1465207995000},{"_id":"source/_posts/Flexbox.md","shasum":"51ea443224e6ac2928b7de544806295929226f1b","modified":1465207995000},{"_id":"source/_posts/JavaScript.md","shasum":"37696b772e14ca82b282d4ec76e3d158038c3b59","modified":1465207995000},{"_id":"source/_posts/hexo-theme-material.md","shasum":"93d3e01d20d20df3a10a27ea425ec01fcfa5cb44","modified":1479385797000},{"_id":"source/_posts/step-counter.md","shasum":"bcbdfcb3d4d371f63199559075b840a64970c475","modified":1466943441000},{"_id":"source/_posts/从Instant run谈Android替换Application和动态加载机制.md","shasum":"f8ffe763e865fe399bd3ba78dc887357c4d19f7e","modified":1465207995000},{"_id":"source/_posts/前端基础-一-CSS布局基础.md","shasum":"7f5f84dcbb8b64a8a616b84a1a4398e018fdee0c","modified":1465207995000},{"_id":"source/_posts/前端基础-零-CSS基础.md","shasum":"7998a5a7cb346659b0278ecff829d9f69c257ca9","modified":1465207995000},{"_id":"source/_posts/快速排序.md","shasum":"340119755950f25b532946c13217c4b6384cc183","modified":1467554949000},{"_id":"source/_posts/终极Shell-Zsh-使用技巧.md","shasum":"60fff833b65b2d1751dfc579fad899b47c1555bc","modified":1465207995000},{"_id":"source/google242d671fbb406072.html","shasum":"526bd244bb9e374e52bc6dcda1d4788a879f1eb6","modified":1465207995000},{"_id":"source/guestbook/index.md","shasum":"1ec282b3c167d922492124ca2c176ac2f9f90237","modified":1479374384000},{"_id":"source/ife_baidu/img/team-logo.jpg","shasum":"d11c2619c80827962ebe63b7711826589d4dd66d","modified":1465207995000},{"_id":"source/ife_baidu/task1/index.html","shasum":"a8c383e0200ebdcc41f96d1a8ef498217dda169d","modified":1465207995000},{"_id":"source/ife_baidu/task10/index.html","shasum":"6b81c04da092f6db56add11e371cedb2612c80e5","modified":1465207995000},{"_id":"source/ife_baidu/task2/index.css","shasum":"0c95bdff70d10ff6bd3fda43a02c5c7364e73ca8","modified":1465207995000},{"_id":"source/ife_baidu/task2/index.html","shasum":"12f3c2a8363a6a868ea44241532237bb2caae136","modified":1465207995000},{"_id":"source/ife_baidu/task3/task3.css","shasum":"961be668ee7fe31cb9a87a331cb2c9a98180e136","modified":1465207995000},{"_id":"source/ife_baidu/task3/task3.html","shasum":"89cc1b45bf4cfc2a503fa802e66eca6d05f17fe9","modified":1465207995000},{"_id":"source/ife_baidu/test.js","shasum":"042dc4512fa3d391c5170cf3aa61e6a638f84342","modified":1465207995000},{"_id":"source/tags/index.md","shasum":"ad3992278232ba0a25cc88abea30f799329bb4bf","modified":1479974832000},{"_id":"source/uploads/ClassyShark.png","shasum":"c5bcd442072d5cbd5f0e31e55a4e7389669cb961","modified":1465207995000},{"_id":"source/uploads/QQ20160131-1@2x.png","shasum":"3f85a1996d6eba7e8a0aaee063bc8967eda218ce","modified":1465207995000},{"_id":"source/uploads/absolute.png","shasum":"0d311831e2626a315e56af96b67a3bb7f58c4f3a","modified":1465207995000},{"_id":"source/uploads/box-model.png","shasum":"8b827fb7ec9c9489b551e8e1783dfb96181ea97d","modified":1465207995000},{"_id":"source/uploads/float1.png","shasum":"9191a3eda5489ddb4f8f830454c5be4a2ec03fcd","modified":1465207995000},{"_id":"source/uploads/float2.png","shasum":"ff84bdafc304111a45e3ada6f69a6c99dc37b449","modified":1465207995000},{"_id":"source/uploads/float3.png","shasum":"b9fa5fb6f2e4bc37b00034cb35fc241b8a527adc","modified":1465207995000},{"_id":"source/uploads/tab.png","shasum":"d09d0b13ab3a45d4ee2e83fb8486a8b519b3c84e","modified":1465207995000},{"_id":"themes/material/layout/_partial/Isolation-post-info.ejs","shasum":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1479284946000},{"_id":"source/uploads/UP1.png","shasum":"faa09579adf3527112b4dfbbce9d6df42d46a967","modified":1465207995000},{"_id":"source/uploads/UP2.png","shasum":"2ae0123901db6f91f460d2f74c89b8382493a30d","modified":1465207995000},{"_id":"source/uploads/alias.png","shasum":"404e90814a0e2ec62e9125b89ff25578a14f9876","modified":1465207995000},{"_id":"themes/material/README.md","shasum":"241ee369710b2064c81e3756f3a0845743f552c7","modified":1479435840000},{"_id":"themes/material/_config.yml","shasum":"c822ba0518217ac979e14d4d46474b29d45b0365","modified":1479959216000},{"_id":"themes/material/LICENSE","shasum":"12d81f50767d4e09aa7877da077ad9d1b915d75b","modified":1479284946000},{"_id":"themes/material/languages/ar.yml","shasum":"3b5e563b3179f02e132829e305922d27fbdd3b59","modified":1479284946000},{"_id":"themes/material/languages/en.yml","shasum":"63d155d64da4844f83ccfde03e515ba003644f30","modified":1479284946000},{"_id":"themes/material/languages/es.yml","shasum":"7987f6db1e86cccdc1ab2a900a1786cc3f58428b","modified":1479284946000},{"_id":"themes/material/languages/ja.yml","shasum":"8efe0aec1d2cd617458693addb8e2ac1d892b56f","modified":1479284946000},{"_id":"themes/material/languages/zh-CN.yml","shasum":"5e9a779f3c23f7eb84c7b85116858910b4ded75c","modified":1479284946000},{"_id":"themes/material/languages/zh-TW.yml","shasum":"318bbe72d0313b2ccafc9a02e2c2c2d27337d6e1","modified":1479284946000},{"_id":"themes/material/layout/_partial/Isolation-post_entry.ejs","shasum":"f57785d1da61b0807b2493c2657c8acbd34cc16c","modified":1479284946000},{"_id":"themes/material/layout/_partial/Paradox-post_entry.ejs","shasum":"313b4634cd67de4da51d94b71a3b2a1543fc10ee","modified":1479453449000},{"_id":"themes/material/layout/_partial/Paradox-search.ejs","shasum":"d2b40de19403b95aa3581a4c64288dc1013efda6","modified":1479284946000},{"_id":"themes/material/layout/_partial/Paradox-post-info.ejs","shasum":"1acdf18dd479c539bf2bba5aedfc4996174473f1","modified":1479284946000},{"_id":"themes/material/layout/_partial/Paradox-post_entry-thumbnail.ejs","shasum":"63176ca062eba02173a5d5da19c7d315ce22714a","modified":1479284946000},{"_id":"themes/material/layout/_partial/Paradox-post-thumbnail.ejs","shasum":"85bd819622970c1821ec73d0a0d8a8bf2575a92f","modified":1479284946000},{"_id":"themes/material/layout/_partial/blog_info.ejs","shasum":"625adf31b270b48d1f7cf81ed2259777c272ded4","modified":1479453449000},{"_id":"themes/material/layout/_partial/comment.ejs","shasum":"1a6ce3d81d4c103bd7b2d7c972b5fe2337588045","modified":1479284946000},{"_id":"themes/material/layout/_partial/daily_pic.ejs","shasum":"83bc545ac146fd71c656093051b503447d98b698","modified":1479453449000},{"_id":"themes/material/layout/_partial/footer-left.ejs","shasum":"46cb729ddf9f62ca69e9b6eba4b6d6a199707bb2","modified":1479453449000},{"_id":"themes/material/layout/_partial/config_css.ejs","shasum":"6bd221f5c8a0a869e66e5df9f829f0e6b850debf","modified":1479435853000},{"_id":"themes/material/layout/_partial/footer.ejs","shasum":"a2e27517eefa6fc9c6a73ddeb01619fc1f69b180","modified":1479453449000},{"_id":"themes/material/layout/_partial/footer_top.ejs","shasum":"b9535d979c2324f101f856412da95a6fddcdb37c","modified":1479284946000},{"_id":"themes/material/layout/_partial/footer-option.ejs","shasum":"6b758920aebabd3add8bf2b0685134d76631cfe4","modified":1479436434000},{"_id":"themes/material/layout/_partial/isolate-sns_list.ejs","shasum":"961212ac51637b7dbf074f5de42be4cf59ffb1a5","modified":1479284946000},{"_id":"themes/material/layout/_partial/head.ejs","shasum":"0784ce9f1af0ec91f57c6aae668ea607635812cb","modified":1479284946000},{"_id":"themes/material/layout/_partial/import_js.ejs","shasum":"6a0baf362ecd6302295ca062a92b3feaaf283a90","modified":1479284946000},{"_id":"themes/material/layout/_partial/isolate_info.ejs","shasum":"9575c471665bbdb7f3b22a1eecda4c17dd707a40","modified":1479284946000},{"_id":"themes/material/layout/_partial/nprogress.ejs","shasum":"88893a23999577123dfe03722c9ca0a673e11ee4","modified":1479284946000},{"_id":"themes/material/layout/_partial/post-content.ejs","shasum":"851e243ff4719afdc62fecfd15b5e6ea251f8701","modified":1479284946000},{"_id":"themes/material/layout/_partial/post-header.ejs","shasum":"694b3893f77c58bb6d7d79122c179fd282e3ff1c","modified":1479368370000},{"_id":"themes/material/layout/_partial/post-info-share.ejs","shasum":"051a8faac031b8732b051aaca6682e5b10d334a0","modified":1479453449000},{"_id":"themes/material/layout/_partial/post-nav.ejs","shasum":"b3fe611db0fb4ea7db2ec5ec30026e96f00c4661","modified":1479284946000},{"_id":"themes/material/layout/_partial/sidebar-footer.ejs","shasum":"fe5a7ccd0ea2d4fcee2e9352bda24db1fd7d04c3","modified":1479284946000},{"_id":"themes/material/layout/_partial/sidebar-header.ejs","shasum":"d86dd890fc228636bb3bf5ea2327219684afcfbf","modified":1479284946000},{"_id":"themes/material/layout/_partial/sidebar-navigation.ejs","shasum":"e92eb2d5fcf6fdef316bbdc0d777849b913ef584","modified":1479435840000},{"_id":"themes/material/layout/_partial/sidebar-sponsor.ejs","shasum":"c8a3b74ab45c5d086895850ca27df848a8c1cd6c","modified":1479284946000},{"_id":"themes/material/layout/_partial/sidebar.ejs","shasum":"4d675fea8445fbf2116872feddc79ee5ffa24f9b","modified":1479284946000},{"_id":"themes/material/layout/_partial/toc_button.ejs","shasum":"048234ab68ad36c8239c2ccfa7d9c3dcedbdd139","modified":1479284946000},{"_id":"themes/material/layout/_widget/disqus.ejs","shasum":"06dcc78d492c03137d5455171891853d5df1ded5","modified":1479284946000},{"_id":"themes/material/layout/_widget/duoshuo.ejs","shasum":"8977476cca1baa2ff6a2ee62b84f3f7fbb5997c6","modified":1479436072000},{"_id":"themes/material/layout/_widget/leancloud-like.ejs","shasum":"dbe913548513e2886424f2943034f92b84aa71b4","modified":1479284946000},{"_id":"themes/material/layout/_widget/leancloud-views.ejs","shasum":"e513fe25e2e3b4ba71b6704c53da51aafac40f44","modified":1479284946000},{"_id":"themes/material/layout/_widget/leancloud-views_num.ejs","shasum":"2fcef7c6dca8d213e294e7f766707f5b43c187e4","modified":1479284946000},{"_id":"themes/material/layout/_widget/page-links.ejs","shasum":"4993b206725c0f2f31600137413d8d1c178461d3","modified":1479284946000},{"_id":"themes/material/layout/_widget/page-gallery.ejs","shasum":"327f5da1eb02e1692ac4e1e8276af32c44b1aea2","modified":1479284946000},{"_id":"themes/material/layout/_widget/page-tagcloud.ejs","shasum":"04386a0977fe5a7d213bf49b30131f6d5150641f","modified":1479284946000},{"_id":"themes/material/layout/_widget/search-local-js.ejs","shasum":"19526e5aa1402e03d589dc3cd6c02bcfb1e4bfa3","modified":1479284946000},{"_id":"themes/material/layout/_widget/search-swiftype-js.ejs","shasum":"6fbc6e98f1971b03cedda7bb78e25cb8c9f30356","modified":1479284946000},{"_id":"themes/material/layout/index.ejs","shasum":"168785c6dcefed2ac68b31bffc1bbd196cdde0c6","modified":1479284946000},{"_id":"themes/material/package.json","shasum":"1a7b86824800ed5e884da6453ade901404af326e","modified":1479435840000},{"_id":"themes/material/source/css/duoshuo.min.css","shasum":"fd1cb54e55a71fb8190af9a371207f85a0dd9977","modified":1479284946000},{"_id":"themes/material/layout/layout.ejs","shasum":"0691005904b19934117b1b7be58045669a884703","modified":1479435840000},{"_id":"themes/material/source/css/highlight/solarized-light.css","shasum":"6b70caf1e84d096b1bc6318d5dae78d69e5dd1d3","modified":1479284946000},{"_id":"themes/material/layout/post.ejs","shasum":"b97995516729cfbab001308b14c20b2e97afcb18","modified":1479284946000},{"_id":"themes/material/source/css/ie-blocker.css","shasum":"dddce7e6250a449291888ae7865697282a213b14","modified":1479284946000},{"_id":"themes/material/source/css/gallery.min.css","shasum":"041ceaf662d3d99c7d683bd98d41ef818aece884","modified":1479284946000},{"_id":"themes/material/source/css/highlight/solarized-dark.css","shasum":"d02fc2dcbeec4b7af2cadec4bbbfc5b016aed4c7","modified":1479284946000},{"_id":"themes/material/source/css/uc.css","shasum":"37c3562e4bb06e3d830e4cad172af4293ff30912","modified":1479284946000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff","shasum":"c6c953c2ccb2ca9abb21db8dbf473b5a435f0082","modified":1479284946000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.woff2","shasum":"09963592e8c953cc7e14e3fb0a5b05d5042e8435","modified":1479284946000},{"_id":"themes/material/source/img/avatar.png","shasum":"6082917e5a6b154e63d459c3fac03d6ae9575fa9","modified":1479453449000},{"_id":"themes/material/source/img/bg.png","shasum":"a32f9717e19e821a4030ade551dc2917c889fcd8","modified":1479284946000},{"_id":"themes/material/source/img/favicon.png","shasum":"b1bcc84cedb2a618e8db93559ce7d58f9274085d","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-csdn.png","shasum":"5cea5a342afb0324f5df0aa17084a20125c022d8","modified":1479453449000},{"_id":"themes/material/source/img/footer/footer_ico-facebook.png","shasum":"66f959829d878794e66fd0e40c0d6bd843cc0cde","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-gplus.png","shasum":"20971cbed2ebf58b9e3b087051f7fc56073da31d","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-instagram.png","shasum":"3687ed1b6fcae267954d426de70ebf41d592dee6","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-github.png","shasum":"5125ef5695dd7e33b35ebe2f32420aaa2fcccd5e","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-tumblr.png","shasum":"0a1828b13d436dd0443dbb5b5b2e388e148cbd19","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-twitter.png","shasum":"98b6529d3e08d5d086a4df85c20265c4517ec9a8","modified":1479284946000},{"_id":"themes/material/source/img/footer/footer_ico-weibo.png","shasum":"0819d48c120881577631c43adb51dd51dcc07128","modified":1479284946000},{"_id":"themes/material/source/img/gallery/spinner.svg","shasum":"285d4c263d37d920d65a1c67c870a05dbbdbb7c3","modified":1479284946000},{"_id":"themes/material/source/img/gallery/arrow.svg","shasum":"84dba9fe4dffab02e5e32f66cea1e38c12129a7c","modified":1479284946000},{"_id":"themes/material/source/img/gallery/close.svg","shasum":"205739dd10d087f013583087e012ee7423a99c34","modified":1479284946000},{"_id":"themes/material/source/img/random/1.png","shasum":"062df9c2b23c0a83faaea5db4a58cf73841ac789","modified":1479284946000},{"_id":"themes/material/source/img/random/3.png","shasum":"0cccb7647a07fe363f0512d20b18fd9cd3d89eb7","modified":1479284946000},{"_id":"themes/material/source/img/random/4.png","shasum":"8dcd26ffa8a6601fd15df52f9dcb63824c187227","modified":1479284946000},{"_id":"themes/material/source/img/random/2.png","shasum":"561793a0daf8b071d217960489935c2a87d7d55e","modified":1479284946000},{"_id":"themes/material/source/img/random/5.png","shasum":"9bffa58e6e021c6e4a67cba714210b8fbb7f7989","modified":1479284946000},{"_id":"themes/material/source/img/upyun_logo.png","shasum":"aee4e90c4e2e72ef7036668c52dabcd8d028ee2f","modified":1479284946000},{"_id":"themes/material/source/img/sidebar_header.png","shasum":"c47f4d39f421c0a950279d050ae82f9ae6dd19ff","modified":1479284946000},{"_id":"themes/material/source/js/gallery/main.min.js","shasum":"8f2e566b2a9641d7749e0da9e102e23bf2953a1c","modified":1479284946000},{"_id":"themes/material/source/js/gallery/jquery.poptrox.min.js","shasum":"0fa3988cea003eb294e359ebe59e00f16151af34","modified":1479284946000},{"_id":"themes/material/source/js/gallery/skel.min.js","shasum":"763a8fc7504139cee50c453f87b5aa204965463a","modified":1479284946000},{"_id":"themes/material/source/js/gallery/util.min.js","shasum":"02ed3bc11ec203f9d7ce0003b836b12c2874b34a","modified":1479284946000},{"_id":"themes/material/source/js/ie-blocker.en.js","shasum":"96ca8e677a12048d099319ebdf01983ddc6ca80c","modified":1479284946000},{"_id":"themes/material/source/js/ie-blocker.zhCN.js","shasum":"0ed49b0ec1d1924b128fbd97fca2cf7af7856fdf","modified":1479284946000},{"_id":"themes/material/source/js/highlight.js","shasum":"5f6e3444d38c0b0d68dbf9595e08b4ba7736adcf","modified":1479284946000},{"_id":"source/uploads/PWD-tab.png","shasum":"7d0cb2668d525da55dbdcad4cce13cf19a7e3c60","modified":1465207995000},{"_id":"themes/material/source/js/smoothscroll.js","shasum":"dcad588e24280faf82daf70cf143226dd55af2ba","modified":1479284946000},{"_id":"source/uploads/PWD-tab-done.png","shasum":"3ca71db1f770265e95782104f05956db4554dd5e","modified":1465207995000},{"_id":"source/uploads/kill_tab.png","shasum":"2bf05a1b037524faf10d028dffe5d3e9994f86e1","modified":1465207995000},{"_id":"source/uploads/git-tab.png","shasum":"c02da4f31813bef77a58d18c085f0c313f0bbf95","modified":1465207995000},{"_id":"source/uploads/large_file1.png","shasum":"2d0acc9d0cbef5b5b1875dc8304c4ff4c4d0fd34","modified":1465207995000},{"_id":"themes/material/source/js/nprogress.js","shasum":"e7fcc9b70d4c3a0cadae226cbcefccdf09e5c8eb","modified":1479284946000},{"_id":"themes/material/source/css/style.css","shasum":"396bf3285e5b7c32daad7995370eed11b123a72b","modified":1479435840000},{"_id":"themes/material/source/css/material.min.css","shasum":"2f31cd708fc113471b013fa33d1f7fb926d0a9af","modified":1479284946000},{"_id":"themes/material/source/css/style.min.css","shasum":"c363ca81ff91c87f6e2c2ceec6675ca6b4fda887","modified":1479284946000},{"_id":"themes/material/source/fonts/FontAwesome.otf","shasum":"42c179eef588854b5ec151bcf6a3f58aa8b79b11","modified":1479284946000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.ttf","shasum":"fc05de31234e0090f7ddc28ce1b23af4026cb1da","modified":1479284946000},{"_id":"themes/material/source/fonts/fontawesome-webfont.eot","shasum":"986eed8dca049714e43eeebcb3932741a4bec76d","modified":1479284946000},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff","shasum":"4a313eb93b959cc4154c684b915b0a31ddb68d84","modified":1479284946000},{"_id":"themes/material/source/fonts/fontawesome-webfont.woff2","shasum":"638c652d623280a58144f93e7b552c66d1667a11","modified":1479284946000},{"_id":"themes/material/source/img/daily_pic.png","shasum":"5e9a5f6a134889d0242e69061837f2032416d7ce","modified":1479284946000},{"_id":"themes/material/source/img/logo.png","shasum":"966bbca62425517a6f24e5b615f8604f3c7443d3","modified":1479454184000},{"_id":"themes/material/source/js/jquery.min.js","shasum":"5d7e5bbfa540f0e53bd599e4305e1a4e815b5dd1","modified":1479284946000},{"_id":"themes/material/source/js/js.min.js","shasum":"d0ade9946b2c8f0ff251cd9473050ad863816066","modified":1479435840000},{"_id":"themes/material/source/css/material.css","shasum":"3c138cc7cf3d53c033471c6706b0d553b0b936bf","modified":1479435840000},{"_id":"themes/material/source/js/js.js","shasum":"751f40c30e234bb9a4307cec3b320128ff4b7eb5","modified":1479435840000},{"_id":"themes/material/source/fonts/MaterialIcons-Regular.eot","shasum":"26fb8cecb5512223277b4d290a24492a0f09ede1","modified":1479284946000},{"_id":"themes/material/source/fonts/fontawesome-webfont.ttf","shasum":"6484f1af6b485d5096b71b344e67f4164c33dd1f","modified":1479284946000},{"_id":"source/uploads/Classy_group_2.png","shasum":"8414c43333cbeb4fec80037e8d953b119d8c5ce0","modified":1465207995000},{"_id":"source/uploads/alias_git.png","shasum":"8625bfeb4080be854fca217dc0d494b973d730bc","modified":1465207995000},{"_id":"source/uploads/ClassyShark_com.png","shasum":"5e160919a5e8c1158ce007ab862209efb8289053","modified":1465207995000},{"_id":"themes/material/source/fonts/fontawesome-webfont.svg","shasum":"b06b5c8f67fd632cdc62a33b62ae4f74194131b3","modified":1479284946000},{"_id":"source/uploads/Classy_group.png","shasum":"7bb5dacaa7db71cd19a72b16a254e7b69868d5aa","modified":1465207995000},{"_id":"themes/material/source/fonts/Roboto-Medium.ttf","shasum":"3965419aab480c184f66bc5e39c1719a373a4ef6","modified":1479284946000},{"_id":"themes/material/source/fonts/Roboto-Light.ttf","shasum":"b9ea2eaf26ff8fdcb5aee3e0c2c7a6084ebb6aac","modified":1479284946000},{"_id":"themes/material/source/fonts/Roboto-Bold.ttf","shasum":"d1864343b543978bd491d40c80010cea50c1b7bf","modified":1479284946000},{"_id":"themes/material/source/fonts/Roboto-Black.ttf","shasum":"0244e6497a51fb8a38ca7e6fe297b066e2e09af5","modified":1479284946000},{"_id":"themes/material/source/fonts/Roboto-Thin.ttf","shasum":"ed5101c3a800f35e925603a406e0c2dc5278b96c","modified":1479284946000},{"_id":"themes/material/source/fonts/Roboto-Regular.ttf","shasum":"06691e103d4d3ce1f1108d9b7d21254b714a41f8","modified":1479284946000},{"_id":"source/uploads/walle.jpg","shasum":"75caacbb2105e4fbc763ab2fedcf56b4c2425ff4","modified":1465207995000}],"Category":[],"Data":[],"Page":[{"title":"tags","date":"2016-01-29T06:10:01.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2016-01-29 14:10:01\ntype: \"tags\"\nlayout: tags\n---\n","updated":"2016-11-24T08:07:12.000Z","path":"tags/index.html","_id":"civvtif5y0007whs6wz37o96o","comments":1},{"_content":"i","source":"ife_baidu/test.js","raw":"i","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/test.js","layout":"false","title":"","comments":1,"_id":"civvtif600008whs6zwrm2dyo"},{"_content":"<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>三段式布局</title>    \n<link rel=\"shortcut icon\" href=\"../img/favicon.ico\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\n<link rel=\"stylesheet\" href=\"task3.css\">   \n</head>\n<body>\n    <div class=\"content\">\n        <div class=\"team\">\n            <img src=\"../img/team-logo.jpg\">\n            <br><br>老中医<br>\n        </div>\n        <div class=\"person\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n        </div>\n        <div class=\"introduce\">\n            <p>老中医</p>\n            <p>老中医啊，专治吹牛逼</p>\n            <p>（以下为示例）</p>\n            <p>百度前端技术学院诞生于2014年，由百度最大规模的前端技术组织 EFE 团队发起成立。目前学院是由百度校园品牌部、百度多模交互搜索部以及百度校园招聘组联合组织的，面向大学生人群，免费的一个技术学习、交流与分享平台。</p>\n            <p>2016春季班概述</p>\n            <p>一年之计在于春，经过漫长的冬季，又是开学之际，众多莘莘学子纷纷又回到校园，投入学习之中。百度前端技术学院也在此时为大家带来了一道前端学习的饕鬄盛宴。经过2年多的尝试与摸索，我们确认了实践、交流与分享，对于技术学习而言，是非常有效且高效的手段，因此，本次春季班，我们特别搭建了一个线上平台系统，通过这个系统向学员们发送编码任务，学员们在这个系统上提交作业地址，进行相互的代码评审（Code Review）与评价，同时在平台中积累自己的学习总结笔记并分享给大家。为了让大家更加有动力进行这些学习方式，我们在整个春季班的学习过程中，融入了竞赛模式，任务完成得好的，评价仔细认真的，笔记写得对他人有帮助的，我们都会通过一套积分系统来进行排名。在头一个半月的任务“闯关”之后，我们还特意安排了一个很有挑战性，能够发挥大家创新能力的大任务环节，具体任务当然暂时保密。这个终极BOSS的挑战会作为整个春季班的最终环节。</p>\n        </div>\n    </div>\n</body>\n</html>","source":"ife_baidu/task3/task3.html","raw":"<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"UTF-8\">\n<title>三段式布局</title>    \n<link rel=\"shortcut icon\" href=\"../img/favicon.ico\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\">\n<link rel=\"stylesheet\" href=\"task3.css\">   \n</head>\n<body>\n    <div class=\"content\">\n        <div class=\"team\">\n            <img src=\"../img/team-logo.jpg\">\n            <br><br>老中医<br>\n        </div>\n        <div class=\"person\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n            <img src=\"../img/team-logo.jpg\">\n        </div>\n        <div class=\"introduce\">\n            <p>老中医</p>\n            <p>老中医啊，专治吹牛逼</p>\n            <p>（以下为示例）</p>\n            <p>百度前端技术学院诞生于2014年，由百度最大规模的前端技术组织 EFE 团队发起成立。目前学院是由百度校园品牌部、百度多模交互搜索部以及百度校园招聘组联合组织的，面向大学生人群，免费的一个技术学习、交流与分享平台。</p>\n            <p>2016春季班概述</p>\n            <p>一年之计在于春，经过漫长的冬季，又是开学之际，众多莘莘学子纷纷又回到校园，投入学习之中。百度前端技术学院也在此时为大家带来了一道前端学习的饕鬄盛宴。经过2年多的尝试与摸索，我们确认了实践、交流与分享，对于技术学习而言，是非常有效且高效的手段，因此，本次春季班，我们特别搭建了一个线上平台系统，通过这个系统向学员们发送编码任务，学员们在这个系统上提交作业地址，进行相互的代码评审（Code Review）与评价，同时在平台中积累自己的学习总结笔记并分享给大家。为了让大家更加有动力进行这些学习方式，我们在整个春季班的学习过程中，融入了竞赛模式，任务完成得好的，评价仔细认真的，笔记写得对他人有帮助的，我们都会通过一套积分系统来进行排名。在头一个半月的任务“闯关”之后，我们还特意安排了一个很有挑战性，能够发挥大家创新能力的大任务环节，具体任务当然暂时保密。这个终极BOSS的挑战会作为整个春季班的最终环节。</p>\n        </div>\n    </div>\n</body>\n</html>","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/task3/task3.html","title":"","comments":1,"layout":"page","_id":"civvtif620009whs67bsfsg0k"},{"_content":"* {\n\tmargin: 0;\n\tpadding: 0;\n}\n.content {\n\tmargin: 20px;\n\tpadding: 20px;\n\tbackground-color: #eee;\n\tborder: 1px solid #979797;\n\toverflow: auto;\n}\nimg {\n\tborder: 1px solid #979797;\n\twidth: 80px;\n\theight: 80px;\n}\n.team {\n\tfloat: left;\n\twidth: 200px;\n    border: 1px solid #979797;\n    font-size: 14px;\n    font-weight: 700;\n    background-color: #fff;\n}\n.team img {\n\tfloat: left;\n\tmargin: 20px 25px 20px 25px;\n}\n.person {\n\tfloat: right;\n\twidth: 120px;\n\tborder: 1px solid #979797;\n\tbackground-color: #fff;\n\ttext-align: center;\n\toverflow: auto;\n\tpadding: 10px 0;\n}\n.person img {\n   margin: 9px;\n}\n.introduce {\n\tbackground-color: #fff;\n\tmargin: 0 140px 0 220px;\n\tborder: 1px solid #979797;\n\tpadding: 20px;\n}\n.introduce p {\n\tmargin: 15px 0;\n}\n.introduce p:first-child {\n\tmargin-top: -5px;\n}","source":"ife_baidu/task3/task3.css","raw":"* {\n\tmargin: 0;\n\tpadding: 0;\n}\n.content {\n\tmargin: 20px;\n\tpadding: 20px;\n\tbackground-color: #eee;\n\tborder: 1px solid #979797;\n\toverflow: auto;\n}\nimg {\n\tborder: 1px solid #979797;\n\twidth: 80px;\n\theight: 80px;\n}\n.team {\n\tfloat: left;\n\twidth: 200px;\n    border: 1px solid #979797;\n    font-size: 14px;\n    font-weight: 700;\n    background-color: #fff;\n}\n.team img {\n\tfloat: left;\n\tmargin: 20px 25px 20px 25px;\n}\n.person {\n\tfloat: right;\n\twidth: 120px;\n\tborder: 1px solid #979797;\n\tbackground-color: #fff;\n\ttext-align: center;\n\toverflow: auto;\n\tpadding: 10px 0;\n}\n.person img {\n   margin: 9px;\n}\n.introduce {\n\tbackground-color: #fff;\n\tmargin: 0 140px 0 220px;\n\tborder: 1px solid #979797;\n\tpadding: 20px;\n}\n.introduce p {\n\tmargin: 15px 0;\n}\n.introduce p:first-child {\n\tmargin-top: -5px;\n}","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/task3/task3.css","layout":"false","title":"","comments":1,"_id":"civvtif63000awhs63zuf4w05"},{"_content":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\">\n    <title>任务二：零基础HTML及CSS编码（一）</title>\n</head>\n\n<body>\n    <section class=\"content\">\n        <header class=\"header\">\n            <img class=\"logo\" src=\"http://ife.baidu.com/asset/img/logo.png\">\n            <nav class=\"nav\">\n                <ul class=\"nav-list\">\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                </ul>\n            </nav>\n        </header>\n        <article>\n            <header>\n                <h2>文章一级标题</h2>\n                <h3>文章二级标题</h3>\n                <span class=\"author\">文章作者</span> <span class=\"time\">文章发表时间</span>\n            </header>\n            <br/>\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n            </p>\n            <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n            <br>\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n                </span>\n        </article>\n        <article>\n            <header>\n                <h2>令一篇文章一级标题</h2>\n                <h3>文章二级标题</h3>\n                <span class=\"author\">文章作者</span> <span class=\"time\">文章发表时间</span>\n            </header>\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n            </p>\n            <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n                </span>\n                <ul>\n                    <li>列表项目1</li>\n                    <li>列表项目2</li>\n                    <li>列表项目3</li>\n                    <li>列表项目4</li>\n                </ul>\n        </article>\n        <h3>图片</h3>\n        <article>\n            <h2>图片</h2>\n            <ul class=\"picList\">\n                <li>\n                    <h5>好看的图片</h5>\n                    <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                </li>\n            </ul>\n        </article>\n        <article>\n            <header>\n                <h2>最后一篇文章一级标题</h2>\n                <h3>文章二级标题</h3>\n                <span class=\"author\">文章作者</span> <span class=\"time\">文章发表时间</span>\n            </header>\n            <ol>\n                <li>\n                    排名1\n                </li>\n                <li>\n                    排名2\n                </li>\n                <li>\n                    排名3\n                </li>\n            </ol>\n            <p>\n                下面是一个表格，给表格加了一个border=\"1\"好让你看出是一个表格\n            </p>\n            <table>\n                <tr>\n                    <th>\n                        表头\n                    </th>\n                    <th>\n                        表头\n                    </th>\n                    <th>\n                        表头\n                    </th>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>总计</td>\n                    <td colspan=\"2\">1000</td>\n                </tr>\n            </table>\n        </article>\n        <aside>\n            <h2>这里以后是一个侧栏</h2>\n            <form action=\"#\" method=\"post\">\n                <div class=\"tableRow\">\n                    <p>请输入邮箱地址</p>\n                    <p>\n                        <input type=\"email\" name='email' placeholder=\"这是一个文本输入框\">\n                        <br><span class=\"msg\">邮箱地址请按格式输入</span>\n                        <br>\n                    </p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>请输入密码</p>\n                    <p>\n                        <input type=\"password\" name=\"password\">\n                        <br><span class=\"msg\">密码请为6-16位英文数字</span>\n                        <br>\n                    </p>\n                </div>\n                <br>\n                <div class=\"tableRow\">\n                    <p>性别</p>\n                    <p>\n                        <input type=\"radio\" name=\"sex\" value=\"1\"><span>男</span>\n                        <input type=\"radio\" name=\"sex\" value=\"0\"><span>女</span></p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>城市</p>\n                    <p>\n                        <select name=\"city\">\n                            <option value=\"Beijing\">北京</option>\n                        </select>\n                    </p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>爱好</p>\n                    <p>\n                        <input type=\"checkbox\" name=\"hobby\" value=\"1\"><span>运动</span>\n                        <input type=\"checkbox\" name=\"hobby\" value=\"2\"><span>艺术</span>\n                        <input type=\"checkbox\" name=\"hobby\" value=\"3\"><span>科学</span></p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>个人描述</p>\n                    <p>\n                        <textarea name=\"profile\" placeholder=\"这是一个多行输入框,输入您的个人描述\"></textarea>\n                    </p>\n                </div>\n            </form>\n            <button type=\"submit\">确认提交</button>\n        </aside>\n        <footer>\n            <p>版权所有&copy;</p>\n        </footer>\n    </section>\n</body>\n\n</html>\n","source":"ife_baidu/task2/index.html","raw":"<!DOCTYPE html>\n<html>\n\n<head>\n    <meta charset=\"utf-8\" />\n    <link rel=\"stylesheet\" type=\"text/css\" href=\"index.css\">\n    <title>任务二：零基础HTML及CSS编码（一）</title>\n</head>\n\n<body>\n    <section class=\"content\">\n        <header class=\"header\">\n            <img class=\"logo\" src=\"http://ife.baidu.com/asset/img/logo.png\">\n            <nav class=\"nav\">\n                <ul class=\"nav-list\">\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                    <li>\n                        <a href=\"http://www.baidu.com\">导航链接</a>\n                    </li>\n                </ul>\n            </nav>\n        </header>\n        <article>\n            <header>\n                <h2>文章一级标题</h2>\n                <h3>文章二级标题</h3>\n                <span class=\"author\">文章作者</span> <span class=\"time\">文章发表时间</span>\n            </header>\n            <br/>\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n            </p>\n            <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n            <br>\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n                </span>\n        </article>\n        <article>\n            <header>\n                <h2>令一篇文章一级标题</h2>\n                <h3>文章二级标题</h3>\n                <span class=\"author\">文章作者</span> <span class=\"time\">文章发表时间</span>\n            </header>\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n            </p>\n            <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n            <p>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落， 这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了\n                <br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\n                </span>\n                <ul>\n                    <li>列表项目1</li>\n                    <li>列表项目2</li>\n                    <li>列表项目3</li>\n                    <li>列表项目4</li>\n                </ul>\n        </article>\n        <h3>图片</h3>\n        <article>\n            <h2>图片</h2>\n            <ul class=\"picList\">\n                <li>\n                    <h5>好看的图片</h5>\n                    <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                    <li>\n                        <h5>好看的图片</h5>\n                        <img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n                    </li>\n                </li>\n            </ul>\n        </article>\n        <article>\n            <header>\n                <h2>最后一篇文章一级标题</h2>\n                <h3>文章二级标题</h3>\n                <span class=\"author\">文章作者</span> <span class=\"time\">文章发表时间</span>\n            </header>\n            <ol>\n                <li>\n                    排名1\n                </li>\n                <li>\n                    排名2\n                </li>\n                <li>\n                    排名3\n                </li>\n            </ol>\n            <p>\n                下面是一个表格，给表格加了一个border=\"1\"好让你看出是一个表格\n            </p>\n            <table>\n                <tr>\n                    <th>\n                        表头\n                    </th>\n                    <th>\n                        表头\n                    </th>\n                    <th>\n                        表头\n                    </th>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                    <td>\n                        表内单元内容\n                    </td>\n                </tr>\n                <tr>\n                    <td>总计</td>\n                    <td colspan=\"2\">1000</td>\n                </tr>\n            </table>\n        </article>\n        <aside>\n            <h2>这里以后是一个侧栏</h2>\n            <form action=\"#\" method=\"post\">\n                <div class=\"tableRow\">\n                    <p>请输入邮箱地址</p>\n                    <p>\n                        <input type=\"email\" name='email' placeholder=\"这是一个文本输入框\">\n                        <br><span class=\"msg\">邮箱地址请按格式输入</span>\n                        <br>\n                    </p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>请输入密码</p>\n                    <p>\n                        <input type=\"password\" name=\"password\">\n                        <br><span class=\"msg\">密码请为6-16位英文数字</span>\n                        <br>\n                    </p>\n                </div>\n                <br>\n                <div class=\"tableRow\">\n                    <p>性别</p>\n                    <p>\n                        <input type=\"radio\" name=\"sex\" value=\"1\"><span>男</span>\n                        <input type=\"radio\" name=\"sex\" value=\"0\"><span>女</span></p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>城市</p>\n                    <p>\n                        <select name=\"city\">\n                            <option value=\"Beijing\">北京</option>\n                        </select>\n                    </p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>爱好</p>\n                    <p>\n                        <input type=\"checkbox\" name=\"hobby\" value=\"1\"><span>运动</span>\n                        <input type=\"checkbox\" name=\"hobby\" value=\"2\"><span>艺术</span>\n                        <input type=\"checkbox\" name=\"hobby\" value=\"3\"><span>科学</span></p>\n                </div>\n                <div class=\"tableRow\">\n                    <p>个人描述</p>\n                    <p>\n                        <textarea name=\"profile\" placeholder=\"这是一个多行输入框,输入您的个人描述\"></textarea>\n                    </p>\n                </div>\n            </form>\n            <button type=\"submit\">确认提交</button>\n        </aside>\n        <footer>\n            <p>版权所有&copy;</p>\n        </footer>\n    </section>\n</body>\n\n</html>\n","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/task2/index.html","title":"","comments":1,"layout":"page","_id":"civvtif64000bwhs6k96jdzda"},{"_content":"/*全局*/\n\nbody {\n    background: #eee;\n    color: #333;\n    font-size: medium;\n}\n\n.content{\n    width: 1024px;\n    margin: 0 auto;\n}\n\n\n/*导航栏*/\n\n.header\n{\n    background: blue;\n    padding: 10px 0;\n    height: 50px;\n    width: 1024px;\n}\n\n.logo {\n    line-height: 100%;\n    float: left;\n}\n\nnav {\n    float: right;\n}\n\n.nav-list {\n}\n\n.nav-list li {\n    display: inline;\n}\n\nnav a:link,\nnav a:visited {\n    width: 120px;\n    font-weight: bold;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 4px;\n    text-decoration: none;\n    text-transform: uppercase;\n}\n\nnav a:hover,\nnav a:active {\n    background-color: #cc0000;\n}\n\n\n/*文章*/\n\narticle {\n    background: #fff;\n    padding: 20px;\n    margin-top: 20px;\n    box-shadow: 2px 2px 2px #aaa;\n}\n\narticle p {\n    text-indent: 2em;\n    line-height: 1.6em;\n}\n\n.author,\n.time {\n    color: gray;\n    font-size: 0.8em;\n}\n\n\n/*图片区*/\n\nul.picList {\n    list-style-type: none;\n}\n\nul.picList li {\n    list-style-type: none;\n    border: solid;\n    border-width: 1px;\n    text-align: center;\n    margin: 20px;\n    width: 200px;\n}\n\n\n/*排行*/\n\nol li {\n    font-weight: 900;\n}\n\ntable {\n    /*表格边框折叠为单一边框*/\n    border-collapse: collapse;\n    width: 100%;\n}\n\ntable tr th {\n    background: #333;\n    color: white;\n}\n\ntable,\ntd,\nth {\n    border: 1px solid darkgray;\n    text-align: left;\n    padding: 4px;\n}\n\nol+p {\n    text-indent: 0em;\n    line-height: 0em;\n}\n\naside {\n    background: #fff;\n    padding: 20px;\n    margin-top: 20px;\n    box-shadow: 2px 2px 2px #aaa;\n}\n\nform {\n    display: table;\n    margin: 0px;\n    width: 100%;\n}\n\n.tableRow {\n    display: table-row;\n}\n\n.tableRow p {\n    display: table-cell;\n    padding: 20px 20px 20px 20px;\n    vertical-align: top;\n}\n\n.tableRow p:first-child {\n    text-align: right;\n}\n\n.msg {\n    font: 0.8em gray;\n}\n\naside textarea {\n    height: 50px;\n    width: 400px;\n}\n\nbutton {\n    width: 100%;\n    background-color: rgb(51, 85, 208);\n    color: white;\n    border-radius: 5px;\n    margin: 0px;\n    text-align: center;\n}\n\nfooter {\n    background: black;\n    width: 1024px;\n    height: 80px;\n}\n\nfooter p {\n    top: 30%;\n    position: relative;\n    width: 100%;\n    text-align: center;\n    color: white;\n}\n","source":"ife_baidu/task2/index.css","raw":"/*全局*/\n\nbody {\n    background: #eee;\n    color: #333;\n    font-size: medium;\n}\n\n.content{\n    width: 1024px;\n    margin: 0 auto;\n}\n\n\n/*导航栏*/\n\n.header\n{\n    background: blue;\n    padding: 10px 0;\n    height: 50px;\n    width: 1024px;\n}\n\n.logo {\n    line-height: 100%;\n    float: left;\n}\n\nnav {\n    float: right;\n}\n\n.nav-list {\n}\n\n.nav-list li {\n    display: inline;\n}\n\nnav a:link,\nnav a:visited {\n    width: 120px;\n    font-weight: bold;\n    color: #FFFFFF;\n    text-align: center;\n    padding: 4px;\n    text-decoration: none;\n    text-transform: uppercase;\n}\n\nnav a:hover,\nnav a:active {\n    background-color: #cc0000;\n}\n\n\n/*文章*/\n\narticle {\n    background: #fff;\n    padding: 20px;\n    margin-top: 20px;\n    box-shadow: 2px 2px 2px #aaa;\n}\n\narticle p {\n    text-indent: 2em;\n    line-height: 1.6em;\n}\n\n.author,\n.time {\n    color: gray;\n    font-size: 0.8em;\n}\n\n\n/*图片区*/\n\nul.picList {\n    list-style-type: none;\n}\n\nul.picList li {\n    list-style-type: none;\n    border: solid;\n    border-width: 1px;\n    text-align: center;\n    margin: 20px;\n    width: 200px;\n}\n\n\n/*排行*/\n\nol li {\n    font-weight: 900;\n}\n\ntable {\n    /*表格边框折叠为单一边框*/\n    border-collapse: collapse;\n    width: 100%;\n}\n\ntable tr th {\n    background: #333;\n    color: white;\n}\n\ntable,\ntd,\nth {\n    border: 1px solid darkgray;\n    text-align: left;\n    padding: 4px;\n}\n\nol+p {\n    text-indent: 0em;\n    line-height: 0em;\n}\n\naside {\n    background: #fff;\n    padding: 20px;\n    margin-top: 20px;\n    box-shadow: 2px 2px 2px #aaa;\n}\n\nform {\n    display: table;\n    margin: 0px;\n    width: 100%;\n}\n\n.tableRow {\n    display: table-row;\n}\n\n.tableRow p {\n    display: table-cell;\n    padding: 20px 20px 20px 20px;\n    vertical-align: top;\n}\n\n.tableRow p:first-child {\n    text-align: right;\n}\n\n.msg {\n    font: 0.8em gray;\n}\n\naside textarea {\n    height: 50px;\n    width: 400px;\n}\n\nbutton {\n    width: 100%;\n    background-color: rgb(51, 85, 208);\n    color: white;\n    border-radius: 5px;\n    margin: 0px;\n    text-align: center;\n}\n\nfooter {\n    background: black;\n    width: 1024px;\n    height: 80px;\n}\n\nfooter p {\n    top: 30%;\n    position: relative;\n    width: 100%;\n    text-align: center;\n    color: white;\n}\n","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/task2/index.css","layout":"false","title":"","comments":1,"_id":"civvtif65000cwhs6yfrjodg2"},{"_content":"<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>task10</title>\n  <style>\n    .container {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n    }\n    .item {\n      flex: 0 0 auto;\n      width: 150px;\n      border: 1px solid #f00;\n    }\n    .item1 {\n      height: 120px;\n    }\n    .item2 {\n      height: 100px;\n    }\n    .item3 {\n      height: 40px;\n    }\n    .item4 {\n      height: 200px;\n      border-color: #0f0;\n    }\n    @media screen and (max-width: 640px) {\n      .container {\n        display: flex;\n        align-items: flex-start;\n        flex-wrap: wrap;\n      }\n      .item4 {\n        order: -1;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"item item1\">宽度 150px, 高度 120px, 边框颜色 #f00</div>\n    <div class=\"item item2\">宽度 150px, 高度 100px, 边框颜色 #f00</div>\n    <div class=\"item item3\">宽度 150px, 高度 40px, 边框颜色 #f00</div>\n    <div class=\"item item4\">宽度 150px, 高度 200px, 边框颜色 #0f0</div>\n  </div>\n</body>\n</html>","source":"ife_baidu/task10/index.html","raw":"<!DOCTYPE html>\n<html lang=\"zh-CN\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>task10</title>\n  <style>\n    .container {\n      display: flex;\n      align-items: center;\n      justify-content: space-between;\n    }\n    .item {\n      flex: 0 0 auto;\n      width: 150px;\n      border: 1px solid #f00;\n    }\n    .item1 {\n      height: 120px;\n    }\n    .item2 {\n      height: 100px;\n    }\n    .item3 {\n      height: 40px;\n    }\n    .item4 {\n      height: 200px;\n      border-color: #0f0;\n    }\n    @media screen and (max-width: 640px) {\n      .container {\n        display: flex;\n        align-items: flex-start;\n        flex-wrap: wrap;\n      }\n      .item4 {\n        order: -1;\n      }\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"item item1\">宽度 150px, 高度 120px, 边框颜色 #f00</div>\n    <div class=\"item item2\">宽度 150px, 高度 100px, 边框颜色 #f00</div>\n    <div class=\"item item3\">宽度 150px, 高度 40px, 边框颜色 #f00</div>\n    <div class=\"item item4\">宽度 150px, 高度 200px, 边框颜色 #0f0</div>\n  </div>\n</body>\n</html>","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/task10/index.html","title":"","comments":1,"layout":"page","_id":"civvtif66000dwhs65pl00lpf"},{"_content":"<!DOCTYPE html>\n<html>\n<head>\n\t<meta charset=\"utf-8\" /> \n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/task_002.css\">\n\t<title>ife_baidu level_1 task_001</title>\n</head>\n<body>\n\t<h1>这是网站一级标题</h1>\n\t<ul>\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t</ul>\n\t<h2>文章一级标题</h2>\n\t<h3>文章二级标题</h3>\n\t<div>文章作者 文章发表时间</div>\n\t<br/>\t\n\t<div>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，\n\t\t这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了<br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\t\n\t</body>\n\t<br>\n\n\t<div>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\n\t<div>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，\n\t\t这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了<br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\t\n\t</div>\n\t<br>\n\t<h2>令一篇文章一级标题</h2>\n\t<br>\n\t<div>\n\t\t<ul>\n\t\t\t<li>列表项目1</li>\n\t\t\t<li>列表项目2</li>\n\t\t\t<li>列表项目3</li>\n\t\t\t<li>列表项目4</li>\n\t\t</ul>\n\t</div>\n\t<br>\n\t<h3>图片</h3>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<h2>最后一篇文章一级标题</h2>\n\t<h3>文章二级标题</h3>\n\t<p>\n\t\t文章作者 文章发表时间\n\t</p>\n\t<br>\n\t<ol>\n\t\t<li>\n\t\t\t排名1\n\t\t</li>\n\t\t<li>\n\t\t\t排名2\n\t\t</li>\n\t\t<li>\n\t\t\t排名3\n\t\t</li>\n\t</ol>\n\t<br>\n\t<p>\n\t\t下面是一个表格，给表格加了一个border=\"1\"好让你看出是一个表格\n\t\t<br>\n\t\t<table border=\"1\">\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表头\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表头\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表头\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t操作\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t操作\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t操作\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t总计\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t1000000\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\t</p>\n\t<p>\n\t\t<h3>这里是一个侧边栏，这是侧边栏的标题</h3>\n\t\t<h3>侧边栏窗口标题</h3>\n\t</p>\n\t<div>\n\t\t<form>\n\t\t\t请输入邮箱地址： <input type=\"text\" name=\"email\"/>\n\t\t</form>\n\t\t<br>\n\t\t邮箱地址请安要求格式输入\n\t\t<br>\n\t\t<form>\n\t\t\t请输入密码： <input type=\"password\" name=\"password\"/> 请重复输入密码：<input type=\"password\" name=\"password\"/>\n\t\t</form>\n\t\t<br>\n\t\t性别：\n\t\t<form>\n\t\t\t<input type=\"radio\" name=\"sex\" value=\"male\"/> 男\t <input type=\"radio\" name=\"sex\" value=\"female\"/> 女\n\t\t</form>\n\t\t城市：\n\t\t<form>\n\t\t\t<select name=\"cities\">\n\t\t\t\t<option value=\"beijing\">\n\t\t\t\t\t北京\n\t\t\t\t</option>\n\t\t\t\t<option value=\"shanghai\">\n\t\t\t\t\t上海\n\t\t\t\t</option>\n\t\t\t\t<option value=\"guangzhou\">\n\t\t\t\t\t广州\n\t\t\t\t</option>\n\t\t\t</select>\n\t\t</form>\n\t\t爱好：\n\t\t<form>\n\t\t\t篮球\n\t\t\t<input type=\"checkbox\" name=\"basketball\"/>\n\t\t\t足球\n\t\t\t<input type=\"checkbox\" name=\"football\"/>\n\t\t</form>\n\t\t个人描述：\n\t\t<textarea rows=\"3\" cols=\"10\">\n\t\t</textarea>\n\t\t<form>\n\t\t\t<input type=\"button\" value=\"确认提交\"/>\n\t\t</form>\n\t</div>\n\t<div name=\"footer\">版权所有&copy</div>\n</body>\n</html>","source":"ife_baidu/task1/index.html","raw":"<!DOCTYPE html>\n<html>\n<head>\n\t<meta charset=\"utf-8\" /> \n\t<link rel=\"stylesheet\" type=\"text/css\" href=\"/css/task_002.css\">\n\t<title>ife_baidu level_1 task_001</title>\n</head>\n<body>\n\t<h1>这是网站一级标题</h1>\n\t<ul>\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t\t<li>\n\t\t\t<a href=\"http://www.baidu.com\">导航链接</a>\n\t\t</li>\t\n\t</ul>\n\t<h2>文章一级标题</h2>\n\t<h3>文章二级标题</h3>\n\t<div>文章作者 文章发表时间</div>\n\t<br/>\t\n\t<div>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，\n\t\t这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了<br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\t\n\t</body>\n\t<br>\n\n\t<div>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\n\t<div>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，\n\t\t这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这里换行了<br /> 这是一个很长的段落，这是一个很长的段落，<a href=\"http://ife.baidu.com\">这里有一个链接</a>这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落，这是一个很长的段落。\t\n\t</div>\n\t<br>\n\t<h2>令一篇文章一级标题</h2>\n\t<br>\n\t<div>\n\t\t<ul>\n\t\t\t<li>列表项目1</li>\n\t\t\t<li>列表项目2</li>\n\t\t\t<li>列表项目3</li>\n\t\t\t<li>列表项目4</li>\n\t\t</ul>\n\t</div>\n\t<br>\n\t<h3>图片</h3>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<div>\n\t\t好看的图片：\n\t\t<br>\n\t\t<img src=\"http://ww3.sinaimg.cn/large/4bf31e43jw1f1vgky6pprj20dt0kumzi.jpg\" width=\"150\">\n\t</div>\n\t<br>\n\t<h2>最后一篇文章一级标题</h2>\n\t<h3>文章二级标题</h3>\n\t<p>\n\t\t文章作者 文章发表时间\n\t</p>\n\t<br>\n\t<ol>\n\t\t<li>\n\t\t\t排名1\n\t\t</li>\n\t\t<li>\n\t\t\t排名2\n\t\t</li>\n\t\t<li>\n\t\t\t排名3\n\t\t</li>\n\t</ol>\n\t<br>\n\t<p>\n\t\t下面是一个表格，给表格加了一个border=\"1\"好让你看出是一个表格\n\t\t<br>\n\t\t<table border=\"1\">\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表头\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表头\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表头\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t操作\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t操作\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t表内容单元格\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t操作\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t\t<tr>\n\t\t\t\t<td>\n\t\t\t\t\t总计\n\t\t\t\t</td>\n\t\t\t\t<td>\n\t\t\t\t\t1000000\n\t\t\t\t</td>\n\t\t\t</tr>\n\t\t</table>\n\t</p>\n\t<p>\n\t\t<h3>这里是一个侧边栏，这是侧边栏的标题</h3>\n\t\t<h3>侧边栏窗口标题</h3>\n\t</p>\n\t<div>\n\t\t<form>\n\t\t\t请输入邮箱地址： <input type=\"text\" name=\"email\"/>\n\t\t</form>\n\t\t<br>\n\t\t邮箱地址请安要求格式输入\n\t\t<br>\n\t\t<form>\n\t\t\t请输入密码： <input type=\"password\" name=\"password\"/> 请重复输入密码：<input type=\"password\" name=\"password\"/>\n\t\t</form>\n\t\t<br>\n\t\t性别：\n\t\t<form>\n\t\t\t<input type=\"radio\" name=\"sex\" value=\"male\"/> 男\t <input type=\"radio\" name=\"sex\" value=\"female\"/> 女\n\t\t</form>\n\t\t城市：\n\t\t<form>\n\t\t\t<select name=\"cities\">\n\t\t\t\t<option value=\"beijing\">\n\t\t\t\t\t北京\n\t\t\t\t</option>\n\t\t\t\t<option value=\"shanghai\">\n\t\t\t\t\t上海\n\t\t\t\t</option>\n\t\t\t\t<option value=\"guangzhou\">\n\t\t\t\t\t广州\n\t\t\t\t</option>\n\t\t\t</select>\n\t\t</form>\n\t\t爱好：\n\t\t<form>\n\t\t\t篮球\n\t\t\t<input type=\"checkbox\" name=\"basketball\"/>\n\t\t\t足球\n\t\t\t<input type=\"checkbox\" name=\"football\"/>\n\t\t</form>\n\t\t个人描述：\n\t\t<textarea rows=\"3\" cols=\"10\">\n\t\t</textarea>\n\t\t<form>\n\t\t\t<input type=\"button\" value=\"确认提交\"/>\n\t\t</form>\n\t</div>\n\t<div name=\"footer\">版权所有&copy</div>\n</body>\n</html>","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"ife_baidu/task1/index.html","title":"","comments":1,"layout":"page","_id":"civvtif68000ewhs6ug8ws6wg"},{"title":"留言","date":"2016-01-29T07:50:47.000Z","thumbnail":"https://api.i-meto.com/bing?new&blur","_content":"<blockquote class=\"blockquote-center\">\n<p align=\"center\" ><b> 也要楚天阔，也要大江流；</b></p>\n<p align=\"center\"><b> 也要望不见前后，才能对月下酒。</b></p>\n</blockquote>\n<br/>\n>最近访客\n\n<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n","source":"guestbook/index.md","raw":"---\ntitle: 留言\ndate: 2016-01-29 15:50:47\nthumbnail: https://api.i-meto.com/bing?new&blur\n---\n<blockquote class=\"blockquote-center\">\n<p align=\"center\" ><b> 也要楚天阔，也要大江流；</b></p>\n<p align=\"center\"><b> 也要望不见前后，才能对月下酒。</b></p>\n</blockquote>\n<br/>\n>最近访客\n\n<div class=\"ds-recent-visitors\" data-num-items=\"28\" data-avatar-size=\"42\" id=\"ds-recent-visitors\"></div>\n","updated":"2016-11-17T09:19:44.000Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"civvtif6a000fwhs6gj643sts"},{"layout":"false","_content":"google-site-verification: google242d671fbb406072.html\n","source":"google242d671fbb406072.html","raw":"layout: false\n---\ngoogle-site-verification: google242d671fbb406072.html\n","date":"2016-06-06T10:13:15.000Z","updated":"2016-06-06T10:13:15.000Z","path":"google242d671fbb406072.html","title":"","comments":1,"_id":"civvtif6c000gwhs6nj82jpah"}],"Post":[{"title":"AndFix支持Multidex的解决方案","date":"2016-03-13T13:42:11.000Z","_content":"\n\n# 背景\n在上一篇文章[Android热补丁之AndFix原理解析](http://w4lle.github.io/2016/03/03/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E4%B9%8BAndFix%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/)中我们提到，AndFix的补丁文件是补丁生成工具apkPatch生成的，补丁文件``.apatch``基于``dex diff``的原理生成，简单来说就是对比两个apk包中的dex文件，代码在``DexFileFactory``类中\n\n```java\npublic static DexBackedDexFile loadDexFile(File dexFile, int api, boolean experimental) throws IOException\n  {\n    return loadDexFile(dexFile, \"classes.dex\", new Opcodes(api, experimental));\n  }\n```\n\n上面可以看到，只提取了apk包中的classes.dex文件，对于支持现阶段基本上所有的项目都是基于multidex方案的，那么如果apk包中有多个dex文件的话，AndFix的补丁工具就不会生效了。\n\n# 解决方案\n\n## 自己重新写一个工具\n补丁生成工具apkPatch是一个jar文件，但是阿里团队并没有开源它的具体实现，我们也只能通过反编译来分析它，所以如果要重新写一个的话，要根据反编译全部重新敲一遍代码，只在关键的部分修改代码来达到支持multidex的目的。但是这种方式很低级，效率太低。\n\n## 反射\n\n大家都知道，Java代码编译完会生成.class文件，就是一堆字节码。JVM会解释执行这些字节码，由于字节码的解释执行是在运行时进行的，那我们能否手工编写字节码，再由JVM执行呢？答案是肯定的。\n\n在``com.euler.patch.diff.DexDiffer``类中，抽取dex文件并进行对比\n\n```java\npublic DiffInfo diff(File newFile, File oldFile)\n    throws IOException\n  {\n    DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, \n      true);\n    DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19, \n      true);\n      ....\n   }\n```\n修改为\n\n```java\npublic DiffInfo diff(File newFile, File oldFile) throws IOException {\n\n    \tHashSet<DexBackedClassDef> newset = getClassSet(newFile);\n    \tHashSet<DexBackedClassDef> oldset = getClassSet(oldFile);\n        DiffInfo info = DiffInfo.getInstance();\n\n        boolean contains = false;\n        Iterator<DexBackedClassDef> iter = newset.iterator();\n        while (iter.hasNext()) {\n            DexBackedClassDef newClazz = iter.next();\n            Iterator<DexBackedClassDef> iter2 = oldset.iterator();\n            contains = false;\n            while (iter2.hasNext()) {\n                DexBackedClassDef oldClazz = iter2.next();\n                if (newClazz.equals(oldClazz)) {\n                    compareField(newClazz, oldClazz, info);\n                    compareMethod(newClazz, oldClazz, info);\n                    contains = true;\n                    break;\n                }\n            }\n            if (!contains) {\n                info.addAddedClasses(newClazz);\n            }\n        }\n        return info;\n    }\n```\n\n抽取dex的``getClassSet``方法\n\n```java\n   private HashSet<DexBackedClassDef> getClassSet(File apkFile) throws IOException{\n    \tZipFile localZipFile = new ZipFile(apkFile);\n    \tEnumeration localEnumeration = localZipFile.entries();\n    \tHashSet<DexBackedClassDef> newset = new HashSet<DexBackedClassDef>();\n    \twhile (localEnumeration.hasMoreElements()) {\n\t\t\tZipEntry localZipEntry = (ZipEntry) localEnumeration.nextElement();\n\t\t\t//所有以.dex结尾的文件都会加载。这样就支持的multidex\n\t\t\tif (localZipEntry.getName().endsWith(\".dex\")) {\n\t\t\t\tDexBackedDexFile newDexFile = DexFileFactory.loadDexFile(apkFile, localZipEntry.getName(), 19, true);\n\t\t\t\tFixedSizeSet<DexBackedClassDef> newclasses = (FixedSizeSet) newDexFile.getClasses();\n\t\t\t\tmergeHashSet(newset, newclasses);\n\t\t\t}\n\t\t}\n    \treturn newset;\n    }\n```\n然后将``DexDiffer``这个类单独达成一个jar包``dexdiffer.jar``，用于替换``apkPatch.jar``包中的``DexDiffer``类。加载的时候动态替换。\n\n新增一个main.jar包，``Main.java``类\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        try {\n            OriginLoader oloader = getOriginClassLoader(Main.class.getClassLoader());\n            FixLoader floader = getFixClassLoader(Main.class.getClassLoader());\n            oloader.otherClassLoder = floader;\n            oloader.otherLoadClassName = \"com.euler.patch.diff.DexDiffer\";\n            floader.otherClassLoder = oloader;\n            Class mainClass = oloader.loadClass(\"com.euler.patch.Main\");\n            //通过反射得到apkpatch.jar中的main()方法\n            Method mainMethod = mainClass.getDeclaredMethod(\"main\", String[].class);\n            mainMethod.setAccessible(true);\n            //执行apkpatch.jar中的main()方法\n            mainMethod.invoke(mainClass, (Object)(args));\n        }\n\n    private static OriginLoader getOriginClassLoader(ClassLoader parent) throws MalformedURLException {\n        URL[] urls = new URL[] {};\n        OriginLoader loader = new OriginLoader(urls, parent);\n        String path = Main.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n        int index = path.lastIndexOf(File.separator) + 1;\n        path = path.substring(0, index);\n        path = path + \"apkpatch.jar\";\n        loader.addJar(new File(path).toURI().toURL());\n        return loader;\n    }\n    \n    private static FixLoader getFixClassLoader(ClassLoader parent) throws MalformedURLException {\n        URL[] urls = new URL[] {};\n        FixLoader loader = new FixLoader(urls, parent);\n        String path = Main.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n        int index = path.lastIndexOf(File.separator) + 1;\n        path = path.substring(0, index);\n        path = path + \"dexdiffer.jar\";\n        loader.addJar(new File(path).toURI().toURL());\n        return loader;\n    }\n}\n```\n工具的入口由``apkpatch.jar``的``main()``方法改为了``main.jar``的``main()``方法。所以在这里我们就可以动态替换相关的关键类和方法。\n\n``OriginLoader``的方法``findClass``方法\n\n```java\n@Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        Class clazz = null;\n        //上面设置的oloader.otherLoadClassName = \t\t\t//\"com.euler.patch.diff.DexDiffer\";\n        if(name.equals(otherLoadClassName)){\n            return otherClassLoder.loadClass(name);\n        }\n        clazz = super.findClass(name);\n        return clazz;\n    }\n```\n也就是说``OriginLoader``在加载的时候如果类是``com.euler.patch.diff.DexDiffer``，那么就会调用``FixLoader``去加载我们刚刚生成的``dexdiff.jar``中的``DexDiffer``达到替换的目的。\n``apkpatch.sh``\n\n```java\nPRG=\"$0\"\nwhile [ -h \"$PRG\" ] ; do\n  ls=`ls -ld \"$PRG\"`\n  link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n  if expr \"$link\" : '/.*' > /dev/null; then\n    PRG=\"$link\"\n  else\n    PRG=`dirname \"$PRG\"`/\"$link\"\n  fi\ndone\nPRGDIR=`dirname \"$PRG\"`\n//入口改为main.jar\njava -Xms512m -Xmx1024m -jar $PRGDIR/main.jar \"$@\"\n```\n\n最后的jar包有4个，main.jar, dexdiffer.jar, apkpatch.jar\n方法代码参考[这里](https://github.com/w4lle/andfix_apkpatch_support_multidex/blob/master/apkpatch.sh)\n\n## javassist修改class文件\n[javassist](https://github.com/jboss-javassist/javassist)其实就是一个二方包，提供了运行时操作Java字节码的方法。Javassist就提供了一些方便的方法，让我们通过这些方法生成字节码。最后也是通过反射调用修改后的方法。\n\n使用方法\n\n```java\n\t//Classpool负责用Javassist来控制字节码的修改\n\tClassPool cp = ClassPool.getDefault();\n\t//获得类文件名\n\tCtClass cc = cp.get(\"com.euler.patch.diff.DexDiffer\");\n\t//获得要修改的方法名\n\tCtMethod m = cc.getDeclaredMethod(\"diff\");\n\tCtMethod.setBody(“这里是修改后的代码”); \n\tCtClass.addMethod(ctMethod);  \n    Class<?> c=CtClass.toClass();  \n    Object o=c.newInstance();  \n    Method method=o.getClass().getMethod(\"diff\", new Class[]{});  \n    //调用字节码生成类的diff方法  \n    method.invoke(o, new Object[]{});  \n\n```\n\n生成``.class``文件，然后替换``apkpatch.jar``包中的``.class``文件。\n这种方法只用一个jar包就可以完成生成补丁的操作。\n\n# 最后一步\n\n先看代码，``AndFixaManager``\n\n```java\n public synchronized void fix(File file, ClassLoader classLoader,\n                                 List<String> classes) {\n        final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),\n                    optfile.getAbsolutePath(), Context.MODE_PRIVATE);\n\n            if (saveFingerprint) {\n                mSecurityChecker.saveOptSig(optfile);\n            }\n\n            ClassLoader patchClassLoader = new ClassLoader(classLoader) {\n                @Override\n                protected Class<?> findClass(String className)\n                        throws ClassNotFoundException {\n                        // 代码1\n                    Class<?> clazz = dexFile.loadClass(className, this);\n                    if (clazz == null\n                            && className.startsWith(\"com.alipay.euler.andfix\")) {\n                        return Class.forName(className);// annotation’s class\n                        // not found\n                    }\n                    \n                    //代码2\n                    //add fix w4lle for multidex surpport\n                    if (clazz == null) {\n                        return Class.forName(className);\n                    }\n                    //add end\n                    \n                    if (clazz == null) {\n                        throw new ClassNotFoundException(className);\n                    }\n                    return clazz;\n                }\n            };\n  }\n ```\n\n代码1处通过``classLoader``去加载目标类，但是有一点要明确，一个运行的Android应用至少有2个``ClassLoader``，一个是``BootClassLoader``（系统启动的时候创建的），另外一个或多个是``PathClassLoader``用于加载dex，每个dex文件由一个独立的``PathClassLoader``去加载。也就是说如果目标类在dex2中，代码1是加载不了目标类的，所以会抛出``ClassNotFoundException``。就像这样\n\n```java\nCaused by: java.lang.ClassNotFoundException: Didn't find class \"com.boohee.status.MsgCategoryActivity$2_CF\" on path: DexPathList[[zip file \"/data/app/com.boohee.one-1.apk\", zip file \"/data/data/com.boohee.one/code_cache/secondary-dexes/com.boohee.one-1.apk.classes2.zip\"],nativeLibraryDirectories=[/data/app-lib/com.boohee.one-1, /vendor/lib, /system/lib]]\n\tat dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:511)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:469)\n```\n\n所以我们在代码2处添加了保护代码，保证目标类可以被加载。由于andfix官方并没有做这个支持，所以就不能通过gradle依赖，就需要我们把andfix的源码放到项目中然后修改。\n\n\n# 参考\n\n* [Android动态加载基础 ClassLoader工作机制](https://segmentfault.com/a/1190000004062880)\n\n项目地址：[AndFix](https://github.com/alibaba/AndFix)，本文分析版本：[AndFix:0.3.1](https://github.com/alibaba/AndFix/tree/c68d9811bd756ee418fce761ca113376ec9c4e66)","source":"_posts/AndFix支持multidex解决方案.md","raw":"---\ntitle: AndFix支持Multidex的解决方案\ndate: 2016-03-13 21:42:11\ntags: [AndFix, 热更新, multidex]\n---\n\n\n# 背景\n在上一篇文章[Android热补丁之AndFix原理解析](http://w4lle.github.io/2016/03/03/Android%E7%83%AD%E8%A1%A5%E4%B8%81%E4%B9%8BAndFix%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/)中我们提到，AndFix的补丁文件是补丁生成工具apkPatch生成的，补丁文件``.apatch``基于``dex diff``的原理生成，简单来说就是对比两个apk包中的dex文件，代码在``DexFileFactory``类中\n\n```java\npublic static DexBackedDexFile loadDexFile(File dexFile, int api, boolean experimental) throws IOException\n  {\n    return loadDexFile(dexFile, \"classes.dex\", new Opcodes(api, experimental));\n  }\n```\n\n上面可以看到，只提取了apk包中的classes.dex文件，对于支持现阶段基本上所有的项目都是基于multidex方案的，那么如果apk包中有多个dex文件的话，AndFix的补丁工具就不会生效了。\n\n# 解决方案\n\n## 自己重新写一个工具\n补丁生成工具apkPatch是一个jar文件，但是阿里团队并没有开源它的具体实现，我们也只能通过反编译来分析它，所以如果要重新写一个的话，要根据反编译全部重新敲一遍代码，只在关键的部分修改代码来达到支持multidex的目的。但是这种方式很低级，效率太低。\n\n## 反射\n\n大家都知道，Java代码编译完会生成.class文件，就是一堆字节码。JVM会解释执行这些字节码，由于字节码的解释执行是在运行时进行的，那我们能否手工编写字节码，再由JVM执行呢？答案是肯定的。\n\n在``com.euler.patch.diff.DexDiffer``类中，抽取dex文件并进行对比\n\n```java\npublic DiffInfo diff(File newFile, File oldFile)\n    throws IOException\n  {\n    DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, \n      true);\n    DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19, \n      true);\n      ....\n   }\n```\n修改为\n\n```java\npublic DiffInfo diff(File newFile, File oldFile) throws IOException {\n\n    \tHashSet<DexBackedClassDef> newset = getClassSet(newFile);\n    \tHashSet<DexBackedClassDef> oldset = getClassSet(oldFile);\n        DiffInfo info = DiffInfo.getInstance();\n\n        boolean contains = false;\n        Iterator<DexBackedClassDef> iter = newset.iterator();\n        while (iter.hasNext()) {\n            DexBackedClassDef newClazz = iter.next();\n            Iterator<DexBackedClassDef> iter2 = oldset.iterator();\n            contains = false;\n            while (iter2.hasNext()) {\n                DexBackedClassDef oldClazz = iter2.next();\n                if (newClazz.equals(oldClazz)) {\n                    compareField(newClazz, oldClazz, info);\n                    compareMethod(newClazz, oldClazz, info);\n                    contains = true;\n                    break;\n                }\n            }\n            if (!contains) {\n                info.addAddedClasses(newClazz);\n            }\n        }\n        return info;\n    }\n```\n\n抽取dex的``getClassSet``方法\n\n```java\n   private HashSet<DexBackedClassDef> getClassSet(File apkFile) throws IOException{\n    \tZipFile localZipFile = new ZipFile(apkFile);\n    \tEnumeration localEnumeration = localZipFile.entries();\n    \tHashSet<DexBackedClassDef> newset = new HashSet<DexBackedClassDef>();\n    \twhile (localEnumeration.hasMoreElements()) {\n\t\t\tZipEntry localZipEntry = (ZipEntry) localEnumeration.nextElement();\n\t\t\t//所有以.dex结尾的文件都会加载。这样就支持的multidex\n\t\t\tif (localZipEntry.getName().endsWith(\".dex\")) {\n\t\t\t\tDexBackedDexFile newDexFile = DexFileFactory.loadDexFile(apkFile, localZipEntry.getName(), 19, true);\n\t\t\t\tFixedSizeSet<DexBackedClassDef> newclasses = (FixedSizeSet) newDexFile.getClasses();\n\t\t\t\tmergeHashSet(newset, newclasses);\n\t\t\t}\n\t\t}\n    \treturn newset;\n    }\n```\n然后将``DexDiffer``这个类单独达成一个jar包``dexdiffer.jar``，用于替换``apkPatch.jar``包中的``DexDiffer``类。加载的时候动态替换。\n\n新增一个main.jar包，``Main.java``类\n\n```java\npublic class Main {\n\n    public static void main(String[] args) {\n        try {\n            OriginLoader oloader = getOriginClassLoader(Main.class.getClassLoader());\n            FixLoader floader = getFixClassLoader(Main.class.getClassLoader());\n            oloader.otherClassLoder = floader;\n            oloader.otherLoadClassName = \"com.euler.patch.diff.DexDiffer\";\n            floader.otherClassLoder = oloader;\n            Class mainClass = oloader.loadClass(\"com.euler.patch.Main\");\n            //通过反射得到apkpatch.jar中的main()方法\n            Method mainMethod = mainClass.getDeclaredMethod(\"main\", String[].class);\n            mainMethod.setAccessible(true);\n            //执行apkpatch.jar中的main()方法\n            mainMethod.invoke(mainClass, (Object)(args));\n        }\n\n    private static OriginLoader getOriginClassLoader(ClassLoader parent) throws MalformedURLException {\n        URL[] urls = new URL[] {};\n        OriginLoader loader = new OriginLoader(urls, parent);\n        String path = Main.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n        int index = path.lastIndexOf(File.separator) + 1;\n        path = path.substring(0, index);\n        path = path + \"apkpatch.jar\";\n        loader.addJar(new File(path).toURI().toURL());\n        return loader;\n    }\n    \n    private static FixLoader getFixClassLoader(ClassLoader parent) throws MalformedURLException {\n        URL[] urls = new URL[] {};\n        FixLoader loader = new FixLoader(urls, parent);\n        String path = Main.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n        int index = path.lastIndexOf(File.separator) + 1;\n        path = path.substring(0, index);\n        path = path + \"dexdiffer.jar\";\n        loader.addJar(new File(path).toURI().toURL());\n        return loader;\n    }\n}\n```\n工具的入口由``apkpatch.jar``的``main()``方法改为了``main.jar``的``main()``方法。所以在这里我们就可以动态替换相关的关键类和方法。\n\n``OriginLoader``的方法``findClass``方法\n\n```java\n@Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        Class clazz = null;\n        //上面设置的oloader.otherLoadClassName = \t\t\t//\"com.euler.patch.diff.DexDiffer\";\n        if(name.equals(otherLoadClassName)){\n            return otherClassLoder.loadClass(name);\n        }\n        clazz = super.findClass(name);\n        return clazz;\n    }\n```\n也就是说``OriginLoader``在加载的时候如果类是``com.euler.patch.diff.DexDiffer``，那么就会调用``FixLoader``去加载我们刚刚生成的``dexdiff.jar``中的``DexDiffer``达到替换的目的。\n``apkpatch.sh``\n\n```java\nPRG=\"$0\"\nwhile [ -h \"$PRG\" ] ; do\n  ls=`ls -ld \"$PRG\"`\n  link=`expr \"$ls\" : '.*-> \\(.*\\)$'`\n  if expr \"$link\" : '/.*' > /dev/null; then\n    PRG=\"$link\"\n  else\n    PRG=`dirname \"$PRG\"`/\"$link\"\n  fi\ndone\nPRGDIR=`dirname \"$PRG\"`\n//入口改为main.jar\njava -Xms512m -Xmx1024m -jar $PRGDIR/main.jar \"$@\"\n```\n\n最后的jar包有4个，main.jar, dexdiffer.jar, apkpatch.jar\n方法代码参考[这里](https://github.com/w4lle/andfix_apkpatch_support_multidex/blob/master/apkpatch.sh)\n\n## javassist修改class文件\n[javassist](https://github.com/jboss-javassist/javassist)其实就是一个二方包，提供了运行时操作Java字节码的方法。Javassist就提供了一些方便的方法，让我们通过这些方法生成字节码。最后也是通过反射调用修改后的方法。\n\n使用方法\n\n```java\n\t//Classpool负责用Javassist来控制字节码的修改\n\tClassPool cp = ClassPool.getDefault();\n\t//获得类文件名\n\tCtClass cc = cp.get(\"com.euler.patch.diff.DexDiffer\");\n\t//获得要修改的方法名\n\tCtMethod m = cc.getDeclaredMethod(\"diff\");\n\tCtMethod.setBody(“这里是修改后的代码”); \n\tCtClass.addMethod(ctMethod);  \n    Class<?> c=CtClass.toClass();  \n    Object o=c.newInstance();  \n    Method method=o.getClass().getMethod(\"diff\", new Class[]{});  \n    //调用字节码生成类的diff方法  \n    method.invoke(o, new Object[]{});  \n\n```\n\n生成``.class``文件，然后替换``apkpatch.jar``包中的``.class``文件。\n这种方法只用一个jar包就可以完成生成补丁的操作。\n\n# 最后一步\n\n先看代码，``AndFixaManager``\n\n```java\n public synchronized void fix(File file, ClassLoader classLoader,\n                                 List<String> classes) {\n        final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(),\n                    optfile.getAbsolutePath(), Context.MODE_PRIVATE);\n\n            if (saveFingerprint) {\n                mSecurityChecker.saveOptSig(optfile);\n            }\n\n            ClassLoader patchClassLoader = new ClassLoader(classLoader) {\n                @Override\n                protected Class<?> findClass(String className)\n                        throws ClassNotFoundException {\n                        // 代码1\n                    Class<?> clazz = dexFile.loadClass(className, this);\n                    if (clazz == null\n                            && className.startsWith(\"com.alipay.euler.andfix\")) {\n                        return Class.forName(className);// annotation’s class\n                        // not found\n                    }\n                    \n                    //代码2\n                    //add fix w4lle for multidex surpport\n                    if (clazz == null) {\n                        return Class.forName(className);\n                    }\n                    //add end\n                    \n                    if (clazz == null) {\n                        throw new ClassNotFoundException(className);\n                    }\n                    return clazz;\n                }\n            };\n  }\n ```\n\n代码1处通过``classLoader``去加载目标类，但是有一点要明确，一个运行的Android应用至少有2个``ClassLoader``，一个是``BootClassLoader``（系统启动的时候创建的），另外一个或多个是``PathClassLoader``用于加载dex，每个dex文件由一个独立的``PathClassLoader``去加载。也就是说如果目标类在dex2中，代码1是加载不了目标类的，所以会抛出``ClassNotFoundException``。就像这样\n\n```java\nCaused by: java.lang.ClassNotFoundException: Didn't find class \"com.boohee.status.MsgCategoryActivity$2_CF\" on path: DexPathList[[zip file \"/data/app/com.boohee.one-1.apk\", zip file \"/data/data/com.boohee.one/code_cache/secondary-dexes/com.boohee.one-1.apk.classes2.zip\"],nativeLibraryDirectories=[/data/app-lib/com.boohee.one-1, /vendor/lib, /system/lib]]\n\tat dalvik.system.BaseDexClassLoader.findClass(BaseDexClassLoader.java:56)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:511)\n\tat java.lang.ClassLoader.loadClass(ClassLoader.java:469)\n```\n\n所以我们在代码2处添加了保护代码，保证目标类可以被加载。由于andfix官方并没有做这个支持，所以就不能通过gradle依赖，就需要我们把andfix的源码放到项目中然后修改。\n\n\n# 参考\n\n* [Android动态加载基础 ClassLoader工作机制](https://segmentfault.com/a/1190000004062880)\n\n项目地址：[AndFix](https://github.com/alibaba/AndFix)，本文分析版本：[AndFix:0.3.1](https://github.com/alibaba/AndFix/tree/c68d9811bd756ee418fce761ca113376ec9c4e66)","slug":"AndFix支持multidex解决方案","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif5k0000whs6jvlwkjkf"},{"title":"终极Shell--Zsh 使用技巧","date":"2016-01-31T17:51:36.000Z","_content":"## 为什么要用Zsh\n请参考这篇文章[终极 Shell](http://macshuo.com/?p=676)\n\n## Zsh使用技巧\n### 巧用``tab``\n#### 自动完成\n``tab``用到最多的就是自动完成,比如``cd``进入某个目录，可以输入该目录的中的几个字母，然后``tab``自动补全。\n你不必输入整个目录名称，只需输入初始几个可以唯一区别与其他目录的字母，Zsh会自动匹配出剩余部分。\n![此处输入图片的描述](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/QQ20160131-1%402x.png)\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/tab.png)\n#### 环境变量展开\n在Zsh中，你可以按下<TAB>键来展开shell中的环境变量值\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/PWD-tab.png)\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/PWD-tab-done.png)\n#### kill命令补全\n通常我们想要杀死某个进程，一般都要先``ps``下查看进程，然后``kill``杀掉。使用``zsh``可以这样\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/kill_tab.png)\n#### help命令\n对于我们不熟悉的命令行，一般都会``--help``查看帮助文档，而zsh可以直接敲你想要的命令，比如这样\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/git-tab.png)\n\n### 强大的历史记录\n类UNIX系统通常都习惯于``ctrl+r``的方式查找命令行的历史记录，挺好用的。但是``zsh``有更强大的历史搜索，比如``UP``\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/UP1.png)\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/UP2.png)\n意思是上方向键能帮你找到最近使用的以``./gradlew``开头的命令，``UP`` ``DOWN``可以循环查找\n### 强大的``alias``别名\n平时工作基本都用``git``管理项目代码，每个人都有习惯使用的``git``别名，``zsh``为我们提供了一套通用的``alias``,即使换了工作环境，只要有``zsh``那么一套``alias``全部搞定。在该文件下可以看到``~/.oh-my-zsh/plugins/git/git.plugin.zsh``\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/alias_git.png)\n除了``git``别名，还有好多有用的别名，``alias``命令可以列出全部的别名\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/alias.png)\n### 智能跳转\n首先需要安装插件``aotojump``，zsh会自动记录你访问过的目录，通过 ``j + 目录名``可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过``Develop``目录，输入``j develo`` 即可正确跳转。\n","source":"_posts/终极Shell-Zsh-使用技巧.md","raw":"---\ntitle: 终极Shell--Zsh 使用技巧\ndate: 2016-02-01 01:51:36\ntags: [工具,Zsh]\n\n---\n## 为什么要用Zsh\n请参考这篇文章[终极 Shell](http://macshuo.com/?p=676)\n\n## Zsh使用技巧\n### 巧用``tab``\n#### 自动完成\n``tab``用到最多的就是自动完成,比如``cd``进入某个目录，可以输入该目录的中的几个字母，然后``tab``自动补全。\n你不必输入整个目录名称，只需输入初始几个可以唯一区别与其他目录的字母，Zsh会自动匹配出剩余部分。\n![此处输入图片的描述](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/QQ20160131-1%402x.png)\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/tab.png)\n#### 环境变量展开\n在Zsh中，你可以按下<TAB>键来展开shell中的环境变量值\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/PWD-tab.png)\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/PWD-tab-done.png)\n#### kill命令补全\n通常我们想要杀死某个进程，一般都要先``ps``下查看进程，然后``kill``杀掉。使用``zsh``可以这样\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/kill_tab.png)\n#### help命令\n对于我们不熟悉的命令行，一般都会``--help``查看帮助文档，而zsh可以直接敲你想要的命令，比如这样\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/git-tab.png)\n\n### 强大的历史记录\n类UNIX系统通常都习惯于``ctrl+r``的方式查找命令行的历史记录，挺好用的。但是``zsh``有更强大的历史搜索，比如``UP``\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/UP1.png)\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/UP2.png)\n意思是上方向键能帮你找到最近使用的以``./gradlew``开头的命令，``UP`` ``DOWN``可以循环查找\n### 强大的``alias``别名\n平时工作基本都用``git``管理项目代码，每个人都有习惯使用的``git``别名，``zsh``为我们提供了一套通用的``alias``,即使换了工作环境，只要有``zsh``那么一套``alias``全部搞定。在该文件下可以看到``~/.oh-my-zsh/plugins/git/git.plugin.zsh``\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/alias_git.png)\n除了``git``别名，还有好多有用的别名，``alias``命令可以列出全部的别名\n![](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/alias.png)\n### 智能跳转\n首先需要安装插件``aotojump``，zsh会自动记录你访问过的目录，通过 ``j + 目录名``可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过``Develop``目录，输入``j develo`` 即可正确跳转。\n","slug":"终极Shell-Zsh-使用技巧","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6e000hwhs6rifs23zz"},{"title":"快速排序","date":"2016-07-03T12:55:44.000Z","_content":"\n\n> Wikipedia: 快速排序是由东尼霍尔所发展的一种排序算法。在平均状况下，排序n个项目要Ο(n log n)次比较。 在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log )算法更快， 因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n# 快排的思路\n\n快速排序采用了分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。\n该方法的基本思想是：\n\n 1. 选取一个基准元素（pivot）\n 2. 分区过程，比pivot小的放到pivot左边，比pivot大的放到pivot右边\n 3. 对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2\n \n虽然是采用分治法，但是分治法不能完全概括这个算法，因为我每次看完算法会很清楚，但是过段时间就忘了。然后看到了非常新颖的名字：“挖坑排序”。\n\n```java\n//快速排序\nvoid quickSort(int s[], int l, int r)\n{\n    if (l < r)\n    {\n        int i = l, j = r;\n        //将数组中的最低位值取出，相当于挖了第一个坑\n        int x = s[l];\n        while (i < j)\n        {\n            while(i < j && s[j] >= x) {\n            //从右向左找第一个小于x的数\n\t\t\t\tj--;  \n\t\t\t}\n            if(i < j) {\n            //将s[j]的数挖坑填之前的坑\n\t\t\t\ts[i++] = s[j];\n\t\t\t}\n\t\t\t\n            while(i < j && s[i] < x) {\n            // 从左向右找第一个大于等于x的数\n\t\t\t\ti++;  \n\t\t\t}\n            if(i < j) {\n            //挖坑，填之前的坑\n\t\t\t\ts[j--] = s[i];\n\t\t\t}\n        }\n        //填最后一个坑\n        s[i] = x;\n        quickSort(s, l, i - 1); // 递归调用 \n        quickSort(s, i + 1, r);\n    }\n}\n```\n\n对挖坑填数进行总结\n\n 1. i =L; j = R; 将基准数挖出形成第一个坑a[i]。\n 2. j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。\n 3. i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。\n 4. 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。\n\n# 算法分析\n\n平均情况下快速排序的时间复杂度是O(n\\lgn)O(n\\lgn)，最坏情况是O(n2)O(n2)。\n\n## 最坏时间复杂度\n\n当划分产生的两个子问题分别包含 n-1 和 0个元素时，最坏情况发生。因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：\n``Cmax = n(n-1)/2=O(n^2)``\n\n## 最好时间复杂度\n\n当划分产生的两个子问题分别包含⌊n/2⌋⌊n/2⌋和⌈n/2⌉−1⌈n/2⌉−1个元素时，最好情况发生。用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为O(lgn)，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数C(n)=O(nlgn)。\n\n因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为0(n2)，最好时间复杂度为O(nlgn)。事实上只要划分是常数比例的，算法的运行时间总是O(nlgn)。 假设按照 9:1 划分，每层代价最多为 cn，递归深度为 log(10/9, n)=O(lgn)，故排序的总代价为O(nlgn)。平均情况下，比如一次坏的划分接着一次好的划分，坏的划分那一项可以合并到好的划分里，统计上来讲平均情况下的时间复杂度仍然是O(nlgn)。\n\n# 优化\n\n在当前无序区中选取划分的基准关键字是决定算法性能的关键。\n\n 1. \"三者取中\"规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准\n 2. 取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准， 随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件，一般不可能导致最坏情况的发生。\n \n\n# 参考\n\n[白话经典算法系列之六 快速排序 快速搞定][1]\n[快速排序的时间和空间复杂度][2]\n[快速排序算法分析][3]\n\n\n  [1]: http://blog.csdn.net/morewindows/article/details/6684558\n  [2]: http://harttle.com/2015/09/27/quick-sort.html\n  [3]: http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.4.htm","source":"_posts/快速排序.md","raw":"---\ntitle: 快速排序\ndate: 2016-07-03 20:55:44\ntags: [算法, 排序]\n---\n\n\n> Wikipedia: 快速排序是由东尼霍尔所发展的一种排序算法。在平均状况下，排序n个项目要Ο(n log n)次比较。 在最坏状况下则需要Ο(n2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他Ο(n log )算法更快， 因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。\n\n# 快排的思路\n\n快速排序采用了分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。\n该方法的基本思想是：\n\n 1. 选取一个基准元素（pivot）\n 2. 分区过程，比pivot小的放到pivot左边，比pivot大的放到pivot右边\n 3. 对pivot左边的序列和右边的序列分别递归的执行步骤1和步骤2\n \n虽然是采用分治法，但是分治法不能完全概括这个算法，因为我每次看完算法会很清楚，但是过段时间就忘了。然后看到了非常新颖的名字：“挖坑排序”。\n\n```java\n//快速排序\nvoid quickSort(int s[], int l, int r)\n{\n    if (l < r)\n    {\n        int i = l, j = r;\n        //将数组中的最低位值取出，相当于挖了第一个坑\n        int x = s[l];\n        while (i < j)\n        {\n            while(i < j && s[j] >= x) {\n            //从右向左找第一个小于x的数\n\t\t\t\tj--;  \n\t\t\t}\n            if(i < j) {\n            //将s[j]的数挖坑填之前的坑\n\t\t\t\ts[i++] = s[j];\n\t\t\t}\n\t\t\t\n            while(i < j && s[i] < x) {\n            // 从左向右找第一个大于等于x的数\n\t\t\t\ti++;  \n\t\t\t}\n            if(i < j) {\n            //挖坑，填之前的坑\n\t\t\t\ts[j--] = s[i];\n\t\t\t}\n        }\n        //填最后一个坑\n        s[i] = x;\n        quickSort(s, l, i - 1); // 递归调用 \n        quickSort(s, i + 1, r);\n    }\n}\n```\n\n对挖坑填数进行总结\n\n 1. i =L; j = R; 将基准数挖出形成第一个坑a[i]。\n 2. j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。\n 3. i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。\n 4. 再重复执行2，3二步，直到i==j，将基准数填入a[i]中。\n\n# 算法分析\n\n平均情况下快速排序的时间复杂度是O(n\\lgn)O(n\\lgn)，最坏情况是O(n2)O(n2)。\n\n## 最坏时间复杂度\n\n当划分产生的两个子问题分别包含 n-1 和 0个元素时，最坏情况发生。因此，快速排序必须做n-1次划分，第i次划分开始时区间长度为n-i+1，所需的比较次数为n-i(1≤i≤n-1)，故总的比较次数达到最大值：\n``Cmax = n(n-1)/2=O(n^2)``\n\n## 最好时间复杂度\n\n当划分产生的两个子问题分别包含⌊n/2⌋⌊n/2⌋和⌈n/2⌉−1⌈n/2⌉−1个元素时，最好情况发生。用递归树来分析最好情况下的比较次数更简单。因为每次划分后左、右子区间长度大致相等，故递归树的高度为O(lgn)，而递归树每一层上各结点所对应的划分过程中所需要的关键字比较次数总和不超过n，故整个排序过程所需要的关键字比较总次数C(n)=O(nlgn)。\n\n因为快速排序的记录移动次数不大于比较的次数，所以快速排序的最坏时间复杂度应为0(n2)，最好时间复杂度为O(nlgn)。事实上只要划分是常数比例的，算法的运行时间总是O(nlgn)。 假设按照 9:1 划分，每层代价最多为 cn，递归深度为 log(10/9, n)=O(lgn)，故排序的总代价为O(nlgn)。平均情况下，比如一次坏的划分接着一次好的划分，坏的划分那一项可以合并到好的划分里，统计上来讲平均情况下的时间复杂度仍然是O(nlgn)。\n\n# 优化\n\n在当前无序区中选取划分的基准关键字是决定算法性能的关键。\n\n 1. \"三者取中\"规则，即在当前区间里，将该区间首、尾和中间位置上的关键字比较，取三者之中值所对应的记录作为基准\n 2. 取位于low和high之间的随机数k(low≤k≤high)，用R[k]作为基准， 随机化的快速排序与一般的快速排序算法差别很小。但随机化后，算法的性能大大地提高了，尤其是对初始有序的文件，一般不可能导致最坏情况的发生。\n \n\n# 参考\n\n[白话经典算法系列之六 快速排序 快速搞定][1]\n[快速排序的时间和空间复杂度][2]\n[快速排序算法分析][3]\n\n\n  [1]: http://blog.csdn.net/morewindows/article/details/6684558\n  [2]: http://harttle.com/2015/09/27/quick-sort.html\n  [3]: http://student.zjzk.cn/course_ware/data_structure/web/paixu/paixu8.3.2.4.htm","slug":"快速排序","published":1,"updated":"2016-07-03T14:09:09.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6i000mwhs6s17wf7uv"},{"title":"前端基础(零)--CSS基础","date":"2016-03-19T14:52:40.000Z","_content":"\n# 背景\n\n最近跟小伙伴们在[百度前端技术学院](ife.baidu.com)学习前端相关的知识，接下来一系列博客会记录学习的过程和知识点，这是第一篇文章CSS基础。\n\n开发工具：sublime text 3\n\n主要插件：[Emmet](http://docs.emmet.io/)\n\n# CSS\n\n## 什么是CSS\n\n> 层叠样式表 (Cascading Style Sheets)，常缩写为 CSS， 是一种 样式表 \n> (stylesheet) 语言，用来描述 HTML、XML（包括各种 XML 语言如 SVG、XHTML）文档\n> 的呈现。CSS 描述怎样在屏幕上渲染结构化元素。\n\n## 为什么使用CSS\n我们知道，html文件主要携带内容，虽然html也可以进行布局相关的操作，但是当浏览器的默认渲染规则不能很好的将我们定义好的布局展示出来，可能会导致显示不统一的问题，所以就将内容和表现进行分离，由CSS专门负责变现，html负责携带内容，可以很好的解除耦合，方便扩展，例如，需要全局的更新界面布局，那么也只需要修改css。可以说，css极大的提高了工作效率。就有点类似于android开发中的style，只负责配置各种view相关的属性值，而xml声明就有些类似于html，只是声明ImageView代表一个特定的view，表现形式完全可以交给style去处理。但是，个人感觉由于css的选择器的存在，css要比android中的style高明许多。\n\n\n# CSS基础语法\n\n看图\n\n![image](http://7xs23g.com1.z0.glb.clouddn.com/CSS.png)\n\n示例\n\n```css\nbody {\n     font-family: Verdana, sans-serif;\n     }\n```\nbody元素的所有文字的字体都是Verdana。\nCSS默认有集成的属性，也就是说默认情况下body下的所有字元素都会继承body的属性，就像android布局，父控件的属性也会它所有的字控件一样，例如在根布局设置``backgroud=\"#eee\"``那么，该界面的基础色就是``#eee``, css也是这样的。\n\n# 选择器\n\ncss的强大之处在于，选择器的可配置性，对于复杂的界面显示来说这点非常有用\n\n## 选择器的分组\n\n```css\nh1,h2,h3,h4,h5,h6 {\n\tcolor: green;\n  }\n```\n上面的代码表示，每个选择器都不相互产生影响，只是写在了一起而已。\n\n## 派生选择器\n\n> 派生选择器就是通过依据元素在其位置的上下文关系来定义样式，以达到使标记更加简洁的\n> 目的。\n\n```css\ndiv p {\n    font-style: italic;\n    font-weight: normal;\n  }\n```\n在上面的例子中，只有 div 元素中的 p 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。当然，单独出现的div 和 p并不会受到影响。\n\n## id 选择器\n\n> id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。以``#``来定义\n\n示例\n\n\n```css\n#red {color:red;}\n#green {color:green;}\n```\nhtml这样写\n```css\n<p id=\"red\">这个段落是红色。</p>\n<p id=\"green\">这个段落是绿色。</p>\n```\n但是要注意，同一个html文件中同一个id只能使用一次，具体的原因请看[这里](http://www.w3school.com.cn/xhtml/xhtml_structural_02.asp)\n\n## 类选择器\n\n通过设置元素的 class 属性，可以为元素指定类名。与id不同的是，同一个class可以在同一个html文件中复用。以``.``来定义\n\n示例\n\n```css\n.center {text-align: center}\n```\nhtml代码中这样用\n\n```css\n<h1 class=\"center\">\n\tThis heading will be center-aligned\n</h1>\n\n<p class=\"center\">\n\tThis paragraph will also be center-aligned.\n</p>\n```\n\n## 基于关系的选择器\n\nCSS有多种基于元素关系的选择器。通过它们我们可以更精确的选择元素。\n常见的关系选择器\n\n| 选择器 | 选择的元素 | \n| ------------ | ------------- | \n| A E | 任何是元素A的后代元素E (后代节点指A的子节点，子节点的子节点，以此类推)  | \n| A > E | 任何元素A的子元素  | \n|E:first-child | 任何元素的第一个子元素E |\n|B + E | 任何元素B的下一个兄弟元素E |\n|B ~ E | B元素后面的拥有共同父元素的兄弟元素E|\n\n\n## 伪类选择器\n\nCSS伪类（pseudo-class）是加在选择器后面的用来指定元素状态的关键字。\n\n示例\n\n```css\na:link {color: #FF0000}\t\t/* 未访问的链接 */\na:visited {color: #00FF00}\t/* 已访问的链接 */\na:hover {color: #FF00FF}\t/* 鼠标移动到链接上 */\na:active {color: #0000FF}\t/* 选定的链接 */\n```\n上面表示a链接的各种状态的表示。\n\n## 属性选择器\n\n属性选择器可以根据元素的属性及属性值来选择元素。\n简单的示例\n```css\n*[title] {color:red;}\n```\n上面表示把包含标题（title）的所有元素变为红色\n在css中 ``*``可以替代任何元素\n\n上面所讲到的任意选择器，都可以通过组合的方式表达更复杂的元素间的关系，产生复杂的显示效果。\n\n# 总结\n\ncss是前端的基础，对于界面显示和布局来说至关重要，特别是css的选择器，相互组合可以产生非常复杂的效果。\n\n最后附上ife的提交任务二\n[代码地址](https://github.com/w4lle/ife_baidu/blob/master/task2%2Findex.html)\n[demo](http://w4lle.github.io/ife_baidu/task2/index.html)\n","source":"_posts/前端基础-零-CSS基础.md","raw":"---\ntitle: 前端基础(零)--CSS基础\ndate: 2016-03-19 22:52:40\ntags: [前端, CSS]\n---\n\n# 背景\n\n最近跟小伙伴们在[百度前端技术学院](ife.baidu.com)学习前端相关的知识，接下来一系列博客会记录学习的过程和知识点，这是第一篇文章CSS基础。\n\n开发工具：sublime text 3\n\n主要插件：[Emmet](http://docs.emmet.io/)\n\n# CSS\n\n## 什么是CSS\n\n> 层叠样式表 (Cascading Style Sheets)，常缩写为 CSS， 是一种 样式表 \n> (stylesheet) 语言，用来描述 HTML、XML（包括各种 XML 语言如 SVG、XHTML）文档\n> 的呈现。CSS 描述怎样在屏幕上渲染结构化元素。\n\n## 为什么使用CSS\n我们知道，html文件主要携带内容，虽然html也可以进行布局相关的操作，但是当浏览器的默认渲染规则不能很好的将我们定义好的布局展示出来，可能会导致显示不统一的问题，所以就将内容和表现进行分离，由CSS专门负责变现，html负责携带内容，可以很好的解除耦合，方便扩展，例如，需要全局的更新界面布局，那么也只需要修改css。可以说，css极大的提高了工作效率。就有点类似于android开发中的style，只负责配置各种view相关的属性值，而xml声明就有些类似于html，只是声明ImageView代表一个特定的view，表现形式完全可以交给style去处理。但是，个人感觉由于css的选择器的存在，css要比android中的style高明许多。\n\n\n# CSS基础语法\n\n看图\n\n![image](http://7xs23g.com1.z0.glb.clouddn.com/CSS.png)\n\n示例\n\n```css\nbody {\n     font-family: Verdana, sans-serif;\n     }\n```\nbody元素的所有文字的字体都是Verdana。\nCSS默认有集成的属性，也就是说默认情况下body下的所有字元素都会继承body的属性，就像android布局，父控件的属性也会它所有的字控件一样，例如在根布局设置``backgroud=\"#eee\"``那么，该界面的基础色就是``#eee``, css也是这样的。\n\n# 选择器\n\ncss的强大之处在于，选择器的可配置性，对于复杂的界面显示来说这点非常有用\n\n## 选择器的分组\n\n```css\nh1,h2,h3,h4,h5,h6 {\n\tcolor: green;\n  }\n```\n上面的代码表示，每个选择器都不相互产生影响，只是写在了一起而已。\n\n## 派生选择器\n\n> 派生选择器就是通过依据元素在其位置的上下文关系来定义样式，以达到使标记更加简洁的\n> 目的。\n\n```css\ndiv p {\n    font-style: italic;\n    font-weight: normal;\n  }\n```\n在上面的例子中，只有 div 元素中的 p 元素的样式为斜体字，无需为 strong 元素定义特别的 class 或 id，代码更加简洁。当然，单独出现的div 和 p并不会受到影响。\n\n## id 选择器\n\n> id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。以``#``来定义\n\n示例\n\n\n```css\n#red {color:red;}\n#green {color:green;}\n```\nhtml这样写\n```css\n<p id=\"red\">这个段落是红色。</p>\n<p id=\"green\">这个段落是绿色。</p>\n```\n但是要注意，同一个html文件中同一个id只能使用一次，具体的原因请看[这里](http://www.w3school.com.cn/xhtml/xhtml_structural_02.asp)\n\n## 类选择器\n\n通过设置元素的 class 属性，可以为元素指定类名。与id不同的是，同一个class可以在同一个html文件中复用。以``.``来定义\n\n示例\n\n```css\n.center {text-align: center}\n```\nhtml代码中这样用\n\n```css\n<h1 class=\"center\">\n\tThis heading will be center-aligned\n</h1>\n\n<p class=\"center\">\n\tThis paragraph will also be center-aligned.\n</p>\n```\n\n## 基于关系的选择器\n\nCSS有多种基于元素关系的选择器。通过它们我们可以更精确的选择元素。\n常见的关系选择器\n\n| 选择器 | 选择的元素 | \n| ------------ | ------------- | \n| A E | 任何是元素A的后代元素E (后代节点指A的子节点，子节点的子节点，以此类推)  | \n| A > E | 任何元素A的子元素  | \n|E:first-child | 任何元素的第一个子元素E |\n|B + E | 任何元素B的下一个兄弟元素E |\n|B ~ E | B元素后面的拥有共同父元素的兄弟元素E|\n\n\n## 伪类选择器\n\nCSS伪类（pseudo-class）是加在选择器后面的用来指定元素状态的关键字。\n\n示例\n\n```css\na:link {color: #FF0000}\t\t/* 未访问的链接 */\na:visited {color: #00FF00}\t/* 已访问的链接 */\na:hover {color: #FF00FF}\t/* 鼠标移动到链接上 */\na:active {color: #0000FF}\t/* 选定的链接 */\n```\n上面表示a链接的各种状态的表示。\n\n## 属性选择器\n\n属性选择器可以根据元素的属性及属性值来选择元素。\n简单的示例\n```css\n*[title] {color:red;}\n```\n上面表示把包含标题（title）的所有元素变为红色\n在css中 ``*``可以替代任何元素\n\n上面所讲到的任意选择器，都可以通过组合的方式表达更复杂的元素间的关系，产生复杂的显示效果。\n\n# 总结\n\ncss是前端的基础，对于界面显示和布局来说至关重要，特别是css的选择器，相互组合可以产生非常复杂的效果。\n\n最后附上ife的提交任务二\n[代码地址](https://github.com/w4lle/ife_baidu/blob/master/task2%2Findex.html)\n[demo](http://w4lle.github.io/ife_baidu/task2/index.html)\n","slug":"前端基础-零-CSS基础","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6l000rwhs6prj1zjxw"},{"title":"前端基础(一)--CSS布局基础","date":"2016-04-17T14:26:23.000Z","_content":"\n# 盒模型\n\nCSS中， Box Model叫盒模型（或框模型），Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。这种方式基本类似于Android开发中的布局方式，所以对于Android developer学习前端布局方式可以很快的入门。但是有一点，在Android中设置margin和padding的顺序是left、top、right、bottom，比如``setMargin(10, 20, 30, 20)``分别代表左上右下的间距分别为10px,20px,30px,20px;但是在CSS中的顺序是top、right、bottom、left，比如``margin: [10px, 20px, 30px, 20px]``分别代表左上右下间距分别为20px,10px,20px,30px。\n概述图如下\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/box-model.png)\n\n# 定位基础\n\n## ``position``定位\n\n``position``包括以下几种类型的定位\n\n* static 默认值。任意 position: static; 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。\n\n* relative 相对布局，在原有基础上偏离使框偏离某个方向固定距离。跟Android中的布局方式很像\n例子\n\n```css\n.relative2 {\n  position: relative;\n  top: -20px; //在原有top位置上向上偏移-20px\n  left: 20px; //在原有left位置上向左偏移20px\n  background-color: white;\n  width: 500px;\n}\n```\n* absolute 绝对布局，向上寻找使用过``position``定位过(除了默认值static外)的祖先元素，然后依据该元素进行定位。\n\n```css\n.relative {\n  position: relative;\n  width: 600px;\n  height: 400px;\n}\n.absolute {\n  position: absolute;\n  top: 120px;\n  right: 0;\n  width: 300px;\n  height: 200px;\n}\n```\n\n如图\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/absolute.png)\n\n* fixed 固定定位，相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。相当于在Android开发中``FrameLayout``中的某个元素指定``layout_gravity``使其固定在根布局的某个固定的位置。\n例子\n\n```css\n.fixed {\n  position: fixed;\n  bottom: 0;\n  right: 0;\n  width: 200px;\n  background-color: white;\n}\n```\n该元素的位置始终在右下角保持不变。\n\n## ``float``浮动\n\n> 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。\n\n可以这样理解，比如``float: left``就是向左移动，直到坐边缘碰到根元素或者另外一个佛洞的边框的边缘。也就是说，如果好好几个向左浮动的元素，那么它们是从左到右依次排列的。\n如下面的图\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/float1.png)\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/float2.png)\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/float3.png)\n\n## ``clear``清除浮动\n\nclear 属性定义了元素的哪边上不允许出现浮动元素。\n具体的例子参考[这里](http://zh.learnlayout.com/clear.html)\n\n# 三栏式布局\n\nife其中的一个任务[三栏式布局](http://ife.baidu.com/task/detail?taskId=3)\n就是通过CSS的布局基础知识来写的。包括position和float。\n\n代码在这里[三栏式布局](https://github.com/w4lle/ife_baidu/tree/master/task3)\ndemo [demo](http://w4lle.github.io/ife_baidu/task3/task3.html)\n\n# 参考\n\n* [learnlayout](http://zh.learnlayout.com/)\n* [w3school](http://www.w3school.com.cn/css/css_positioning.asp)","source":"_posts/前端基础-一-CSS布局基础.md","raw":"---\ntitle: 前端基础(一)--CSS布局基础\ndate: 2016-04-17 22:26:23\ntags: [CSS, 前端]\n---\n\n# 盒模型\n\nCSS中， Box Model叫盒模型（或框模型），Box Model规定了元素框处理元素内容（element content）、内边距（padding）、边框（border） 和 外边距（margin） 的方式。这种方式基本类似于Android开发中的布局方式，所以对于Android developer学习前端布局方式可以很快的入门。但是有一点，在Android中设置margin和padding的顺序是left、top、right、bottom，比如``setMargin(10, 20, 30, 20)``分别代表左上右下的间距分别为10px,20px,30px,20px;但是在CSS中的顺序是top、right、bottom、left，比如``margin: [10px, 20px, 30px, 20px]``分别代表左上右下间距分别为20px,10px,20px,30px。\n概述图如下\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/box-model.png)\n\n# 定位基础\n\n## ``position``定位\n\n``position``包括以下几种类型的定位\n\n* static 默认值。任意 position: static; 的元素不会被特殊的定位。一个 static 元素表示它不会被“positioned”，一个 position 属性被设置为其他值的元素表示它会被“positioned”。\n\n* relative 相对布局，在原有基础上偏离使框偏离某个方向固定距离。跟Android中的布局方式很像\n例子\n\n```css\n.relative2 {\n  position: relative;\n  top: -20px; //在原有top位置上向上偏移-20px\n  left: 20px; //在原有left位置上向左偏移20px\n  background-color: white;\n  width: 500px;\n}\n```\n* absolute 绝对布局，向上寻找使用过``position``定位过(除了默认值static外)的祖先元素，然后依据该元素进行定位。\n\n```css\n.relative {\n  position: relative;\n  width: 600px;\n  height: 400px;\n}\n.absolute {\n  position: absolute;\n  top: 120px;\n  right: 0;\n  width: 300px;\n  height: 200px;\n}\n```\n\n如图\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/absolute.png)\n\n* fixed 固定定位，相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。相当于在Android开发中``FrameLayout``中的某个元素指定``layout_gravity``使其固定在根布局的某个固定的位置。\n例子\n\n```css\n.fixed {\n  position: fixed;\n  bottom: 0;\n  right: 0;\n  width: 200px;\n  background-color: white;\n}\n```\n该元素的位置始终在右下角保持不变。\n\n## ``float``浮动\n\n> 浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。\n\n可以这样理解，比如``float: left``就是向左移动，直到坐边缘碰到根元素或者另外一个佛洞的边框的边缘。也就是说，如果好好几个向左浮动的元素，那么它们是从左到右依次排列的。\n如下面的图\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/float1.png)\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/float2.png)\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/float3.png)\n\n## ``clear``清除浮动\n\nclear 属性定义了元素的哪边上不允许出现浮动元素。\n具体的例子参考[这里](http://zh.learnlayout.com/clear.html)\n\n# 三栏式布局\n\nife其中的一个任务[三栏式布局](http://ife.baidu.com/task/detail?taskId=3)\n就是通过CSS的布局基础知识来写的。包括position和float。\n\n代码在这里[三栏式布局](https://github.com/w4lle/ife_baidu/tree/master/task3)\ndemo [demo](http://w4lle.github.io/ife_baidu/task3/task3.html)\n\n# 参考\n\n* [learnlayout](http://zh.learnlayout.com/)\n* [w3school](http://www.w3school.com.cn/css/css_positioning.asp)","slug":"前端基础-一-CSS布局基础","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6q000wwhs6sbe9pkn4"},{"title":"从Instant run谈Android替换Application和动态加载机制","date":"2016-05-02T11:33:05.000Z","_content":"\n# 背景\n\n``Android studio 2.0 Stable``版本中集成了``Install run``即时编译技术，官方描述可以大幅加速编译速度，我们团队在第一时间更新并使用，总体用下来感觉，恩...也就那样吧，还不如不用的快。所以就去看了下``Install run``的实现方式，其中有一个整体框架的基础，也就是今天的文章的主题，Android替换Application和动态加载机制。\n\n# Instant run\n\n``Instant run``的大概实现原理可以看下这篇[Instant Run 浅析](http://jiajixin.cn/2015/11/25/instant-run/)，我们需要知道``Instant run``使用的``gradle plugin2.0.0``，源码在[这里](https://bintray.com/android/android-tools/com.android.tools.build.gradle/view)，文中大概讲了下``Instant run``的实现原理，但是并没有深入细节，特别是替换Application和动态加载机制。\n\n关于动态加载，实际上``Instant run``提供了两种动态加载的机制：\n1.修改java代码需要重启应用加载补丁dex，而在Application初始化时替换了Application，新建了一个自定义的ClassLoader去加载所有的dex文件。我们称为**重启更新机制**\n2.修改代码不需要重启，新建一个``ClassLoader``去加载修改部分。我们称为**热更新机制**\n\n## Application入口\n\n在编译时``Instant run``用到了``Transform API``修改字节码文件。其中``AndroidManifest.xml``文件也被修改，如下：\n``/app/build/intermediates/bundles/production/instant-run/AndroidManifest.xml``，其中的``Application``标签\n```xml\n<application\n        name=\"com.aa.bb.MyApplication\"\n        android:name=\"com.android.tools.fd.runtime.BootstrapApplication\"\n\t\t... />\n```\n多了一个``com.android.tools.fd.runtime.BootstrapApplication``，在刚刚提到的``gradle plugin``中的``instant-run-server``目录下找到该文件。\n\n实际上``BootstrapApplication``是我们app的实际入口，我们自己的``Application``即``MyApplication``采用反射机制调用。\n我们知道``Application``是``ContextWrapper``的子类\n\n```java\n// android.app.Application\npublic class Application extends ContextWrapper {\n    // ...\n    public application() {\n        super(null);\n    }\n    // ...\n}\n// android.content.ContextWrapper\npublic class ContextWrapper extends Context {\n    Context mBase;\n    // ...\n    public ContextWrapper(Context base) {\n        mBase = base;\n    }\n    protected void attachBaseContext(Context base) {\n        if (mBase != null) {\n            throw new IllegalStateException(\"Base context already set\");\n        }\n        mBase = base;\n    }\n    // ...\n    @Override\n    public AssetManager getAssets() {\n        return mBase.getAssets();\n    }\n    @Override\n    public Resources getResources()\n    {\n        return mBase.getResources();\n    }\n    // ...\n}\n```\n\nContextWrapper一方面继承了Context，一方面又包含(composite)了一个Context对象（称为mBase），对Context的实现为转发给mBase对象处理。上面的代码表示，在``attachBaseContext``方式调用之前Application是没有用的，因为mBase是空的。所以我们看下``BootstrapApplication``的``attachBaseContext``方法\n\n```java\nprotected void attachBaseContext(Context context) {\n        if (!AppInfo.usingApkSplits) {\n            createResources(apkModified);\n            //新建一个ClassLoader并设置为原ClassLoader的parent\n            setupClassLoaders(context, context.getCacheDir().getPath(), apkModified);\n        }\n\t\t//通过Manifest中我们的实际Application即MyApplication名反射生成对象\n        createRealApplication();\n\t\t//调用attachBaseContext完成初始化\n        super.attachBaseContext(context);\n\n        if (realApplication != null) {\n        //反射调用实际Application的attachBaseContext方法\n            try {\n                Method attachBaseContext =\n                        ContextWrapper.class.getDeclaredMethod(\"attachBaseContext\", Context.class);\n                attachBaseContext.setAccessible(true);\n                attachBaseContext.invoke(realApplication, context);\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n```\n\n初始化ClassLoader\n\n```java\n//BootstrapApplication.setupClassLoaders\nprivate static void setupClassLoaders(Context context, String codeCacheDir, long apkModified) {\n\t\t// /data/data/package_name/files/instant-run/dex/目录下的dex列表\n        List<String> dexList = FileManager.getDexList(context, apkModified);\n            ClassLoader classLoader = BootstrapApplication.class.getClassLoader();\n            String nativeLibraryPath = (String) classLoader.getClass().getMethod(\"getLdLibraryPath\")\n                                .invoke(classLoader);\n            IncrementalClassLoader.inject(\n                    classLoader,\n                    nativeLibraryPath,\n                    codeCacheDir,\n                    dexList);\n        }\n    }\n    \n//IncrementalClassLoader.inject\npublic static ClassLoader inject(\n            ClassLoader classLoader, String nativeLibraryPath, String codeCacheDir,\n            List<String> dexes) {\n        //新建一个自定义ClassLoader，dexPath为参数中的dexList\n        IncrementalClassLoader incrementalClassLoader =\n                new IncrementalClassLoader(classLoader, nativeLibraryPath, codeCacheDir, dexes);\n        //设置为原ClassLoader的parent\n        setParent(classLoader, incrementalClassLoader);\n\t\treturn incrementalClassLoader;\n    }\n```\n\n## 动态加载\n\n新建一个自定义的``ClassLoader``名为IncrementalClassLoader，该``ClassLoader``很简单，就是``BaseDexClassLoader``的一个子类，并且将``IncrementalClassLoader``设置为原ClassLoader的parent，熟悉JVM加载机制的同学应该都知道，由于ClassLoader采用双亲委托模式，即委托父类加载类，父类找不到再自己去找。这样``IncrementalClassLoader``就变成了整个App的所有类的加载的ClassLoader，并且dexPath是``/data/data/package_name/files/instant-run/dex``目录下的dex列表，这意味着什么呢？\n\n```java\n\n//``BaseDexClassLoader``的``findClass``\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n    List<Throwable> suppressedExceptions = new ArrayList<Throwable>();\n    Class c = pathList.findClass(name, suppressedExceptions);\n    if (c == null) {\n        ClassNotFoundException cnfe = new ClassNotFoundException(\"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList);\n        for (Throwable t : suppressedExceptions) {\n            cnfe.addSuppressed(t);\n        }\n        throw cnfe;\n    }\n    return c;\n}\n```\n\n可以看到，查找Class的任务通过pathList完成；这个pathList是一个DexPathList类的对象，它的findClass方法如下：\n\n```java\npublic Class findClass(String name, List<Throwable> suppressed) {\n   for (Element element : dexElements) {\n       DexFile dex = element.dexFile;\n\n       if (dex != null) {\n           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);\n           if (clazz != null) {\n               return clazz;\n           }\n       }\n   }\n   if (dexElementsSuppressedExceptions != null) {\n       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));\n   }\n   return null;\n}\n```\n\n这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class。看到了吗，这个dexElements就是从dexPath来的，也就说是``IncrementalClassLoader``用来加载dexPath(/data/data/package_name/files/instant-run/dex/)下面的dex文件。感兴趣的同学可以看下，我们app中的所有第三方库和自己项目中的代码，都被打包成若干个slice dex分片，该目录下有几十个dex文件。每当修改代码用``Instant run``完成编译，该目录下的dex文件就会有一个或者几个的更新时间发生改变。\n\n正常情况下，apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类。而使用``Install run``则完全不管之前的加载路径，所有的分片dex文件和资源都在dexPath下，用``IncrementalClassLoader``去加载。也就是加载不存在APK固定路径之外的类，即动态加载。\n\n但是仅仅有ClassLoader是不够的。因为每个被修改的类都被改了名字，类名在原名后面添加``$override``，目录在``app/build/intermediates/transforms/instantRun/debug/folders/4000``。AndroidManifest中并没有注册这些被改了名字的Activity。> 因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象。\n> 解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要干预这个类加载的过程。\n> 引用自 -- [Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)\n\n\n\n## 动态加载的两种方案\n\n先来看下系统如何完成类的加载过程。\n``Activity``的创建过程\n\n```java\njava.lang.ClassLoader cl = r.packageInfo.getClassLoader();\nactivity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\nStrictMode.incrementExpectedActivityCount(activity.getClass());\nr.intent.setExtrasClassLoader(cl);\n```\n\n通过``ClassLoader``和类名加载，反射调用生成``Activity``对象，其中的``ClassLoader``从``LoadedApk``的一个对象``r.packageInfo``中获得的。``LoadedApk``对象是APK文件在内存中的表示。 Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的``Activity``，``Service``等组件的信息我们都可以通过此对象获取。\nr.packageInfo的来源：\n\n```java\nprivate LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,\n        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,\n        boolean registerPackage) {\n        // 获取userid信息\n    final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));\n    synchronized (mResourcesManager) {\n    // 尝试获取缓存信息\n        WeakReference<LoadedApk> ref;\n        if (differentUser) {\n            // Caching not supported across users\n            ref = null;\n        } else if (includeCode) {\n            ref = mPackages.get(aInfo.packageName);\n        } else {\n            ref = mResourcePackages.get(aInfo.packageName);\n        }\n\n        LoadedApk packageInfo = ref != null ? ref.get() : null;\n        if (packageInfo == null || (packageInfo.mResources != null\n                && !packageInfo.mResources.getAssets().isUpToDate())) {\n                // 缓存没有命中，直接new\n            packageInfo =\n                new LoadedApk(this, aInfo, compatInfo, baseLoader,\n                        securityViolation, includeCode &&\n                        (aInfo.flags&ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);\n\n        // 省略。。更新缓存\n        return packageInfo;\n    }\n}\n```\n\n重要的是这个缓存``mPackage``，``LoadedApk``对象``packageInfo``就是从这个缓存中取的，所以我们只要在``mPackage``修改里面的``ClassLoader``控制类的加载就能完成动态加载。\n\n在《[Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)》一文中，作者已经提出两种动态加载的解决方案：\n\n> 『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进mPackages中，进而完成了类的加载过程。\n\n>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。\n\n激进方案由于是一个插件一个``Classloader``也叫多``ClassLoader``方案，代表作[DroidPlugin](https://github.com/Qihoo360/DroidPlugin)；保守方案也叫做单``ClassLoader``方案，代表作，Small、众多热更新框架如[nuwa](https://github.com/jasonross/Nuwa)等。\n\n## Instant run的重启更新机制\n\n绕了一大圈，终于能接着往下看了。接上面，我们继续看``BootstrapApplication``的``onCreate``方法\n\n```java\npublic void onCreate() {\n        MonkeyPatcher.monkeyPatchApplication(\n                    BootstrapApplication.this, BootstrapApplication.this,\n                    realApplication, externalResourcePath);\n            MonkeyPatcher.monkeyPatchExistingResources(BootstrapApplication.this,\n                    externalResourcePath, null);\n        super.onCreate();\n        ...\n\t\t//手机客户端app和Android Studio建立Socket通信，AS是客户端发消息，app\t\t//是服务端接收消息作出相应操作。Instant run的通信方式。不在本文范围内\n        Server.create(AppInfo.applicationId, BootstrapApplication.this);\n\n        if (realApplication != null) {\n        \t//还记得这个realApplication吗，我们app中实际的Application\n            realApplication.onCreate();\n        }\n    }\n```\n\n上面代码，手机客户端app和Android Studio建立Socket通信，AS是客户端发消息，app是服务端接收消息作出相应操作，这是Instant run的通信方式，不在本文范围内。然后反射调用实际``Application``的``onCreate``方法。\n那么前面的两个``MonkeyPatcher``的方法是干嘛的呢\n\n先看``MonkeyPatcher.monkeyPatchApplication``\n\n```java\npublic static void monkeyPatchApplication(@Nullable Context context,\n                                              @Nullable Application bootstrap,\n                                              @Nullable Application realApplication,\n                                              @Nullable String externalResourceFile) {\n        try {\n            // Find the ActivityThread instance for the current thread\n            Class<?> activityThread = Class.forName(\"android.app.ActivityThread\");\n            Object currentActivityThread = getActivityThread(context, activityThread);\n\n            // Find the mInitialApplication field of the ActivityThread to the real application\n            Field mInitialApplication = activityThread.getDeclaredField(\"mInitialApplication\");\n            mInitialApplication.setAccessible(true);\n            Application initialApplication = (Application) mInitialApplication.get(currentActivityThread);\n            if (realApplication != null && initialApplication == bootstrap) {\n            //**2.替换掉ActivityThread.mInitialApplication**\n                mInitialApplication.set(currentActivityThread, realApplication);\n            }\n\n            // Replace all instance of the stub application in ActivityThread#mAllApplications with the\n            // real one\n            if (realApplication != null) {\n                Field mAllApplications = activityThread.getDeclaredField(\"mAllApplications\");\n                mAllApplications.setAccessible(true);\n                List<Application> allApplications = (List<Application>) mAllApplications\n                        .get(currentActivityThread);\n                for (int i = 0; i < allApplications.size(); i++) {\n                    if (allApplications.get(i) == bootstrap) {\n                    //**1.替换掉ActivityThread.mAllApplications**\n                        allApplications.set(i, realApplication);\n                    }\n                }\n            }\n\n            // Figure out how loaded APKs are stored.\n\n            // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.\n            Class<?> loadedApkClass;\n            try {\n                loadedApkClass = Class.forName(\"android.app.LoadedApk\");\n            } catch (ClassNotFoundException e) {\n                loadedApkClass = Class.forName(\"android.app.ActivityThread$PackageInfo\");\n            }\n            Field mApplication = loadedApkClass.getDeclaredField(\"mApplication\");\n            mApplication.setAccessible(true);\n            Field mResDir = loadedApkClass.getDeclaredField(\"mResDir\");\n            mResDir.setAccessible(true);\n\n            // 10 doesn't have this field, 14 does. Fortunately, there are not many Honeycomb devices\n            // floating around.\n            Field mLoadedApk = null;\n            try {\n                mLoadedApk = Application.class.getDeclaredField(\"mLoadedApk\");\n            } catch (NoSuchFieldException e) {\n                // According to testing, it's okay to ignore this.\n            }\n\n            // Enumerate all LoadedApk (or PackageInfo) fields in ActivityThread#mPackages and\n            // ActivityThread#mResourcePackages and do two things:\n            //   - Replace the Application instance in its mApplication field with the real one\n            //   - Replace mResDir to point to the external resource file instead of the .apk. This is\n            //     used as the asset path for new Resources objects.\n            //   - Set Application#mLoadedApk to the found LoadedApk instance\n            for (String fieldName : new String[]{\"mPackages\", \"mResourcePackages\"}) {\n                Field field = activityThread.getDeclaredField(fieldName);\n                field.setAccessible(true);\n                Object value = field.get(currentActivityThread);\n\n                for (Map.Entry<String, WeakReference<?>> entry :\n                        ((Map<String, WeakReference<?>>) value).entrySet()) {\n                    Object loadedApk = entry.getValue().get();\n                    if (loadedApk == null) {\n                        continue;\n                    }\n\n                    if (mApplication.get(loadedApk) == bootstrap) {\n                        if (realApplication != null) {\n                        //**3.替换掉mApplication**\n                            mApplication.set(loadedApk, realApplication);\n                        }\n                        if (externalResourceFile != null) {\n                        //替换掉资源目录\n                            mResDir.set(loadedApk, externalResourceFile);\n                        }\n\n                        if (realApplication != null && mLoadedApk != null) {\n                        //**4.替换掉mLoadedApk**\n                            mLoadedApk.set(realApplication, loadedApk);\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            throw new IllegalStateException(e);\n        }\n    }\n```\n\n这里做了三件事情：\n\n1.替换Application对象\n\n``BootstrapApplication``的作用就是加载``realApplication``也就是``MyApplication``，所以我们就要把所有Framework层的``BootstrapApplication``对象替换为``MyApplication``对象。包括：\n\n```java\nbaseContext.mPackageInfo.mApplication 代码3处\nbaseContext.mPackageInfo.mActivityThread.mInitialApplication 代码2处\nbaseContext.mPackageInfo.mActivityThread.mAllApplications 代码1处\n```\n\n2.替换资源相关对象mResDir，前面我们已经说过，正常情况下寻找资源都是在``/data/app/package_name/base-1.apk``目录下，而``Instant run``将资源也抽出来放在``/data/data/package_name/files/instant-run/``，加载目录也更改为后者\n\n3.替换``mLoadedApk``对象\n还记得前面的讲的``LoadedApk``吗，这里面有加载类的``ClassLoader``，由于``BootstrapApplication``在``attachBaseContext``方法中就将其已经替换为了``IncrementalClassLoader``，所以代码4处反射将``BootstrapApplication``的``mLoadedApk``赋值给了``MyApplication``，那么接下来MyApplication的所有类的加载都将由``IncrementalClassLoader``来负责。\n\n``MonkeyPatcher.monkeyPatchExistingResources``更新资源补丁，不在本文范围内就不讲了。\n\n这些工作做完之后调用``MyApplication``的``onCreate``方法``BootstrapApplication``就将控制权交给了``MyApplication``，这样在整个运行环境中，``MyApplication``就是正牌``Application``了，完成``Application``的替换。\n\n总结一下，刚才我们说了已经有两个动态加载的方案，激进方案和保守方案,而``Instant run``的重启更新机制更像后者--保守方案即单``ClassLoader``方案，首先，该种方案只有一个``ClassLoader``，只不过是通过替换``Application``达到的替换``mLoadedApk``进而替换``ClassLoader``的目的，并没有涉及到缓存``mPackage``然后dexList也是它自己维护的。\n\n## Instant run 热更新机制\n\nInstant run哪里用到的热更新机制呢？还记得刚才我们提到的Socket通信吗，其中S端也就是手机客户端，接收到热更新的消息会执行下面的方法：\n\n```java\n private int handleHotSwapPatch(int updateMode, @NonNull ApplicationPatch patch) {\n        try {\n            String dexFile = FileManager.writeTempDexFile(patch.getBytes());\n            String nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();\n            //新建一个ClassLoader，dexFile是刚更新的插件\n            DexClassLoader dexClassLoader = new DexClassLoader(dexFile,\n                    mApplication.getCacheDir().getPath(), nativeLibraryPath,\n                    getClass().getClassLoader());\n\n            // we should transform this process with an interface/impl\n            Class<?> aClass = Class.forName(\n                    \"com.android.tools.fd.runtime.AppPatchesLoaderImpl\", true, dexClassLoader);\n            try {\n                PatchesLoader loader = (PatchesLoader) aClass.newInstance();\n                String[] getPatchedClasses = (String[]) aClass\n                        .getDeclaredMethod(\"getPatchedClasses\").invoke(loader);\n                //loader是PatchesLoader的一个实例，调用load方法加载插件\n                if (!loader.load()) {\n                    updateMode = UPDATE_MODE_COLD_SWAP;\n                }\n            } catch (Exception e) {\n                updateMode = UPDATE_MODE_COLD_SWAP;\n            }\n        } catch (Throwable e) {\n            updateMode = UPDATE_MODE_COLD_SWAP;\n        }\n        return updateMode;\n    }\n```\n\n可以看到根据单个dexFile新建了一个``ClassLoader``，然后调用``loader.load()``方法，``loader``是``PatchesLoader``接口的实例，``PatchesLoader``接口的一个实现类``AppPatchesLoaderImpl``，该类中记录了哪些修改的类。看一下``load``方法\n\n```java\n@Override\n    public boolean load() {\n        try {\n        //遍历已记录的所有修改的类\n            for (String className : getPatchedClasses()) {\n                ClassLoader cl = getClass().getClassLoader();\n                //我们刚才说的修改的类名后面都有$override\n                Class<?> aClass = cl.loadClass(className + \"$override\");\n                Object o = aClass.newInstance();\n                //1.**反射修改原类中的$change字段为修改后的值**\n                Class<?> originalClass = cl.loadClass(className);\n                Field changeField = originalClass.getDeclaredField(\"$change\");\n                // force the field accessibility as the class might not be \"visible\"\n                // from this package.\n                changeField.setAccessible(true);\n                // If there was a previous change set, mark it as obsolete:\n                Object previous = changeField.get(null);\n                if (previous != null) {\n                    Field isObsolete = previous.getClass().getDeclaredField(\"$obsolete\");\n                    if (isObsolete != null) {\n                        isObsolete.set(null, true);\n                    }\n                }\n                changeField.set(null, o);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n```\n\n``Instant run``的热更新原理可以概述为：\n1.第一次运行，应用``transform API``修改字节码。\n输出目录在``app/build/intermediates/transforms/instantRun/debug/folders/1/``，给所有的类添加``$change``字段，``$change``为``IncrementalChange``类型，``IncrementalChange``是个接口。如果``$change``不为空，去调用``$change``的``access$dispatch``方法，参数为方法签名字符串和方法参数数组，否则调用原逻辑。\nload方法中会去加载全部补丁类，并赋值给对应原类的``$change``。\n这也验证了我们说它是多``ClassLoader``方案。\n\n2.所有修改的类有``gradle plugin``自动生成，类名在原名后面添加$override，复制修改后类的大部分方法，实现IncrementalChange 接口的access$dispatch方法，该方法会根据传递过来的方法签名，调用本类的同名方法。\n\n那么也就是说只要把原类的``$change``字段设置为该类，那就会调用该类的``access$dispatch``方法，就会使用修改后的方法了。上面代码1处就通过反射修改了原类中的``$change``为修改后补丁类中的值。``AppPatchesLoaderImpl``记录了所有被修改的类，也会被打进补丁dex。\n\n总结一下，可以看到``Instant run``热更新是多``ClassLoader``加载方案，每个插件dex都有一个``ClassLoader``，如果插件需要升级，直接重新创建一个自定的``ClassLoader``加载新的插件。但是目前来看，``Instant run``修改java代码大部分情况下都是重启更新机制，可能热更新机制还有bug。资源更新是热更新，重启对应Activity就可以。\n\n# 总结\n\n``Instant run``看下来真的有好多东西，其中就以替换``Application``和动态加载尤为重要，关于动态加载，完全可以根据``Instant run``的实现方式完成一个热修复和重启修复相结合的更新框架，用于线上bug的修复和功能更新，并且可以支持资源文件的更新，是无侵入性的更新框架，最重要的一点，这是官方支持的。但是，性能肯定会有所影响，实际开发中使用``Instant run``编译其实还有很多的问题，而且app初始化时使用的很多反射，这也直接导致app的启动速度降低好多。\n\n另外一点关于Application的替换是基于[bazel](https://github.com/bazelbuild/bazel)(一种构建工具，类似于burk)中的[StubApplication](https://github.com/bazelbuild/bazel/blob/master/src/tools/android/java/com/google/devtools/build/android/incrementaldeployment/StubApplication.java)\n\n\n# 参考\n\n* [Android的Proxy/Delegate Application框架](http://blogs.360.cn/blog/proxydelegate-application/)\n* [Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)\n* [Instant Run 浅析](http://jiajixin.cn/2015/11/25/instant-run/)\n* [Instant Run原理解析](http://www.jianshu.com/p/0400fb58d086)","source":"_posts/从Instant run谈Android替换Application和动态加载机制.md","raw":"---\ntitle: 从Instant run谈Android替换Application和动态加载机制\ndate: 2016-05-02 19:33:05\ntags: [Android, 动态加载, 热更新, Install run]\n---\n\n# 背景\n\n``Android studio 2.0 Stable``版本中集成了``Install run``即时编译技术，官方描述可以大幅加速编译速度，我们团队在第一时间更新并使用，总体用下来感觉，恩...也就那样吧，还不如不用的快。所以就去看了下``Install run``的实现方式，其中有一个整体框架的基础，也就是今天的文章的主题，Android替换Application和动态加载机制。\n\n# Instant run\n\n``Instant run``的大概实现原理可以看下这篇[Instant Run 浅析](http://jiajixin.cn/2015/11/25/instant-run/)，我们需要知道``Instant run``使用的``gradle plugin2.0.0``，源码在[这里](https://bintray.com/android/android-tools/com.android.tools.build.gradle/view)，文中大概讲了下``Instant run``的实现原理，但是并没有深入细节，特别是替换Application和动态加载机制。\n\n关于动态加载，实际上``Instant run``提供了两种动态加载的机制：\n1.修改java代码需要重启应用加载补丁dex，而在Application初始化时替换了Application，新建了一个自定义的ClassLoader去加载所有的dex文件。我们称为**重启更新机制**\n2.修改代码不需要重启，新建一个``ClassLoader``去加载修改部分。我们称为**热更新机制**\n\n## Application入口\n\n在编译时``Instant run``用到了``Transform API``修改字节码文件。其中``AndroidManifest.xml``文件也被修改，如下：\n``/app/build/intermediates/bundles/production/instant-run/AndroidManifest.xml``，其中的``Application``标签\n```xml\n<application\n        name=\"com.aa.bb.MyApplication\"\n        android:name=\"com.android.tools.fd.runtime.BootstrapApplication\"\n\t\t... />\n```\n多了一个``com.android.tools.fd.runtime.BootstrapApplication``，在刚刚提到的``gradle plugin``中的``instant-run-server``目录下找到该文件。\n\n实际上``BootstrapApplication``是我们app的实际入口，我们自己的``Application``即``MyApplication``采用反射机制调用。\n我们知道``Application``是``ContextWrapper``的子类\n\n```java\n// android.app.Application\npublic class Application extends ContextWrapper {\n    // ...\n    public application() {\n        super(null);\n    }\n    // ...\n}\n// android.content.ContextWrapper\npublic class ContextWrapper extends Context {\n    Context mBase;\n    // ...\n    public ContextWrapper(Context base) {\n        mBase = base;\n    }\n    protected void attachBaseContext(Context base) {\n        if (mBase != null) {\n            throw new IllegalStateException(\"Base context already set\");\n        }\n        mBase = base;\n    }\n    // ...\n    @Override\n    public AssetManager getAssets() {\n        return mBase.getAssets();\n    }\n    @Override\n    public Resources getResources()\n    {\n        return mBase.getResources();\n    }\n    // ...\n}\n```\n\nContextWrapper一方面继承了Context，一方面又包含(composite)了一个Context对象（称为mBase），对Context的实现为转发给mBase对象处理。上面的代码表示，在``attachBaseContext``方式调用之前Application是没有用的，因为mBase是空的。所以我们看下``BootstrapApplication``的``attachBaseContext``方法\n\n```java\nprotected void attachBaseContext(Context context) {\n        if (!AppInfo.usingApkSplits) {\n            createResources(apkModified);\n            //新建一个ClassLoader并设置为原ClassLoader的parent\n            setupClassLoaders(context, context.getCacheDir().getPath(), apkModified);\n        }\n\t\t//通过Manifest中我们的实际Application即MyApplication名反射生成对象\n        createRealApplication();\n\t\t//调用attachBaseContext完成初始化\n        super.attachBaseContext(context);\n\n        if (realApplication != null) {\n        //反射调用实际Application的attachBaseContext方法\n            try {\n                Method attachBaseContext =\n                        ContextWrapper.class.getDeclaredMethod(\"attachBaseContext\", Context.class);\n                attachBaseContext.setAccessible(true);\n                attachBaseContext.invoke(realApplication, context);\n            } catch (Exception e) {\n                throw new IllegalStateException(e);\n            }\n        }\n    }\n```\n\n初始化ClassLoader\n\n```java\n//BootstrapApplication.setupClassLoaders\nprivate static void setupClassLoaders(Context context, String codeCacheDir, long apkModified) {\n\t\t// /data/data/package_name/files/instant-run/dex/目录下的dex列表\n        List<String> dexList = FileManager.getDexList(context, apkModified);\n            ClassLoader classLoader = BootstrapApplication.class.getClassLoader();\n            String nativeLibraryPath = (String) classLoader.getClass().getMethod(\"getLdLibraryPath\")\n                                .invoke(classLoader);\n            IncrementalClassLoader.inject(\n                    classLoader,\n                    nativeLibraryPath,\n                    codeCacheDir,\n                    dexList);\n        }\n    }\n    \n//IncrementalClassLoader.inject\npublic static ClassLoader inject(\n            ClassLoader classLoader, String nativeLibraryPath, String codeCacheDir,\n            List<String> dexes) {\n        //新建一个自定义ClassLoader，dexPath为参数中的dexList\n        IncrementalClassLoader incrementalClassLoader =\n                new IncrementalClassLoader(classLoader, nativeLibraryPath, codeCacheDir, dexes);\n        //设置为原ClassLoader的parent\n        setParent(classLoader, incrementalClassLoader);\n\t\treturn incrementalClassLoader;\n    }\n```\n\n## 动态加载\n\n新建一个自定义的``ClassLoader``名为IncrementalClassLoader，该``ClassLoader``很简单，就是``BaseDexClassLoader``的一个子类，并且将``IncrementalClassLoader``设置为原ClassLoader的parent，熟悉JVM加载机制的同学应该都知道，由于ClassLoader采用双亲委托模式，即委托父类加载类，父类找不到再自己去找。这样``IncrementalClassLoader``就变成了整个App的所有类的加载的ClassLoader，并且dexPath是``/data/data/package_name/files/instant-run/dex``目录下的dex列表，这意味着什么呢？\n\n```java\n\n//``BaseDexClassLoader``的``findClass``\nprotected Class<?> findClass(String name) throws ClassNotFoundException {\n    List<Throwable> suppressedExceptions = new ArrayList<Throwable>();\n    Class c = pathList.findClass(name, suppressedExceptions);\n    if (c == null) {\n        ClassNotFoundException cnfe = new ClassNotFoundException(\"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList);\n        for (Throwable t : suppressedExceptions) {\n            cnfe.addSuppressed(t);\n        }\n        throw cnfe;\n    }\n    return c;\n}\n```\n\n可以看到，查找Class的任务通过pathList完成；这个pathList是一个DexPathList类的对象，它的findClass方法如下：\n\n```java\npublic Class findClass(String name, List<Throwable> suppressed) {\n   for (Element element : dexElements) {\n       DexFile dex = element.dexFile;\n\n       if (dex != null) {\n           Class clazz = dex.loadClassBinaryName(name, definingContext, suppressed);\n           if (clazz != null) {\n               return clazz;\n           }\n       }\n   }\n   if (dexElementsSuppressedExceptions != null) {\n       suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));\n   }\n   return null;\n}\n```\n\n这个DexPathList内部有一个叫做dexElements的数组，然后findClass的时候会遍历这个数组来查找Class。看到了吗，这个dexElements就是从dexPath来的，也就说是``IncrementalClassLoader``用来加载dexPath(/data/data/package_name/files/instant-run/dex/)下面的dex文件。感兴趣的同学可以看下，我们app中的所有第三方库和自己项目中的代码，都被打包成若干个slice dex分片，该目录下有几十个dex文件。每当修改代码用``Instant run``完成编译，该目录下的dex文件就会有一个或者几个的更新时间发生改变。\n\n正常情况下，apk被安装之后，APK文件的代码以及资源会被系统存放在固定的目录（比如/data/app/package_name/base-1.apk )系统在进行类加载的时候，会自动去这一个或者几个特定的路径来寻找这个类。而使用``Install run``则完全不管之前的加载路径，所有的分片dex文件和资源都在dexPath下，用``IncrementalClassLoader``去加载。也就是加载不存在APK固定路径之外的类，即动态加载。\n\n但是仅仅有ClassLoader是不够的。因为每个被修改的类都被改了名字，类名在原名后面添加``$override``，目录在``app/build/intermediates/transforms/instantRun/debug/folders/4000``。AndroidManifest中并没有注册这些被改了名字的Activity。> 因此正常情况下系统无法加载我们插件中的类；因此也没有办法创建Activity的对象。\n> 解决这个问题有两个思路，要么全盘接管这个类加载的过程；要么告知系统我们使用的插件存在于哪里，让系统帮忙加载；这两种方式或多或少都需要干预这个类加载的过程。\n> 引用自 -- [Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)\n\n\n\n## 动态加载的两种方案\n\n先来看下系统如何完成类的加载过程。\n``Activity``的创建过程\n\n```java\njava.lang.ClassLoader cl = r.packageInfo.getClassLoader();\nactivity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);\nStrictMode.incrementExpectedActivityCount(activity.getClass());\nr.intent.setExtrasClassLoader(cl);\n```\n\n通过``ClassLoader``和类名加载，反射调用生成``Activity``对象，其中的``ClassLoader``从``LoadedApk``的一个对象``r.packageInfo``中获得的。``LoadedApk``对象是APK文件在内存中的表示。 Apk文件的相关信息，诸如Apk文件的代码和资源，甚至代码里面的``Activity``，``Service``等组件的信息我们都可以通过此对象获取。\nr.packageInfo的来源：\n\n```java\nprivate LoadedApk getPackageInfo(ApplicationInfo aInfo, CompatibilityInfo compatInfo,\n        ClassLoader baseLoader, boolean securityViolation, boolean includeCode,\n        boolean registerPackage) {\n        // 获取userid信息\n    final boolean differentUser = (UserHandle.myUserId() != UserHandle.getUserId(aInfo.uid));\n    synchronized (mResourcesManager) {\n    // 尝试获取缓存信息\n        WeakReference<LoadedApk> ref;\n        if (differentUser) {\n            // Caching not supported across users\n            ref = null;\n        } else if (includeCode) {\n            ref = mPackages.get(aInfo.packageName);\n        } else {\n            ref = mResourcePackages.get(aInfo.packageName);\n        }\n\n        LoadedApk packageInfo = ref != null ? ref.get() : null;\n        if (packageInfo == null || (packageInfo.mResources != null\n                && !packageInfo.mResources.getAssets().isUpToDate())) {\n                // 缓存没有命中，直接new\n            packageInfo =\n                new LoadedApk(this, aInfo, compatInfo, baseLoader,\n                        securityViolation, includeCode &&\n                        (aInfo.flags&ApplicationInfo.FLAG_HAS_CODE) != 0, registerPackage);\n\n        // 省略。。更新缓存\n        return packageInfo;\n    }\n}\n```\n\n重要的是这个缓存``mPackage``，``LoadedApk``对象``packageInfo``就是从这个缓存中取的，所以我们只要在``mPackage``修改里面的``ClassLoader``控制类的加载就能完成动态加载。\n\n在《[Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)》一文中，作者已经提出两种动态加载的解决方案：\n\n> 『激进方案』中我们自定义了插件的ClassLoader，并且绕开了Framework的检测；利用ActivityThread对于LoadedApk的缓存机制，我们把携带这个自定义的ClassLoader的插件信息添加进mPackages中，进而完成了类的加载过程。\n\n>『保守方案』中我们深入探究了系统使用ClassLoader findClass的过程，发现应用程序使用的非系统类都是通过同一个PathClassLoader加载的；而这个类的最终父类BaseDexClassLoader通过DexPathList完成类的查找过程；我们hack了这个查找过程，从而完成了插件类的加载。\n\n激进方案由于是一个插件一个``Classloader``也叫多``ClassLoader``方案，代表作[DroidPlugin](https://github.com/Qihoo360/DroidPlugin)；保守方案也叫做单``ClassLoader``方案，代表作，Small、众多热更新框架如[nuwa](https://github.com/jasonross/Nuwa)等。\n\n## Instant run的重启更新机制\n\n绕了一大圈，终于能接着往下看了。接上面，我们继续看``BootstrapApplication``的``onCreate``方法\n\n```java\npublic void onCreate() {\n        MonkeyPatcher.monkeyPatchApplication(\n                    BootstrapApplication.this, BootstrapApplication.this,\n                    realApplication, externalResourcePath);\n            MonkeyPatcher.monkeyPatchExistingResources(BootstrapApplication.this,\n                    externalResourcePath, null);\n        super.onCreate();\n        ...\n\t\t//手机客户端app和Android Studio建立Socket通信，AS是客户端发消息，app\t\t//是服务端接收消息作出相应操作。Instant run的通信方式。不在本文范围内\n        Server.create(AppInfo.applicationId, BootstrapApplication.this);\n\n        if (realApplication != null) {\n        \t//还记得这个realApplication吗，我们app中实际的Application\n            realApplication.onCreate();\n        }\n    }\n```\n\n上面代码，手机客户端app和Android Studio建立Socket通信，AS是客户端发消息，app是服务端接收消息作出相应操作，这是Instant run的通信方式，不在本文范围内。然后反射调用实际``Application``的``onCreate``方法。\n那么前面的两个``MonkeyPatcher``的方法是干嘛的呢\n\n先看``MonkeyPatcher.monkeyPatchApplication``\n\n```java\npublic static void monkeyPatchApplication(@Nullable Context context,\n                                              @Nullable Application bootstrap,\n                                              @Nullable Application realApplication,\n                                              @Nullable String externalResourceFile) {\n        try {\n            // Find the ActivityThread instance for the current thread\n            Class<?> activityThread = Class.forName(\"android.app.ActivityThread\");\n            Object currentActivityThread = getActivityThread(context, activityThread);\n\n            // Find the mInitialApplication field of the ActivityThread to the real application\n            Field mInitialApplication = activityThread.getDeclaredField(\"mInitialApplication\");\n            mInitialApplication.setAccessible(true);\n            Application initialApplication = (Application) mInitialApplication.get(currentActivityThread);\n            if (realApplication != null && initialApplication == bootstrap) {\n            //**2.替换掉ActivityThread.mInitialApplication**\n                mInitialApplication.set(currentActivityThread, realApplication);\n            }\n\n            // Replace all instance of the stub application in ActivityThread#mAllApplications with the\n            // real one\n            if (realApplication != null) {\n                Field mAllApplications = activityThread.getDeclaredField(\"mAllApplications\");\n                mAllApplications.setAccessible(true);\n                List<Application> allApplications = (List<Application>) mAllApplications\n                        .get(currentActivityThread);\n                for (int i = 0; i < allApplications.size(); i++) {\n                    if (allApplications.get(i) == bootstrap) {\n                    //**1.替换掉ActivityThread.mAllApplications**\n                        allApplications.set(i, realApplication);\n                    }\n                }\n            }\n\n            // Figure out how loaded APKs are stored.\n\n            // API version 8 has PackageInfo, 10 has LoadedApk. 9, I don't know.\n            Class<?> loadedApkClass;\n            try {\n                loadedApkClass = Class.forName(\"android.app.LoadedApk\");\n            } catch (ClassNotFoundException e) {\n                loadedApkClass = Class.forName(\"android.app.ActivityThread$PackageInfo\");\n            }\n            Field mApplication = loadedApkClass.getDeclaredField(\"mApplication\");\n            mApplication.setAccessible(true);\n            Field mResDir = loadedApkClass.getDeclaredField(\"mResDir\");\n            mResDir.setAccessible(true);\n\n            // 10 doesn't have this field, 14 does. Fortunately, there are not many Honeycomb devices\n            // floating around.\n            Field mLoadedApk = null;\n            try {\n                mLoadedApk = Application.class.getDeclaredField(\"mLoadedApk\");\n            } catch (NoSuchFieldException e) {\n                // According to testing, it's okay to ignore this.\n            }\n\n            // Enumerate all LoadedApk (or PackageInfo) fields in ActivityThread#mPackages and\n            // ActivityThread#mResourcePackages and do two things:\n            //   - Replace the Application instance in its mApplication field with the real one\n            //   - Replace mResDir to point to the external resource file instead of the .apk. This is\n            //     used as the asset path for new Resources objects.\n            //   - Set Application#mLoadedApk to the found LoadedApk instance\n            for (String fieldName : new String[]{\"mPackages\", \"mResourcePackages\"}) {\n                Field field = activityThread.getDeclaredField(fieldName);\n                field.setAccessible(true);\n                Object value = field.get(currentActivityThread);\n\n                for (Map.Entry<String, WeakReference<?>> entry :\n                        ((Map<String, WeakReference<?>>) value).entrySet()) {\n                    Object loadedApk = entry.getValue().get();\n                    if (loadedApk == null) {\n                        continue;\n                    }\n\n                    if (mApplication.get(loadedApk) == bootstrap) {\n                        if (realApplication != null) {\n                        //**3.替换掉mApplication**\n                            mApplication.set(loadedApk, realApplication);\n                        }\n                        if (externalResourceFile != null) {\n                        //替换掉资源目录\n                            mResDir.set(loadedApk, externalResourceFile);\n                        }\n\n                        if (realApplication != null && mLoadedApk != null) {\n                        //**4.替换掉mLoadedApk**\n                            mLoadedApk.set(realApplication, loadedApk);\n                        }\n                    }\n                }\n            }\n        } catch (Throwable e) {\n            throw new IllegalStateException(e);\n        }\n    }\n```\n\n这里做了三件事情：\n\n1.替换Application对象\n\n``BootstrapApplication``的作用就是加载``realApplication``也就是``MyApplication``，所以我们就要把所有Framework层的``BootstrapApplication``对象替换为``MyApplication``对象。包括：\n\n```java\nbaseContext.mPackageInfo.mApplication 代码3处\nbaseContext.mPackageInfo.mActivityThread.mInitialApplication 代码2处\nbaseContext.mPackageInfo.mActivityThread.mAllApplications 代码1处\n```\n\n2.替换资源相关对象mResDir，前面我们已经说过，正常情况下寻找资源都是在``/data/app/package_name/base-1.apk``目录下，而``Instant run``将资源也抽出来放在``/data/data/package_name/files/instant-run/``，加载目录也更改为后者\n\n3.替换``mLoadedApk``对象\n还记得前面的讲的``LoadedApk``吗，这里面有加载类的``ClassLoader``，由于``BootstrapApplication``在``attachBaseContext``方法中就将其已经替换为了``IncrementalClassLoader``，所以代码4处反射将``BootstrapApplication``的``mLoadedApk``赋值给了``MyApplication``，那么接下来MyApplication的所有类的加载都将由``IncrementalClassLoader``来负责。\n\n``MonkeyPatcher.monkeyPatchExistingResources``更新资源补丁，不在本文范围内就不讲了。\n\n这些工作做完之后调用``MyApplication``的``onCreate``方法``BootstrapApplication``就将控制权交给了``MyApplication``，这样在整个运行环境中，``MyApplication``就是正牌``Application``了，完成``Application``的替换。\n\n总结一下，刚才我们说了已经有两个动态加载的方案，激进方案和保守方案,而``Instant run``的重启更新机制更像后者--保守方案即单``ClassLoader``方案，首先，该种方案只有一个``ClassLoader``，只不过是通过替换``Application``达到的替换``mLoadedApk``进而替换``ClassLoader``的目的，并没有涉及到缓存``mPackage``然后dexList也是它自己维护的。\n\n## Instant run 热更新机制\n\nInstant run哪里用到的热更新机制呢？还记得刚才我们提到的Socket通信吗，其中S端也就是手机客户端，接收到热更新的消息会执行下面的方法：\n\n```java\n private int handleHotSwapPatch(int updateMode, @NonNull ApplicationPatch patch) {\n        try {\n            String dexFile = FileManager.writeTempDexFile(patch.getBytes());\n            String nativeLibraryPath = FileManager.getNativeLibraryFolder().getPath();\n            //新建一个ClassLoader，dexFile是刚更新的插件\n            DexClassLoader dexClassLoader = new DexClassLoader(dexFile,\n                    mApplication.getCacheDir().getPath(), nativeLibraryPath,\n                    getClass().getClassLoader());\n\n            // we should transform this process with an interface/impl\n            Class<?> aClass = Class.forName(\n                    \"com.android.tools.fd.runtime.AppPatchesLoaderImpl\", true, dexClassLoader);\n            try {\n                PatchesLoader loader = (PatchesLoader) aClass.newInstance();\n                String[] getPatchedClasses = (String[]) aClass\n                        .getDeclaredMethod(\"getPatchedClasses\").invoke(loader);\n                //loader是PatchesLoader的一个实例，调用load方法加载插件\n                if (!loader.load()) {\n                    updateMode = UPDATE_MODE_COLD_SWAP;\n                }\n            } catch (Exception e) {\n                updateMode = UPDATE_MODE_COLD_SWAP;\n            }\n        } catch (Throwable e) {\n            updateMode = UPDATE_MODE_COLD_SWAP;\n        }\n        return updateMode;\n    }\n```\n\n可以看到根据单个dexFile新建了一个``ClassLoader``，然后调用``loader.load()``方法，``loader``是``PatchesLoader``接口的实例，``PatchesLoader``接口的一个实现类``AppPatchesLoaderImpl``，该类中记录了哪些修改的类。看一下``load``方法\n\n```java\n@Override\n    public boolean load() {\n        try {\n        //遍历已记录的所有修改的类\n            for (String className : getPatchedClasses()) {\n                ClassLoader cl = getClass().getClassLoader();\n                //我们刚才说的修改的类名后面都有$override\n                Class<?> aClass = cl.loadClass(className + \"$override\");\n                Object o = aClass.newInstance();\n                //1.**反射修改原类中的$change字段为修改后的值**\n                Class<?> originalClass = cl.loadClass(className);\n                Field changeField = originalClass.getDeclaredField(\"$change\");\n                // force the field accessibility as the class might not be \"visible\"\n                // from this package.\n                changeField.setAccessible(true);\n                // If there was a previous change set, mark it as obsolete:\n                Object previous = changeField.get(null);\n                if (previous != null) {\n                    Field isObsolete = previous.getClass().getDeclaredField(\"$obsolete\");\n                    if (isObsolete != null) {\n                        isObsolete.set(null, true);\n                    }\n                }\n                changeField.set(null, o);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n```\n\n``Instant run``的热更新原理可以概述为：\n1.第一次运行，应用``transform API``修改字节码。\n输出目录在``app/build/intermediates/transforms/instantRun/debug/folders/1/``，给所有的类添加``$change``字段，``$change``为``IncrementalChange``类型，``IncrementalChange``是个接口。如果``$change``不为空，去调用``$change``的``access$dispatch``方法，参数为方法签名字符串和方法参数数组，否则调用原逻辑。\nload方法中会去加载全部补丁类，并赋值给对应原类的``$change``。\n这也验证了我们说它是多``ClassLoader``方案。\n\n2.所有修改的类有``gradle plugin``自动生成，类名在原名后面添加$override，复制修改后类的大部分方法，实现IncrementalChange 接口的access$dispatch方法，该方法会根据传递过来的方法签名，调用本类的同名方法。\n\n那么也就是说只要把原类的``$change``字段设置为该类，那就会调用该类的``access$dispatch``方法，就会使用修改后的方法了。上面代码1处就通过反射修改了原类中的``$change``为修改后补丁类中的值。``AppPatchesLoaderImpl``记录了所有被修改的类，也会被打进补丁dex。\n\n总结一下，可以看到``Instant run``热更新是多``ClassLoader``加载方案，每个插件dex都有一个``ClassLoader``，如果插件需要升级，直接重新创建一个自定的``ClassLoader``加载新的插件。但是目前来看，``Instant run``修改java代码大部分情况下都是重启更新机制，可能热更新机制还有bug。资源更新是热更新，重启对应Activity就可以。\n\n# 总结\n\n``Instant run``看下来真的有好多东西，其中就以替换``Application``和动态加载尤为重要，关于动态加载，完全可以根据``Instant run``的实现方式完成一个热修复和重启修复相结合的更新框架，用于线上bug的修复和功能更新，并且可以支持资源文件的更新，是无侵入性的更新框架，最重要的一点，这是官方支持的。但是，性能肯定会有所影响，实际开发中使用``Instant run``编译其实还有很多的问题，而且app初始化时使用的很多反射，这也直接导致app的启动速度降低好多。\n\n另外一点关于Application的替换是基于[bazel](https://github.com/bazelbuild/bazel)(一种构建工具，类似于burk)中的[StubApplication](https://github.com/bazelbuild/bazel/blob/master/src/tools/android/java/com/google/devtools/build/android/incrementaldeployment/StubApplication.java)\n\n\n# 参考\n\n* [Android的Proxy/Delegate Application框架](http://blogs.360.cn/blog/proxydelegate-application/)\n* [Android 插件化原理解析——插件加载机制](http://weishu.me/2016/04/05/understand-plugin-framework-classloader/)\n* [Instant Run 浅析](http://jiajixin.cn/2015/11/25/instant-run/)\n* [Instant Run原理解析](http://www.jianshu.com/p/0400fb58d086)","slug":"从Instant run谈Android替换Application和动态加载机制","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6s000zwhs6hjmg2qiv"},{"title":"Android计步","date":"2016-06-26T02:35:39.000Z","_content":"\n# 前言\n\n计步越来越成为人们的强需求，一般有手环计步，手表计步，手机计步等实现，这篇文章讨论下手机上实现计步的两种方案。\n\n# 加速度传感器（gsensor）\n\n人在走路时，加速度传感器会形成一个类似正弦波形图，因此可以根据检测波峰波谷记步。见下图：\n\n![](http://www.analog.com/library/analogDialogue/archives/44-06/AD44_06_FIG_03.jpg)\n\n可以分为几步进行：\n\n 1. 特征选取，由于手机在不同放置条件下三轴传感器会有不同的数据表现，所以 可以取三轴的平方和。\n 2. 滤波，由于得到的数据存在一定的噪音，我们需要过滤掉这些噪音得到比 较平滑的数据，一般有中值滤波和低通滤波。\n 3. 计步监测，我们一般采用判断峰谷值来决定是否是一次计步。\n 4. 动态阈值，采用判断峰谷值来记步需要动态的计算阈值，符合阈值标准才能算一次计步。\n 5. 步数矫正，人的步伐速度在200-2000ms之间，通过记录记步的时间戳，矫正步数。步伐间隔<200ms和>2000ms，认为是无效步数。\n\n使用gsensor来计步可能会存在以下问题：\n\n - 续航问题，由于要不停的监测gsensor变化和计算，就会导致手机不会进入休眠状态，一直保持CPU的唤醒，这对于手机的续航可能会带来一定的影响。\n - 精度问题，计步算法需要不断的产品迭代，并且要有较好的步数矫正机制，短时间内不能做到优秀的计步功能。\n - 后台service保活问题，要保证后台可以实时统计步数需要后台服务一直运行，包括低内存防杀机制、自启机制等。\n - 对于一些锁屏自动关闭sensor的定制系统来说不可用。\n \n# 计步传感器（step-sensor）\n\n相对于使用加速度传感器获取数据和计算实现计步的方式，通过计步传感器sensor监测或者读取计步数对于终端的续航能力有了很大的提高。\n\n在Android4.4（KITKAT）系统API提供了两种硬件计步传感器的支持，因为是硬件所以需要厂商支持。可以通过以下方式查看你的手机是否支持\n\n - adb shell pm list features\n 如果有以下两项说明支持\n```java\nfeature:android.hardware.sensor.stepcounter\nfeature:android.hardware.sensor.stepdetector\n```\n - 代码检测Android4.4后更高并且有sensor支持\n```java\n    private boolean isKitkatWithStepSensor() {\n        // BEGIN_INCLUDE(iskitkatsensor)\n        // Require at least Android KitKat\n        int currentApiVersion = android.os.Build.VERSION.SDK_INT;\n        // Check that the device supports the step counter and detector sensors\n        PackageManager packageManager = getActivity().getPackageManager();\n        return currentApiVersion >= android.os.Build.VERSION_CODES.KITKAT\n                && packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_STEP_COUNTER)\n                && packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_STEP_DETECTOR);\n        // END_INCLUDE(iskitkatsensor)\n    }\n```\n\n在使用前需要声明权限\n\n```java\n<uses-feature android:name=\"android.hardware.sensor.stepcounter\" />\n<uses-feature android:name=\"android.hardware.sensor.stepdetector\" />\n```\n\n 1. TYPE_STEP_COUNTER\n API的解释说返回从开机被激活后统计的步数，当重启手机后该数据归零，该传感器是一个硬件传感器所以它是低功耗的。为了能持续的计步，请不要反注册事件，就算手机处于休眠状态它依然会计步。当激活的时候依然会上报步数。该sensor适合在长时间的计步需求。\n\n 2. TYPE_STEP_DETECTOR\n 翻译过来就是走路检测，API文档也确实是这样说的，该sensor只用来监监测走步，每次返回数字1.0。如果需要长事件的计步请使用TYPE_STEP_COUNTER。\n\n用法比较简单，实现比较方便，由于我们需要长时间的计步，所以一般我们采用``TYPE_STEP_COUNTER``。\n优点：\n\n - 精度相对来说精确。\n - 低功耗，对手机续航基本没有影响。\n - 不需要后台服务持续唤醒，所以不需要后台保活。\n - 实现简单。\n\n缺点：\n\n - 手机必须要Android4.4及以上版本，并且内置计步sensor硬件\n - 并不像iOS的M7协处理器记录每天各个时段的计步数据，step counter sensor记录从开机以来所有的步数，每日计步数需要自己维护。\n \n# 总结\n\n总结来说，如果用g-sensor来实现计步会保证良好的兼容性，排除锁屏自动关闭sensor的定制系统除外，基本所有的Android手机都可以使用，但是需要一定时间的算法调试和后台保活机制的健全保证，开发周期较长；如果项目需求开发周期较短，并且没有强制性的全机型兼容，那么可以考虑使用step-sensor，优点比较明显，而且使用协处理器代替纯软件计算实现计步监测已经是大势所趋。另外以上两种方案都需要开机自启权限。\n\n# 参考\n\n[如何在手机上实现高精度及自适应多种场景的计步器算法][1]\n[Android-Developers-Samples-BatchStepSensor][2]\n[利用3轴数字加速度计实现功能全面的计步器设计][3]\n\n\n  [1]: http://www.wujiame.com/blog/2013/12/27/pedometer/\n  [2]: https://github.com/johnjohndoe/Android-Developers-Samples/tree/master/BatchStepSensor\n  [3]: http://www.analog.com/library/analogDialogue/china/archives/44-06/pedometer.html","source":"_posts/step-counter.md","raw":"---\ntitle: Android计步\ndate: 2016-06-26 10:35:39\ntags: [Android]\n---\n\n# 前言\n\n计步越来越成为人们的强需求，一般有手环计步，手表计步，手机计步等实现，这篇文章讨论下手机上实现计步的两种方案。\n\n# 加速度传感器（gsensor）\n\n人在走路时，加速度传感器会形成一个类似正弦波形图，因此可以根据检测波峰波谷记步。见下图：\n\n![](http://www.analog.com/library/analogDialogue/archives/44-06/AD44_06_FIG_03.jpg)\n\n可以分为几步进行：\n\n 1. 特征选取，由于手机在不同放置条件下三轴传感器会有不同的数据表现，所以 可以取三轴的平方和。\n 2. 滤波，由于得到的数据存在一定的噪音，我们需要过滤掉这些噪音得到比 较平滑的数据，一般有中值滤波和低通滤波。\n 3. 计步监测，我们一般采用判断峰谷值来决定是否是一次计步。\n 4. 动态阈值，采用判断峰谷值来记步需要动态的计算阈值，符合阈值标准才能算一次计步。\n 5. 步数矫正，人的步伐速度在200-2000ms之间，通过记录记步的时间戳，矫正步数。步伐间隔<200ms和>2000ms，认为是无效步数。\n\n使用gsensor来计步可能会存在以下问题：\n\n - 续航问题，由于要不停的监测gsensor变化和计算，就会导致手机不会进入休眠状态，一直保持CPU的唤醒，这对于手机的续航可能会带来一定的影响。\n - 精度问题，计步算法需要不断的产品迭代，并且要有较好的步数矫正机制，短时间内不能做到优秀的计步功能。\n - 后台service保活问题，要保证后台可以实时统计步数需要后台服务一直运行，包括低内存防杀机制、自启机制等。\n - 对于一些锁屏自动关闭sensor的定制系统来说不可用。\n \n# 计步传感器（step-sensor）\n\n相对于使用加速度传感器获取数据和计算实现计步的方式，通过计步传感器sensor监测或者读取计步数对于终端的续航能力有了很大的提高。\n\n在Android4.4（KITKAT）系统API提供了两种硬件计步传感器的支持，因为是硬件所以需要厂商支持。可以通过以下方式查看你的手机是否支持\n\n - adb shell pm list features\n 如果有以下两项说明支持\n```java\nfeature:android.hardware.sensor.stepcounter\nfeature:android.hardware.sensor.stepdetector\n```\n - 代码检测Android4.4后更高并且有sensor支持\n```java\n    private boolean isKitkatWithStepSensor() {\n        // BEGIN_INCLUDE(iskitkatsensor)\n        // Require at least Android KitKat\n        int currentApiVersion = android.os.Build.VERSION.SDK_INT;\n        // Check that the device supports the step counter and detector sensors\n        PackageManager packageManager = getActivity().getPackageManager();\n        return currentApiVersion >= android.os.Build.VERSION_CODES.KITKAT\n                && packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_STEP_COUNTER)\n                && packageManager.hasSystemFeature(PackageManager.FEATURE_SENSOR_STEP_DETECTOR);\n        // END_INCLUDE(iskitkatsensor)\n    }\n```\n\n在使用前需要声明权限\n\n```java\n<uses-feature android:name=\"android.hardware.sensor.stepcounter\" />\n<uses-feature android:name=\"android.hardware.sensor.stepdetector\" />\n```\n\n 1. TYPE_STEP_COUNTER\n API的解释说返回从开机被激活后统计的步数，当重启手机后该数据归零，该传感器是一个硬件传感器所以它是低功耗的。为了能持续的计步，请不要反注册事件，就算手机处于休眠状态它依然会计步。当激活的时候依然会上报步数。该sensor适合在长时间的计步需求。\n\n 2. TYPE_STEP_DETECTOR\n 翻译过来就是走路检测，API文档也确实是这样说的，该sensor只用来监监测走步，每次返回数字1.0。如果需要长事件的计步请使用TYPE_STEP_COUNTER。\n\n用法比较简单，实现比较方便，由于我们需要长时间的计步，所以一般我们采用``TYPE_STEP_COUNTER``。\n优点：\n\n - 精度相对来说精确。\n - 低功耗，对手机续航基本没有影响。\n - 不需要后台服务持续唤醒，所以不需要后台保活。\n - 实现简单。\n\n缺点：\n\n - 手机必须要Android4.4及以上版本，并且内置计步sensor硬件\n - 并不像iOS的M7协处理器记录每天各个时段的计步数据，step counter sensor记录从开机以来所有的步数，每日计步数需要自己维护。\n \n# 总结\n\n总结来说，如果用g-sensor来实现计步会保证良好的兼容性，排除锁屏自动关闭sensor的定制系统除外，基本所有的Android手机都可以使用，但是需要一定时间的算法调试和后台保活机制的健全保证，开发周期较长；如果项目需求开发周期较短，并且没有强制性的全机型兼容，那么可以考虑使用step-sensor，优点比较明显，而且使用协处理器代替纯软件计算实现计步监测已经是大势所趋。另外以上两种方案都需要开机自启权限。\n\n# 参考\n\n[如何在手机上实现高精度及自适应多种场景的计步器算法][1]\n[Android-Developers-Samples-BatchStepSensor][2]\n[利用3轴数字加速度计实现功能全面的计步器设计][3]\n\n\n  [1]: http://www.wujiame.com/blog/2013/12/27/pedometer/\n  [2]: https://github.com/johnjohndoe/Android-Developers-Samples/tree/master/BatchStepSensor\n  [3]: http://www.analog.com/library/analogDialogue/china/archives/44-06/pedometer.html","slug":"step-counter","published":1,"updated":"2016-06-26T12:17:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6v0017whs6yiyf28rr"},{"title":"Hexo Material主题","date":"2016-11-17T02:41:20.000Z","_content":"\n\n\n# Material\n\n最近把博客主题换成了[Material][1]，该主题刚刚上线，效果还不错。\n\n需要把以前的配置迁移一下，包括留言之类的。\n\n# 多说评论\n\n由于之前用的NexT主题，多说后台每篇文章的thread-key是根据NexT主题来的，现在Material主题的多说配置文件如下：\n\n```java\n<div id=\"comments\">\n    <!-- 多说评论框 start -->\n        <div class=\"ds-thread\" data-thread-key=\"<% if(theme.comment.duoshuo_thread_key == \"id\"){ %><%= page.id %><% } else { %><%= page.path %><% } %>\" data-url=\"<%= config.url+ config.root + url_for(path) %>\"></div>\n    <!-- 多说评论框 end -->\n</div>\n```\nduoshuo_thread_key配成了page.title，就导致我们找不到多说后台的数据。\n\n所以要找到NexT主题相关多说的配置。\n\n```java\ncd themes/next/layout\ngrep -ri \"thread-key\" ./*\n```\n\n结果：\n\n```java\n./_macro/post.swig:                  <span class=\"post-comments-count ds-thread-count\" data-thread-key=\"{{ post.path }}\" itemprop=\"commentsCount\"></span>\n./_partials/comments.swig:      <div class=\"ds-thread\" data-thread-key=\"{{ page.path }}\"\n./_partials/share/duoshuo_share.swig:<div class=\"ds-share flat\" data-thread-key=\"{{ page.path }}\"\n```\n\n可以看到NexT配置的是page.path。那么我们找到Material主题的thread-key替换下就好了。主要就是两个地方:\n\n - ./layout/_widget/duoshuo.ejs 文章评论内容\n - ./layout/_partial/Paradox-post_entry.ejs 首页显示评论数\n\n都修改下就能正常显示以前的评论了。\n\n# 每日一图\n\nMaterial主题首页有个每日图片，默认是写死的。我们可以改为动态的，使用了bing的每日图片，是一位开发者抓取的然后提供的一个api，地址：[必应美图 API][2]\n\n使用：\n\n```java\n./_partial/daily_pic.ejs\n<div class=\"mdl-card__media mdl-color-text--grey-50\" style=\"background-image:url(https://api.i-meto.com/bing)\">\n```\n\n# backgroud\n\n同上背景图也可以设置成bing的图片。\n\n```java\nconfig_css.ejs\n<% if(theme.background.bing.enable == true){ %>\n\t<style>\n\t\tbody{\n            background-image: url(https://api.i-meto.com/bing?<%= theme.background.bing.parameter %>);\n        }\n\t</style>\n```\n\nconfig配置文件\n\n```java\n# Background Settings\n# bing available parameter:\n#     new | color= | type=\n#         color available value: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow\n#         type available value: A (animal), C (culture), N (nature), S (space), T (travel)\nbackground:\n    purecolor: \"#F5F5F5\"\n    bgimg: blur\n    bing:\n        parameter: color=white\n        enable: true\n```\n\n# 不算子统计\n\n站点统计\n```java\nfooter.ejs\n\t\t<div>\n\t\t<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n\t\t<div>\n\t\t本站总访问量 <span id=\"busuanzi_value_site_pv\"></span> &nbsp&nbsp&nbsp\n\t\t你是第<span id=\"busuanzi_value_site_uv\"></span>个来到的小伙伴\n\t\t</div>\n\t\t</div>\n```\n\n\n\n\n  [1]: https://github.com/viosey/hexo-theme-material\n  [2]: https://i-meto.com/bing-api/","source":"_posts/hexo-theme-material.md","raw":"---\ntitle: Hexo Material主题 \ndate: 2016-11-17 10:41:20\ntags: [Hexo]\n---\n\n\n\n# Material\n\n最近把博客主题换成了[Material][1]，该主题刚刚上线，效果还不错。\n\n需要把以前的配置迁移一下，包括留言之类的。\n\n# 多说评论\n\n由于之前用的NexT主题，多说后台每篇文章的thread-key是根据NexT主题来的，现在Material主题的多说配置文件如下：\n\n```java\n<div id=\"comments\">\n    <!-- 多说评论框 start -->\n        <div class=\"ds-thread\" data-thread-key=\"<% if(theme.comment.duoshuo_thread_key == \"id\"){ %><%= page.id %><% } else { %><%= page.path %><% } %>\" data-url=\"<%= config.url+ config.root + url_for(path) %>\"></div>\n    <!-- 多说评论框 end -->\n</div>\n```\nduoshuo_thread_key配成了page.title，就导致我们找不到多说后台的数据。\n\n所以要找到NexT主题相关多说的配置。\n\n```java\ncd themes/next/layout\ngrep -ri \"thread-key\" ./*\n```\n\n结果：\n\n```java\n./_macro/post.swig:                  <span class=\"post-comments-count ds-thread-count\" data-thread-key=\"{{ post.path }}\" itemprop=\"commentsCount\"></span>\n./_partials/comments.swig:      <div class=\"ds-thread\" data-thread-key=\"{{ page.path }}\"\n./_partials/share/duoshuo_share.swig:<div class=\"ds-share flat\" data-thread-key=\"{{ page.path }}\"\n```\n\n可以看到NexT配置的是page.path。那么我们找到Material主题的thread-key替换下就好了。主要就是两个地方:\n\n - ./layout/_widget/duoshuo.ejs 文章评论内容\n - ./layout/_partial/Paradox-post_entry.ejs 首页显示评论数\n\n都修改下就能正常显示以前的评论了。\n\n# 每日一图\n\nMaterial主题首页有个每日图片，默认是写死的。我们可以改为动态的，使用了bing的每日图片，是一位开发者抓取的然后提供的一个api，地址：[必应美图 API][2]\n\n使用：\n\n```java\n./_partial/daily_pic.ejs\n<div class=\"mdl-card__media mdl-color-text--grey-50\" style=\"background-image:url(https://api.i-meto.com/bing)\">\n```\n\n# backgroud\n\n同上背景图也可以设置成bing的图片。\n\n```java\nconfig_css.ejs\n<% if(theme.background.bing.enable == true){ %>\n\t<style>\n\t\tbody{\n            background-image: url(https://api.i-meto.com/bing?<%= theme.background.bing.parameter %>);\n        }\n\t</style>\n```\n\nconfig配置文件\n\n```java\n# Background Settings\n# bing available parameter:\n#     new | color= | type=\n#         color available value: black, blue, brown, green, multi, orange, pink, purple, red, white, yellow\n#         type available value: A (animal), C (culture), N (nature), S (space), T (travel)\nbackground:\n    purecolor: \"#F5F5F5\"\n    bgimg: blur\n    bing:\n        parameter: color=white\n        enable: true\n```\n\n# 不算子统计\n\n站点统计\n```java\nfooter.ejs\n\t\t<div>\n\t\t<script async src=\"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js\"></script>\n\t\t<div>\n\t\t本站总访问量 <span id=\"busuanzi_value_site_pv\"></span> &nbsp&nbsp&nbsp\n\t\t你是第<span id=\"busuanzi_value_site_uv\"></span>个来到的小伙伴\n\t\t</div>\n\t\t</div>\n```\n\n\n\n\n  [1]: https://github.com/viosey/hexo-theme-material\n  [2]: https://i-meto.com/bing-api/","slug":"hexo-theme-material","published":1,"updated":"2016-11-17T12:29:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif6y0019whs648aistmc"},{"title":"Hello World","date":"2016-01-27T16:00:00.000Z","_content":"Welcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2016-01-28\n---\nWelcome to [Hexo](http://hexo.io/)! This is your very first post. Check [documentation](http://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](http://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](http://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](http://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](http://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](http://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif71001cwhs67u285eo7"},{"title":"前端基础（三）-- JavaScript","date":"2016-05-31T07:34:31.000Z","_content":"\n# JavaScript简介\n\n``JavaScript``可以说是世界上最流行的脚本语言，这也正达到了作者给这种语言取名字的目的，由于当时``Java``很火，所以这哥们儿为了``JavaScript``也能火起来就取了个相似的名字，并希望``JavaScript``也能火起来，所以现在就有了很多程序员的段子，一脸黑线。\n\n``JavaScript``是一种解释型的动态语言，我们知道用``JavaScript``开发web，然而自从有了``Node.js``，前端程序员瞬间变成了全栈，自从``facebook``开源了跨平台开发框架[react-native](https://github.com/facebook/react-native)，前端程序员瞬间能写源生客户端了，最近阿里也开源了更轻量级``Weex``，而且最近RoyLi的创业公司搞出来一个硬件产品``Ruff``，也可以用``JavaScript``开发，前端程序员瞬间成为了真正的全栈，``JavaScript``这是要大一统的节奏啊，想想也是醉了。所以，是时候学一波``JavaScript``了。\n\n虽然之前基本没怎么用过``JavaScript``，但是也学过像``python``这种动态语言，说实话，学完``JavaScript``就有一种感觉这是tm什么玩意儿的感觉，可以说非常怪异，也可以说非常``magic``，用一个词形容感觉特别合适，喜欢NBA的童鞋应该深有感触，妖刀--GinoBili。真的是太妖了。幸好有最新的标准``ECMAScript 6``（以下简称ES6）写起来还能轻松点，不然真的坑太多了。下文会对比着说。\n\n# 数据类型\n\n``JavaScript``中一个有5种基本数据类型：\n\n 1. 数字，包括整数和浮点和NaN(not a number)\n 2. 字符串\n 3. 布尔值\n 4. undefined：未声明或者声明了却未赋值\n 5. null：空值，与undefined的区别在于这是一个已经声明的变量\n\n``JavaScript``，并且任何不属于基本数据类型的东西都是对象。\n数组，``Map``什么的就不写了。\n\n# 变量\n\n说到变量我真是喷出一口老血，太特么容易坑了。\n由于是动态语言，所以不需要指定变量的类型，可以在运行时绑定。声明变量用var(variable)。\n\n## 作用域\n\n为什么说容易坑呢，先看个列子\n```javascript\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    b = 'f**k';\n    console.log(i);\n  };\n}\nconsole.log(b);// f**k\na[6](); // 10\n```\n竟然打印了10。法克。\n用``var``声明的变量的作用域是函数级别的，也就是说在函数内部有效，不同于``java``等静态语言变量声明是块级别的。由于for语句属于函数，所以变量``i``的作用域就是整块代码。\n那为啥会打印出``f**k``？如果不用``var``声明变量，那么默认就是全局变量，也就是说``b``其实是个全局变量..醉了。``JavaScript``中有一种严格模式，在JavaScript代码的第一行写上：``'use strict';``，就会强制通过``var``声明变量，避免发生错误。\n另外一种办法就是，``ES6``新增了``let``命令用来声明变量，该变量的作用域是块级别的，把上面的例子``var``改为``let``最终输出就是变成6。\n\n## 变量提升\n\n又为啥这么说坑呢，看例子\n```javascript\nvar v='Hello World';\n(function(){\n    alert(v);\n    var v='I love you';\n})()\n```\n结果竟然是``undefined``，再法克。\n上面函数的意思是匿名函数立即执行的写法。\n``JavaScript``的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。所以上面代码在``JavaScript``引擎看来是这样的：\n```javascript\nvar v='Hello World';\n(function(){\n    var v;\n    alert(v);\n    v='I love you';\n})()\n```\n那有什么办法解决呢？\n用``let``，用``let``，用``let``。\n\n# 坑爹的this\n\n一般正常的面向对象的语言``this``就是指向对象本身，而``JavaScript``很坑爹，``this``指向视情况而定，用好了是指向对象本身，用不好就指向全局对象(非strict模式)或者指向``undefined``(strict模式)，全局对象是指``web``中是``window``，``Node.js``中是``global``。\n\n - 指向对象本身\n    1. ``obj.fuc()``; \n    2. 由于``JavaScript``中函数也是对象，调用函数对象的``call()``、 ``apply()``，第一个参数传入要绑定的``this``对象。\n - 指向全局对象或者``undefined`` \n    1. 没有绑定对象\n    2. 间接调用方法 ``var a = obj.func(), a();``\n    3. 方法中返回闭包，闭包中使用了``this``\n \n总之，``this``坑很多，能不用最好不用。\n \n# 闭包\n\n闭包(``closure``)是一种包含了外部函数的参数和局部变量的返回函数。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外 隐藏起来。\n\n```javascript\nfunction make_pow(n) {\n    return function (x) {//这是一个闭包\n        return Math.pow(x, n);\n    }\n}\n// 创建两个新函数:\nlet pow2 = make_pow(2);\nlet pow3 = make_pow(3);\npow2(5); // 25\npow3(7); // 343\n```\n\nAndroid开发中常用的回调就是一种闭包，只不过是用对象方法的方式表达，而``JavaScript``中函数也是一种对象，所以无需多余的对象引用。\n类似``Java``的``lambda``表达式，ES6中可以用箭头函数定义匿名函数：\n\n```javascript\n// 两个参数:\n(x, y) => x * x + y * y\n\n// 无参数:\n() => 3.14\n\n// 可变参数:\n(x, y, ...rest) => {\n    var i, sum = x + y;\n    for (i=0; i<rest.length; i++) {\n        sum += rest[i];\n    }\n    return sum;\n}\n```\n \n# 面向对象\n \n``JavaScript``是一种面向对象的语言，刚才已经说了除基本数据类型外，所有的东西都是对象，但是又跟正常的面向对象语言不一样。像``Java``、``C++``这种大多数面向对象语言，类和实例是面向对象的基础，而``JavaScript``不区分类和实例的概念，而是通过原型（``prototype``）来实现面向对象编程。\n\n``JavaScript``对每个创建的对象都会设置一个原型，指向它的原型对象。并且有一个属性查找原则，当我们用``obj.xxx``访问一个对象的属性时，``JavaScript``引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到``Object.prototype``对象，最后，如果还没有找到，就只能返回``undefined``。\n\n## 创建对象\n\n``JavaScript``面向对象基于原型实现，这就导致其用法比较灵活，也足够简单，缺点就是比较难理解，容易出错。下面是几种创建对象的方法。\n\n### 直接用``{ ... }``创建一个对象\n``Student``就是一个对象\n```javascript\nlet Student = {\nname: 'xiaoming',\nage: 19,\nrun: function () {\n    console.log(this.name + ' is running...');\n    }\n}\n```\n原型链是这样的：\n```\nStudent ----> Object.prototype ----> null\n```\n``JavaScript``的原型链和``Java``的``Class``区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。\n\n### ``Object.create()``\n传入一个原型对象作为参数，并创建一个基于该原型的新对象，但是新对象什么属性都没有\n\n```javascript\nfunction createStudent(name) {\n    // 基于Student原型创建一个新对象:\n    var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n```\n\n### 构造函数\n``JavaScript``的构造函数就是普通函数\n\n```javascript\nfunction Student(name) {\n    this.name = name;\n    this.hello = function () {\n        console.log('Hello, ' + this.name + '!');\n    }\n}\n\nlet xiaoming = new Student('小明');\nxiaoming.name; // '小明'\nxiaoming.hello(); // Hello, 小明!\nlet xiaohong = new Student('小红');\nxiaohong.name;//'小红'\nxiaohong.hello();//Hello,小红!\n```\n原型链是这样的\n```\nxiaoming ↘\nxiaohong -→ Student.prototype ----> Object.prototype ----> null\nxiaojun  ↗\n```\n也就是说，``xiaoming``的原型指向函数``Student``的原型。验证一下\n```javascript\nxiaoming.constructor === Student.prototype.constructor; // true\nStudent.prototype.constructor === Student; // true\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\nxiaoming instanceof Student; // true\nxiaoming.hello === xiaohong.hello; // false\n```\n\n### 封装构造函数，以对象作为初始化参数\n\n```javacsript\nfunction Student(props) {\n    this.name = props.name || 'noname'; // 默认值为'noname'\n    this.grade = props.grade || 1; // 默认值为1\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n\nfunction createStudent(props) {\n    return new Student(props || {})\n}\n\nlet xiaoming = createStudent({\n    name: '小明'\n});\nxiaoming.name; //小明\nxiaoming.grade; // 1\n```\n这个``createStudent()``函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以传一个对象。\n\n## 原型继承\n\n一张图看懂上面的关系\n![原型继承](http://7xs23g.com1.z0.glb.clouddn.com/prototype.png)\n``xiaoming``的原型指向``Student``的``prototype``对象，这个原型对象有个``constuctor``属性，指向``Student()``函数本身。\n\n上面可以看到``xiaoming.hello() !== xiaohong.hello()``，各自的``hello()``函数实际上是两个不同的函数，如果我们要创建共享的``hello``函数，根据属性查找原则，只需要把函数定义在他们共同所指的原型对象上来就可以了。\n```javascript\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n```\n\n那么假如我们想从``Student``扩展出``PrimaryStudent``，使得新的基于``PrimaryStudent``创建的对象不但能调用``PrimaryStudent.prototype``定义的方法，也可以调用``Student.prototype``定义的方法。也就是说原型链是这样的\n```\nnew PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null\n```\n那要怎么做呢？\n我们可以定义一个空函数``F``，用于桥接原型链，并将其封装起来，隐藏``F``的定义，代码如下\n```javascript\nfunction inherits(Child, Parent) {\n    let F = function () {};//空函数F\n    // 把F的原型指向Student.prototype:\n    F.prototype = Parent.prototype;\n    // 把Child的原型指向一个新的F对象，该F对象的原型正好指向Parent.prototype\n    Child.prototype = new F();\n    // 把Child的原型的构造函数修复为Child\n    Child.prototype.constructor = Child;\n}\n```\n使用\n```javascript\nfunction PrimaryStudent(props) {\n    Student.call(this, props);//调用Student的构造方法，并绑定this\n    this.grade = props.grade || 1;\n}\n// 实现原型继承链:\ninherits(PrimaryStudent, Student);\n\n// 继续在PrimaryStudent原型（就是new F()对象）上定义方法： \nPrimaryStudent.prototype.getGrade = function () {\n    return this.grade;\n};\n```\n原型链图如下\n![继承](http://7xs23g.com1.z0.glb.clouddn.com/prototype_extends.png)\n\n## 类继承\n\n说实话，你让我写原型继承，我的内心其实是拒绝的，这特么都是些什么啊乱七八糟的，继承要写这么多，而且很容易出错有没有！那么有没有类似``Java``这种类继承的方式呢，答案是当然有，ES6早就为我们准备好了。\nES6中增加了新的关键字``class``用于定义类。``extends``用于实现类的继承。\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n    // 相当于Student.prototype.hello = function () {...}\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n创建对象的方式跟原型继承一样，``new``就可以了。\n继承：\n```javascript\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n是不是炒鸡简单，跟``Java``的类继承基本一模一样。这样写跟原型继承的写法在``JavaScript``引擎看来完全一样。\n\n# 总结\n\n这篇基本描述了``JavaScript``的一些注意容易踩坑的点和与``Java``面向对象实现不同的点。像一些基础的集合、字符串等都没写。当然还有一些前端用的比较多的比如``DOM``、``AJAX``、``jQuery``就不写了，大概浏览下就好了。\n另外一点要说的就是，对于我们这些非前端工程师来说，ES6中定义了的一律用ES6的，而且像``Node.js``这种脱离了浏览器引擎的框架已经完全支持ES6的写法。\n学完``JavaScript``就得学``Node.js``啊。下一篇带来``Node.js``基础和实战。\n\n# 参考\n\n《JavaScript面向对象编程指南(第二版)》\n[阮一峰的网络日志][1]\n[廖雪峰 JavaScript教程][2]\n[JavaScript秘密花园][3]\n\n\n  [1]: http://www.ruanyifeng.com/blog/javascript/\n  [2]: http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\n  [3]: http://bonsaiden.github.io/JavaScript-Garden/zh/","source":"_posts/JavaScript.md","raw":"---\ntitle: 前端基础（三）-- JavaScript\ndate: 2016-05-31 15:34:31\ntags: [前端, JavaScript]\n---\n\n# JavaScript简介\n\n``JavaScript``可以说是世界上最流行的脚本语言，这也正达到了作者给这种语言取名字的目的，由于当时``Java``很火，所以这哥们儿为了``JavaScript``也能火起来就取了个相似的名字，并希望``JavaScript``也能火起来，所以现在就有了很多程序员的段子，一脸黑线。\n\n``JavaScript``是一种解释型的动态语言，我们知道用``JavaScript``开发web，然而自从有了``Node.js``，前端程序员瞬间变成了全栈，自从``facebook``开源了跨平台开发框架[react-native](https://github.com/facebook/react-native)，前端程序员瞬间能写源生客户端了，最近阿里也开源了更轻量级``Weex``，而且最近RoyLi的创业公司搞出来一个硬件产品``Ruff``，也可以用``JavaScript``开发，前端程序员瞬间成为了真正的全栈，``JavaScript``这是要大一统的节奏啊，想想也是醉了。所以，是时候学一波``JavaScript``了。\n\n虽然之前基本没怎么用过``JavaScript``，但是也学过像``python``这种动态语言，说实话，学完``JavaScript``就有一种感觉这是tm什么玩意儿的感觉，可以说非常怪异，也可以说非常``magic``，用一个词形容感觉特别合适，喜欢NBA的童鞋应该深有感触，妖刀--GinoBili。真的是太妖了。幸好有最新的标准``ECMAScript 6``（以下简称ES6）写起来还能轻松点，不然真的坑太多了。下文会对比着说。\n\n# 数据类型\n\n``JavaScript``中一个有5种基本数据类型：\n\n 1. 数字，包括整数和浮点和NaN(not a number)\n 2. 字符串\n 3. 布尔值\n 4. undefined：未声明或者声明了却未赋值\n 5. null：空值，与undefined的区别在于这是一个已经声明的变量\n\n``JavaScript``，并且任何不属于基本数据类型的东西都是对象。\n数组，``Map``什么的就不写了。\n\n# 变量\n\n说到变量我真是喷出一口老血，太特么容易坑了。\n由于是动态语言，所以不需要指定变量的类型，可以在运行时绑定。声明变量用var(variable)。\n\n## 作用域\n\n为什么说容易坑呢，先看个列子\n```javascript\nvar a = [];\nfor (var i = 0; i < 10; i++) {\n  a[i] = function () {\n    b = 'f**k';\n    console.log(i);\n  };\n}\nconsole.log(b);// f**k\na[6](); // 10\n```\n竟然打印了10。法克。\n用``var``声明的变量的作用域是函数级别的，也就是说在函数内部有效，不同于``java``等静态语言变量声明是块级别的。由于for语句属于函数，所以变量``i``的作用域就是整块代码。\n那为啥会打印出``f**k``？如果不用``var``声明变量，那么默认就是全局变量，也就是说``b``其实是个全局变量..醉了。``JavaScript``中有一种严格模式，在JavaScript代码的第一行写上：``'use strict';``，就会强制通过``var``声明变量，避免发生错误。\n另外一种办法就是，``ES6``新增了``let``命令用来声明变量，该变量的作用域是块级别的，把上面的例子``var``改为``let``最终输出就是变成6。\n\n## 变量提升\n\n又为啥这么说坑呢，看例子\n```javascript\nvar v='Hello World';\n(function(){\n    alert(v);\n    var v='I love you';\n})()\n```\n结果竟然是``undefined``，再法克。\n上面函数的意思是匿名函数立即执行的写法。\n``JavaScript``的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。所以上面代码在``JavaScript``引擎看来是这样的：\n```javascript\nvar v='Hello World';\n(function(){\n    var v;\n    alert(v);\n    v='I love you';\n})()\n```\n那有什么办法解决呢？\n用``let``，用``let``，用``let``。\n\n# 坑爹的this\n\n一般正常的面向对象的语言``this``就是指向对象本身，而``JavaScript``很坑爹，``this``指向视情况而定，用好了是指向对象本身，用不好就指向全局对象(非strict模式)或者指向``undefined``(strict模式)，全局对象是指``web``中是``window``，``Node.js``中是``global``。\n\n - 指向对象本身\n    1. ``obj.fuc()``; \n    2. 由于``JavaScript``中函数也是对象，调用函数对象的``call()``、 ``apply()``，第一个参数传入要绑定的``this``对象。\n - 指向全局对象或者``undefined`` \n    1. 没有绑定对象\n    2. 间接调用方法 ``var a = obj.func(), a();``\n    3. 方法中返回闭包，闭包中使用了``this``\n \n总之，``this``坑很多，能不用最好不用。\n \n# 闭包\n\n闭包(``closure``)是一种包含了外部函数的参数和局部变量的返回函数。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外 隐藏起来。\n\n```javascript\nfunction make_pow(n) {\n    return function (x) {//这是一个闭包\n        return Math.pow(x, n);\n    }\n}\n// 创建两个新函数:\nlet pow2 = make_pow(2);\nlet pow3 = make_pow(3);\npow2(5); // 25\npow3(7); // 343\n```\n\nAndroid开发中常用的回调就是一种闭包，只不过是用对象方法的方式表达，而``JavaScript``中函数也是一种对象，所以无需多余的对象引用。\n类似``Java``的``lambda``表达式，ES6中可以用箭头函数定义匿名函数：\n\n```javascript\n// 两个参数:\n(x, y) => x * x + y * y\n\n// 无参数:\n() => 3.14\n\n// 可变参数:\n(x, y, ...rest) => {\n    var i, sum = x + y;\n    for (i=0; i<rest.length; i++) {\n        sum += rest[i];\n    }\n    return sum;\n}\n```\n \n# 面向对象\n \n``JavaScript``是一种面向对象的语言，刚才已经说了除基本数据类型外，所有的东西都是对象，但是又跟正常的面向对象语言不一样。像``Java``、``C++``这种大多数面向对象语言，类和实例是面向对象的基础，而``JavaScript``不区分类和实例的概念，而是通过原型（``prototype``）来实现面向对象编程。\n\n``JavaScript``对每个创建的对象都会设置一个原型，指向它的原型对象。并且有一个属性查找原则，当我们用``obj.xxx``访问一个对象的属性时，``JavaScript``引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到``Object.prototype``对象，最后，如果还没有找到，就只能返回``undefined``。\n\n## 创建对象\n\n``JavaScript``面向对象基于原型实现，这就导致其用法比较灵活，也足够简单，缺点就是比较难理解，容易出错。下面是几种创建对象的方法。\n\n### 直接用``{ ... }``创建一个对象\n``Student``就是一个对象\n```javascript\nlet Student = {\nname: 'xiaoming',\nage: 19,\nrun: function () {\n    console.log(this.name + ' is running...');\n    }\n}\n```\n原型链是这样的：\n```\nStudent ----> Object.prototype ----> null\n```\n``JavaScript``的原型链和``Java``的``Class``区别就在，它没有“Class”的概念，所有对象都是实例，所谓继承关系不过是把一个对象的原型指向另一个对象而已。\n\n### ``Object.create()``\n传入一个原型对象作为参数，并创建一个基于该原型的新对象，但是新对象什么属性都没有\n\n```javascript\nfunction createStudent(name) {\n    // 基于Student原型创建一个新对象:\n    var s = Object.create(Student);\n    // 初始化新对象:\n    s.name = name;\n    return s;\n}\n\nvar xiaoming = createStudent('小明');\nxiaoming.run(); // 小明 is running...\nxiaoming.__proto__ === Student; // true\n```\n\n### 构造函数\n``JavaScript``的构造函数就是普通函数\n\n```javascript\nfunction Student(name) {\n    this.name = name;\n    this.hello = function () {\n        console.log('Hello, ' + this.name + '!');\n    }\n}\n\nlet xiaoming = new Student('小明');\nxiaoming.name; // '小明'\nxiaoming.hello(); // Hello, 小明!\nlet xiaohong = new Student('小红');\nxiaohong.name;//'小红'\nxiaohong.hello();//Hello,小红!\n```\n原型链是这样的\n```\nxiaoming ↘\nxiaohong -→ Student.prototype ----> Object.prototype ----> null\nxiaojun  ↗\n```\n也就是说，``xiaoming``的原型指向函数``Student``的原型。验证一下\n```javascript\nxiaoming.constructor === Student.prototype.constructor; // true\nStudent.prototype.constructor === Student; // true\nObject.getPrototypeOf(xiaoming) === Student.prototype; // true\nxiaoming instanceof Student; // true\nxiaoming.hello === xiaohong.hello; // false\n```\n\n### 封装构造函数，以对象作为初始化参数\n\n```javacsript\nfunction Student(props) {\n    this.name = props.name || 'noname'; // 默认值为'noname'\n    this.grade = props.grade || 1; // 默认值为1\n}\n\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n\nfunction createStudent(props) {\n    return new Student(props || {})\n}\n\nlet xiaoming = createStudent({\n    name: '小明'\n});\nxiaoming.name; //小明\nxiaoming.grade; // 1\n```\n这个``createStudent()``函数有几个巨大的优点：一是不需要new来调用，二是参数非常灵活，可以不传，也可以传一个对象。\n\n## 原型继承\n\n一张图看懂上面的关系\n![原型继承](http://7xs23g.com1.z0.glb.clouddn.com/prototype.png)\n``xiaoming``的原型指向``Student``的``prototype``对象，这个原型对象有个``constuctor``属性，指向``Student()``函数本身。\n\n上面可以看到``xiaoming.hello() !== xiaohong.hello()``，各自的``hello()``函数实际上是两个不同的函数，如果我们要创建共享的``hello``函数，根据属性查找原则，只需要把函数定义在他们共同所指的原型对象上来就可以了。\n```javascript\nStudent.prototype.hello = function () {\n    alert('Hello, ' + this.name + '!');\n};\n```\n\n那么假如我们想从``Student``扩展出``PrimaryStudent``，使得新的基于``PrimaryStudent``创建的对象不但能调用``PrimaryStudent.prototype``定义的方法，也可以调用``Student.prototype``定义的方法。也就是说原型链是这样的\n```\nnew PrimaryStudent() ----> PrimaryStudent.prototype ----> Student.prototype ----> Object.prototype ----> null\n```\n那要怎么做呢？\n我们可以定义一个空函数``F``，用于桥接原型链，并将其封装起来，隐藏``F``的定义，代码如下\n```javascript\nfunction inherits(Child, Parent) {\n    let F = function () {};//空函数F\n    // 把F的原型指向Student.prototype:\n    F.prototype = Parent.prototype;\n    // 把Child的原型指向一个新的F对象，该F对象的原型正好指向Parent.prototype\n    Child.prototype = new F();\n    // 把Child的原型的构造函数修复为Child\n    Child.prototype.constructor = Child;\n}\n```\n使用\n```javascript\nfunction PrimaryStudent(props) {\n    Student.call(this, props);//调用Student的构造方法，并绑定this\n    this.grade = props.grade || 1;\n}\n// 实现原型继承链:\ninherits(PrimaryStudent, Student);\n\n// 继续在PrimaryStudent原型（就是new F()对象）上定义方法： \nPrimaryStudent.prototype.getGrade = function () {\n    return this.grade;\n};\n```\n原型链图如下\n![继承](http://7xs23g.com1.z0.glb.clouddn.com/prototype_extends.png)\n\n## 类继承\n\n说实话，你让我写原型继承，我的内心其实是拒绝的，这特么都是些什么啊乱七八糟的，继承要写这么多，而且很容易出错有没有！那么有没有类似``Java``这种类继承的方式呢，答案是当然有，ES6早就为我们准备好了。\nES6中增加了新的关键字``class``用于定义类。``extends``用于实现类的继承。\n```javascript\nclass Student {\n    constructor(name) {\n        this.name = name;\n    }\n    // 相当于Student.prototype.hello = function () {...}\n    hello() {\n        alert('Hello, ' + this.name + '!');\n    }\n}\n```\n创建对象的方式跟原型继承一样，``new``就可以了。\n继承：\n```javascript\nclass PrimaryStudent extends Student {\n    constructor(name, grade) {\n        super(name); // 记得用super调用父类的构造方法!\n        this.grade = grade;\n    }\n\n    myGrade() {\n        alert('I am at grade ' + this.grade);\n    }\n}\n```\n是不是炒鸡简单，跟``Java``的类继承基本一模一样。这样写跟原型继承的写法在``JavaScript``引擎看来完全一样。\n\n# 总结\n\n这篇基本描述了``JavaScript``的一些注意容易踩坑的点和与``Java``面向对象实现不同的点。像一些基础的集合、字符串等都没写。当然还有一些前端用的比较多的比如``DOM``、``AJAX``、``jQuery``就不写了，大概浏览下就好了。\n另外一点要说的就是，对于我们这些非前端工程师来说，ES6中定义了的一律用ES6的，而且像``Node.js``这种脱离了浏览器引擎的框架已经完全支持ES6的写法。\n学完``JavaScript``就得学``Node.js``啊。下一篇带来``Node.js``基础和实战。\n\n# 参考\n\n《JavaScript面向对象编程指南(第二版)》\n[阮一峰的网络日志][1]\n[廖雪峰 JavaScript教程][2]\n[JavaScript秘密花园][3]\n\n\n  [1]: http://www.ruanyifeng.com/blog/javascript/\n  [2]: http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\n  [3]: http://bonsaiden.github.io/JavaScript-Garden/zh/","slug":"JavaScript","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif74001dwhs6auoo8d5a"},{"title":"Hexo主题同步","date":"2016-06-06T10:48:22.000Z","_content":"\n# 问题\n\n由于升级``Node.js``导致要重新安装``Hexo``，安装完新版的``Hexo``发现有些东西不能用，搞来搞去把本地仓库搞乱了，就想着把本地的仓库删掉吧，在从远程``clone``一份下来。\n博客用的是[Next主题][1]，结果之前的主题配置``themes/next/``目录根本就没有上传到远程分支，导致主题所有的定制化修改全部丢失。此问题已经提交到[Next主题][3]的[Issues][2]中。\n\n# 原因\n\n先看下[Next主题][4]的使用方法\n```\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n这样配置完其实``thems/next/``就是一个包含``.git/``的子项目仓库。所以在``push``主项目的时候不会上传子项目，子项目的文件夹是灰的，并且里面是空的。如图\n![此处输入图片的描述][5]\n\n所以从远程仓库拉取的项目中是没有[Next主题][6]的。\n\n# 解决\n\n解决方法在[Issues][7]里也说了，用``fork + subtree``。\n\n首先要``fork`` ``Next``，然后拉取到本地做修改，修改好后``push``到远程仓库。\n然后用``git subtree``把``themes/next/``当做子项目来统一管理。``subtree``的用法可以看[使用GIT SUBTREE集成项目到子目录][8]。\n\n具体步骤：\n\n 1. 删除``themes/next/``并``push``到远程\n    \n    ```java\n      rm -rf themes/next\n      gst\n      ga .\n      git add --all\n      gcmsg \"delete next\"\n      ggpush\n    ```\n 2. 绑定子项目\n    \n    ```java\n        git remote add -f next git@github.com:w4lle/hexo-theme-next.git\n        git subtree add --prefix=themes/next next master --squash\n    ```\n 3. 更新子项目\n    \n    ```java\n        git fetch next master\n        git subtree pull --prefix=themes/next next master --squash\n    ```\n 4. 从子目录push到远程仓库\n    \n    ```java\n        git subtree push --prefix=themes/next next master\n    ```\n\n现在再去远程仓库看``themes/next/``就有内容了，并且跟子项目的远程仓库可以保持更新，在主项目中修改也可以``push``到子项目的远程。再也不用担心主题配置丢失了。\n\n# 参考\n\n* [使用GIT SUBTREE集成项目到子目录][8]\n* [hexo用subtree同步主题](http://tidus.xyz/2016/01/29/hexo%E7%94%A8subtree%E5%90%8C%E6%AD%A5%E4%B8%BB%E9%A2%98/)\n\n\n  [1]: https://github.com/iissnan/hexo-theme-next\n  [2]: https://github.com/iissnan/hexo-theme-next/issues/932\n  [3]: https://github.com/iissnan/hexo-theme-next\n  [4]: https://github.com/iissnan/hexo-theme-next\n  [5]: https://cloud.githubusercontent.com/assets/7310246/15810485/b86f642a-2bd1-11e6-9bea-c8c603e9ba35.png\n  [6]: https://github.com/iissnan/hexo-theme-next\n  [7]: https://github.com/iissnan/hexo-theme-next/issues/932\n  [8]: http://aoxuis.me/post/2013-08-06-git-subtree","source":"_posts/Hexo-themes.md","raw":"---\ntitle: Hexo主题同步\ndate: 2016-06-06 18:48:22\ntags: [Hexo]\n---\n\n# 问题\n\n由于升级``Node.js``导致要重新安装``Hexo``，安装完新版的``Hexo``发现有些东西不能用，搞来搞去把本地仓库搞乱了，就想着把本地的仓库删掉吧，在从远程``clone``一份下来。\n博客用的是[Next主题][1]，结果之前的主题配置``themes/next/``目录根本就没有上传到远程分支，导致主题所有的定制化修改全部丢失。此问题已经提交到[Next主题][3]的[Issues][2]中。\n\n# 原因\n\n先看下[Next主题][4]的使用方法\n```\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n这样配置完其实``thems/next/``就是一个包含``.git/``的子项目仓库。所以在``push``主项目的时候不会上传子项目，子项目的文件夹是灰的，并且里面是空的。如图\n![此处输入图片的描述][5]\n\n所以从远程仓库拉取的项目中是没有[Next主题][6]的。\n\n# 解决\n\n解决方法在[Issues][7]里也说了，用``fork + subtree``。\n\n首先要``fork`` ``Next``，然后拉取到本地做修改，修改好后``push``到远程仓库。\n然后用``git subtree``把``themes/next/``当做子项目来统一管理。``subtree``的用法可以看[使用GIT SUBTREE集成项目到子目录][8]。\n\n具体步骤：\n\n 1. 删除``themes/next/``并``push``到远程\n    \n    ```java\n      rm -rf themes/next\n      gst\n      ga .\n      git add --all\n      gcmsg \"delete next\"\n      ggpush\n    ```\n 2. 绑定子项目\n    \n    ```java\n        git remote add -f next git@github.com:w4lle/hexo-theme-next.git\n        git subtree add --prefix=themes/next next master --squash\n    ```\n 3. 更新子项目\n    \n    ```java\n        git fetch next master\n        git subtree pull --prefix=themes/next next master --squash\n    ```\n 4. 从子目录push到远程仓库\n    \n    ```java\n        git subtree push --prefix=themes/next next master\n    ```\n\n现在再去远程仓库看``themes/next/``就有内容了，并且跟子项目的远程仓库可以保持更新，在主项目中修改也可以``push``到子项目的远程。再也不用担心主题配置丢失了。\n\n# 参考\n\n* [使用GIT SUBTREE集成项目到子目录][8]\n* [hexo用subtree同步主题](http://tidus.xyz/2016/01/29/hexo%E7%94%A8subtree%E5%90%8C%E6%AD%A5%E4%B8%BB%E9%A2%98/)\n\n\n  [1]: https://github.com/iissnan/hexo-theme-next\n  [2]: https://github.com/iissnan/hexo-theme-next/issues/932\n  [3]: https://github.com/iissnan/hexo-theme-next\n  [4]: https://github.com/iissnan/hexo-theme-next\n  [5]: https://cloud.githubusercontent.com/assets/7310246/15810485/b86f642a-2bd1-11e6-9bea-c8c603e9ba35.png\n  [6]: https://github.com/iissnan/hexo-theme-next\n  [7]: https://github.com/iissnan/hexo-theme-next/issues/932\n  [8]: http://aoxuis.me/post/2013-08-06-git-subtree","slug":"Hexo-themes","published":1,"updated":"2016-06-06T12:41:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif77001hwhs6twgivlwd"},{"title":"前端基础(二)--快速布局神器Flexbox布局","date":"2016-05-08T12:38:35.000Z","_content":"\n# 什么是Flexbox\n\n在[上一篇文章](http://w4lle.github.io/2016/04/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%B8%80-CSS%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80/)中，我们知道CSS布局传统的布局方式是基于盒模型，主要依赖 display属性 + position属性 + float属性。这种盒模型对于一些复杂的布局解决起来比较麻烦，所以一种新的布局方式应运而生。\n2009年，W3C提出了一种新的方案--Flexbox布局(弹性布局)，可以简便、完整、响应式地实现各种页面布局。Flex布局模型不同于块和内联模型布局，块和内联模型的布局计算依赖于块和内联的流方向。\n并且React Native也是使用的Flex布局，对于客户端开发来说学习Flex大有裨益。\n\n# 基本概念和属性\n\n``Flexbox``布局依赖于``flex directions``，简单的说：``Flexbox``是布局模块，而不是一个简单的属性。采用Flex布局的元素，称为``Flex容器``（flex container），它的所有``子元素``（flex item）自动成为容器成员。\n``Flexbox``布局很像``Android``开发中的``LinearLayout``布局，但是要比``LinearLayout``要强大。跟``LinearLayout``类似，``Flexbox``也存在两个方向的布局--主轴（main axis）和副轴（cross axis），可以简单的理解为``LinearLayout``的水平布局和垂直布局。主轴的开始位置（与边框的交叉点）叫做``main start``，结束位置叫做``main end``；交叉轴的开始位置叫做``cross start``，结束位置叫做``cross end``。项目默认沿主轴排列。单个项目占据的主轴空间叫做``main size``，占据的交叉轴空间叫做``cross size``。\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n# 属性\n\n属性分为``flex container``属性和``flex item``属性。对应父容器和子元素。\n\n## flex container属性\n\n以下几个属于``flex container``属性\n\n * flex container 属性\n * order\n * flex-wrap\n * flex-flow\n * justify-content\n * align-content\n * align-items\n\n### flex-direction属性\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。类似``LinearLayout``的``vertical``or``Horizontal``。\n\n```css\nflex-direction: row | row-reverse | column | column-reverse\n```\n\n有四个值可以选择：\n\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n\n### order属性\n\n默认情况下子元素的排列方式按照文档流的顺序依次排序，而``order``属性可以控制排列的顺序，负值在前，正值灾后，按照从小到大的顺序依次排列。我们说之所以``flex box``相对``LinearLayout``强就是因为一些属性比较给力，``order``就是其中之一。\n\n![image](https://sfault-image.b0.upaiyun.com/318/287/3182877863-56fde345ba339_articlex)\n\n### flex-wrap属性\n\n默认情况下``Flex``跟``LinearLayout``一样，都是不带换行排列的，但是``flex-wrap``属性可以支持换行排列。这个也比``LinearLayout``吊啊有三个值：\n\n```\nflex-wrap: nowrap | wrap | wrap-reverse;\n```\n\n![image](https://sfault-image.b0.upaiyun.com/159/596/15959628-56fde3489ff74_articlex)\n\n* nowrap ：不换行\n* wrap：按正常方向换行\n* wrap-reverse：按反方向换行\n\n### flex-flow属性\n\n``flex-flow``属性是``flex-direction``属性和``flex-wrap``属性的简写形式，默认值为``row nowrap``。\n\n```\nflex-flow: <flex-direction> || <flex-wrap>;\n```\n\n### justify-content属性\n\n``justify-content``属性定义了项目在主轴上的对齐方式。\n\n```\njustify-content: flex-start | flex-end | center | space-between | space-around;\n```\n\n* flex-start（默认值）：左对齐\n* flex-end：右对齐\n* center： 居中\n* space-between：两端对齐，项目之间的间隔都相等。\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![image](https://sfault-image.b0.upaiyun.com/421/275/4212753174-56fde6083157c_articlex)\n\n### align-items属性\n``align-items``属性定义项目在副轴轴上如何对齐。\n\n```\nalign-items: flex-start | flex-end | center | baseline | stretch;\n```\n\n* flex-start：交叉轴的起点对齐。\n* flex-end：交叉轴的终点对齐。\n* center：交叉轴的中点对齐。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![image](http://img.blog.csdn.net/20150616152600533)\n\n### align-content属性\n\n``align-content``属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n```\n\n* flex-start：与交叉轴的起点对齐。\n* flex-end：与交叉轴的终点对齐。\n* center：与交叉轴的中点对齐。\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n* stretch（默认值）：轴线占满整个交叉轴。\n\n## 子元素属性\n\n以下几个属性设置在子元素上。\n\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n### flex-grow属性\n\n``flex-grow``属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。一张图看懂。跟``LinearLayout``中的``weight``属性一样。\n\n```\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n![image](https://sfault-image.b0.upaiyun.com/271/846/2718468848-56fde60740335_articlex)\n\n如果所有项目的``flex-grow``属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的``flex-grow``属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink属性\n\n``flex-shrink``属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n如果所有项目的``flex-shrink``属性都为1，当空间不足时，都将等比例缩小。如果一个项目的``flex-shrink``属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n\n### flex-basis属性\n\n``flex-basis``属性定义了在分配多余空间之前，子元素占据的``main size``主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为``auto``，即子元素的本来大小。\n\n```\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n### flex属性\n\n``flex``属性是``flex-grow``, ``flex-shrink`` 和 ``flex-basis``的简写，默认值为0 1 auto。后两个属性可选。\n\n```\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n### align-self属性\n\n``align-self``属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖``align-items``属性。默认值为``auto``，表示继承父元素的``align-items``属性，如果没有父元素，则等同于``stretch``。\n\n```\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可能取6个值，除了``auto``，其他都与``align-items``属性完全一致。\n\n\n# 实例\n\n属性基本都讲完了，下面进入实战。\n百度前端学院的其中一个任务：\n\n* 学习如何flex进行布局，学习如何根据屏幕宽度调整布局策略。\n* 屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。\n\n[效果图](http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png)\n\n分析：\n1. 屏幕宽度小于640px时，调整主轴对齐方式justify-content属性为space-between，在副轴对齐方式align-items为center\n2. 屏幕宽度大于640px，要有换行，并且动态调整``order``属性，调整第四个子元素的排列位置。并且调整align-items为flex-start;\n\n[效果图](http://w4lle.github.io/ife_baidu/task10/index.html)和[代码](https://github.com/w4lle/ife_baidu/tree/master/task10)\n\n# Android开发者的福音\n\n\n大概在一个月前，Google开源了[flexbox-layout](https://github.com/google/flexbox-layout)项目，用以支持``Flexbox``布局在Android开发中使用，支持源生的``Flexbox``属性。\n官方例子，在xml布局文件中使用\n\n```xml\n<com.google.android.flexbox.FlexboxLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:flexWrap=\"wrap\"\n    app:alignItems=\"stretch\"\n    app:alignContent=\"stretch\" >\n\n    <TextView\n        android:id=\"@+id/textview1\"\n        android:layout_width=\"120dp\"\n        android:layout_height=\"80dp\"\n        app:layout_flexBasisPercent=\"50%\"\n        />\n\n    <TextView\n        android:id=\"@+id/textview2\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"80dp\"\n        app:layout_alignSelf=\"center\"\n        />\n\n    <TextView\n        android:id=\"@+id/textview3\"\n        android:layout_width=\"160dp\"\n        android:layout_height=\"80dp\"\n        app:layout_alignSelf=\"flex_end\"\n        />\n</com.google.android.flexbox.FlexboxLayout>\n```\n\n在java代码中使用\n\n```java\nFlexboxLayout flexboxLayout = (FlexboxLayout) findViewById(R.id.flexbox_layout);\nflexboxLayout.setFlexDirection(FlexboxLayout.FLEX_DIRECTION_COLUMN);\n\nView view = flexboxLayout.getChildAt(0);\nFlexboxLayout.LayoutParams lp = (FlexboxLayout.LayoutParams) view.getLayoutParams();\nlp.order = -1;\nlp.flexGrow = 2;\nview.setLayoutParams(lp);\n```\n\n可以看到使用非常方便，对于熟悉``Flexbox``的开发者来说对于``Android``app也可以快速上手。\nGoogle开发这个开源库我猜想可能一方面看到``React Native``使用``Flexbox``对于前端工程师开发Android app布局的无缝切换；另一方面，``Flexbox``也确实要比Android开发中经常使用的``LinearLayout``和``RelativeLayout``要方便很多，灵活性较两者有大幅提高，特别在动态变化这一块。\n\n# 总结\n\n``Flexbox``布局方式相比传统的盒模型布局方式要快速很多，对于一些复杂的页面也可以很快速的开发。而且由于Google和Facebook的支持和使用，相信会有越来越多的开发者使用这种布局方式进行开发，在跨平台开发框架越来越成熟的现在，``Flexbox``赶紧学起来！\n","source":"_posts/Flexbox.md","raw":"---\ntitle: 前端基础(二)--快速布局神器Flexbox布局\ndate: 2016-05-08 20:38:35\ntags: [前端, Flexbox]\n---\n\n# 什么是Flexbox\n\n在[上一篇文章](http://w4lle.github.io/2016/04/17/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-%E4%B8%80-CSS%E5%B8%83%E5%B1%80%E5%9F%BA%E7%A1%80/)中，我们知道CSS布局传统的布局方式是基于盒模型，主要依赖 display属性 + position属性 + float属性。这种盒模型对于一些复杂的布局解决起来比较麻烦，所以一种新的布局方式应运而生。\n2009年，W3C提出了一种新的方案--Flexbox布局(弹性布局)，可以简便、完整、响应式地实现各种页面布局。Flex布局模型不同于块和内联模型布局，块和内联模型的布局计算依赖于块和内联的流方向。\n并且React Native也是使用的Flex布局，对于客户端开发来说学习Flex大有裨益。\n\n# 基本概念和属性\n\n``Flexbox``布局依赖于``flex directions``，简单的说：``Flexbox``是布局模块，而不是一个简单的属性。采用Flex布局的元素，称为``Flex容器``（flex container），它的所有``子元素``（flex item）自动成为容器成员。\n``Flexbox``布局很像``Android``开发中的``LinearLayout``布局，但是要比``LinearLayout``要强大。跟``LinearLayout``类似，``Flexbox``也存在两个方向的布局--主轴（main axis）和副轴（cross axis），可以简单的理解为``LinearLayout``的水平布局和垂直布局。主轴的开始位置（与边框的交叉点）叫做``main start``，结束位置叫做``main end``；交叉轴的开始位置叫做``cross start``，结束位置叫做``cross end``。项目默认沿主轴排列。单个项目占据的主轴空间叫做``main size``，占据的交叉轴空间叫做``cross size``。\n![image](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n# 属性\n\n属性分为``flex container``属性和``flex item``属性。对应父容器和子元素。\n\n## flex container属性\n\n以下几个属于``flex container``属性\n\n * flex container 属性\n * order\n * flex-wrap\n * flex-flow\n * justify-content\n * align-content\n * align-items\n\n### flex-direction属性\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。类似``LinearLayout``的``vertical``or``Horizontal``。\n\n```css\nflex-direction: row | row-reverse | column | column-reverse\n```\n\n有四个值可以选择：\n\n* row（默认值）：主轴为水平方向，起点在左端。\n* row-reverse：主轴为水平方向，起点在右端。\n* column：主轴为垂直方向，起点在上沿。\n* column-reverse：主轴为垂直方向，起点在下沿。\n\n### order属性\n\n默认情况下子元素的排列方式按照文档流的顺序依次排序，而``order``属性可以控制排列的顺序，负值在前，正值灾后，按照从小到大的顺序依次排列。我们说之所以``flex box``相对``LinearLayout``强就是因为一些属性比较给力，``order``就是其中之一。\n\n![image](https://sfault-image.b0.upaiyun.com/318/287/3182877863-56fde345ba339_articlex)\n\n### flex-wrap属性\n\n默认情况下``Flex``跟``LinearLayout``一样，都是不带换行排列的，但是``flex-wrap``属性可以支持换行排列。这个也比``LinearLayout``吊啊有三个值：\n\n```\nflex-wrap: nowrap | wrap | wrap-reverse;\n```\n\n![image](https://sfault-image.b0.upaiyun.com/159/596/15959628-56fde3489ff74_articlex)\n\n* nowrap ：不换行\n* wrap：按正常方向换行\n* wrap-reverse：按反方向换行\n\n### flex-flow属性\n\n``flex-flow``属性是``flex-direction``属性和``flex-wrap``属性的简写形式，默认值为``row nowrap``。\n\n```\nflex-flow: <flex-direction> || <flex-wrap>;\n```\n\n### justify-content属性\n\n``justify-content``属性定义了项目在主轴上的对齐方式。\n\n```\njustify-content: flex-start | flex-end | center | space-between | space-around;\n```\n\n* flex-start（默认值）：左对齐\n* flex-end：右对齐\n* center： 居中\n* space-between：两端对齐，项目之间的间隔都相等。\n* space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n![image](https://sfault-image.b0.upaiyun.com/421/275/4212753174-56fde6083157c_articlex)\n\n### align-items属性\n``align-items``属性定义项目在副轴轴上如何对齐。\n\n```\nalign-items: flex-start | flex-end | center | baseline | stretch;\n```\n\n* flex-start：交叉轴的起点对齐。\n* flex-end：交叉轴的终点对齐。\n* center：交叉轴的中点对齐。\n* baseline: 项目的第一行文字的基线对齐。\n* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n![image](http://img.blog.csdn.net/20150616152600533)\n\n### align-content属性\n\n``align-content``属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n```\nalign-content: flex-start | flex-end | center | space-between | space-around | stretch;\n```\n\n* flex-start：与交叉轴的起点对齐。\n* flex-end：与交叉轴的终点对齐。\n* center：与交叉轴的中点对齐。\n* space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n* space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n* stretch（默认值）：轴线占满整个交叉轴。\n\n## 子元素属性\n\n以下几个属性设置在子元素上。\n\n* flex-grow\n* flex-shrink\n* flex-basis\n* flex\n* align-self\n\n### flex-grow属性\n\n``flex-grow``属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。一张图看懂。跟``LinearLayout``中的``weight``属性一样。\n\n```\n.item {\n  flex-grow: <number>; /* default 0 */\n}\n```\n\n![image](https://sfault-image.b0.upaiyun.com/271/846/2718468848-56fde60740335_articlex)\n\n如果所有项目的``flex-grow``属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的``flex-grow``属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### flex-shrink属性\n\n``flex-shrink``属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n```\n.item {\n  flex-shrink: <number>; /* default 1 */\n}\n```\n\n如果所有项目的``flex-shrink``属性都为1，当空间不足时，都将等比例缩小。如果一个项目的``flex-shrink``属性为0，其他项目都为1，则空间不足时，前者不缩小。\n负值对该属性无效。\n\n### flex-basis属性\n\n``flex-basis``属性定义了在分配多余空间之前，子元素占据的``main size``主轴空间，浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为``auto``，即子元素的本来大小。\n\n```\n.item {\n  flex-basis: <length> | auto; /* default auto */\n}\n```\n\n### flex属性\n\n``flex``属性是``flex-grow``, ``flex-shrink`` 和 ``flex-basis``的简写，默认值为0 1 auto。后两个属性可选。\n\n```\n.item {\n  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n}\n```\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n### align-self属性\n\n``align-self``属性允许单个子元素有与其他子元素不一样的对齐方式，可覆盖``align-items``属性。默认值为``auto``，表示继承父元素的``align-items``属性，如果没有父元素，则等同于``stretch``。\n\n```\n.item {\n  align-self: auto | flex-start | flex-end | center | baseline | stretch;\n}\n```\n该属性可能取6个值，除了``auto``，其他都与``align-items``属性完全一致。\n\n\n# 实例\n\n属性基本都讲完了，下面进入实战。\n百度前端学院的其中一个任务：\n\n* 学习如何flex进行布局，学习如何根据屏幕宽度调整布局策略。\n* 屏幕宽度小于 640px 时，调整 Flexbox 的属性以实现第四个元素移动到最前面的效果，而不要改动第一个元素的边框颜色与高度实现效果图。\n\n[效果图](http://7xrp04.com1.z0.glb.clouddn.com/task_1_10_1.png)\n\n分析：\n1. 屏幕宽度小于640px时，调整主轴对齐方式justify-content属性为space-between，在副轴对齐方式align-items为center\n2. 屏幕宽度大于640px，要有换行，并且动态调整``order``属性，调整第四个子元素的排列位置。并且调整align-items为flex-start;\n\n[效果图](http://w4lle.github.io/ife_baidu/task10/index.html)和[代码](https://github.com/w4lle/ife_baidu/tree/master/task10)\n\n# Android开发者的福音\n\n\n大概在一个月前，Google开源了[flexbox-layout](https://github.com/google/flexbox-layout)项目，用以支持``Flexbox``布局在Android开发中使用，支持源生的``Flexbox``属性。\n官方例子，在xml布局文件中使用\n\n```xml\n<com.google.android.flexbox.FlexboxLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    app:flexWrap=\"wrap\"\n    app:alignItems=\"stretch\"\n    app:alignContent=\"stretch\" >\n\n    <TextView\n        android:id=\"@+id/textview1\"\n        android:layout_width=\"120dp\"\n        android:layout_height=\"80dp\"\n        app:layout_flexBasisPercent=\"50%\"\n        />\n\n    <TextView\n        android:id=\"@+id/textview2\"\n        android:layout_width=\"80dp\"\n        android:layout_height=\"80dp\"\n        app:layout_alignSelf=\"center\"\n        />\n\n    <TextView\n        android:id=\"@+id/textview3\"\n        android:layout_width=\"160dp\"\n        android:layout_height=\"80dp\"\n        app:layout_alignSelf=\"flex_end\"\n        />\n</com.google.android.flexbox.FlexboxLayout>\n```\n\n在java代码中使用\n\n```java\nFlexboxLayout flexboxLayout = (FlexboxLayout) findViewById(R.id.flexbox_layout);\nflexboxLayout.setFlexDirection(FlexboxLayout.FLEX_DIRECTION_COLUMN);\n\nView view = flexboxLayout.getChildAt(0);\nFlexboxLayout.LayoutParams lp = (FlexboxLayout.LayoutParams) view.getLayoutParams();\nlp.order = -1;\nlp.flexGrow = 2;\nview.setLayoutParams(lp);\n```\n\n可以看到使用非常方便，对于熟悉``Flexbox``的开发者来说对于``Android``app也可以快速上手。\nGoogle开发这个开源库我猜想可能一方面看到``React Native``使用``Flexbox``对于前端工程师开发Android app布局的无缝切换；另一方面，``Flexbox``也确实要比Android开发中经常使用的``LinearLayout``和``RelativeLayout``要方便很多，灵活性较两者有大幅提高，特别在动态变化这一块。\n\n# 总结\n\n``Flexbox``布局方式相比传统的盒模型布局方式要快速很多，对于一些复杂的页面也可以很快速的开发。而且由于Google和Facebook的支持和使用，相信会有越来越多的开发者使用这种布局方式进行开发，在跨平台开发框架越来越成熟的现在，``Flexbox``赶紧学起来！\n","slug":"Flexbox","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif79001jwhs6u5hgbnet"},{"title":"ClassyShark——apk分析利器","date":"2016-02-15T06:32:15.000Z","_content":"\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/ClassyShark.png)\n\n## 背景\n对于一个感兴趣的android非开源项目，通常使用逆向工程查看apk中的内容，俗称反编译。工具大概包括[dex2jar](https://github.com/pxb1988/dex2jar)、[JD-GUI](http://jd.benow.ca/)、[apktool](http://ibotpeaches.github.io/Apktool/install/)、[procyon](https://bitbucket.org/mstrobel/procyon),这些工具使用起来相对比较麻烦，如果我们只想知道该项目的基本框架、使用到哪些开源项目的话，那么就有些浪费时间。\n对于一些大厂的项目，我们还比较关心的是用到了哪些新的框架和技术，对于新技术的流行程度和使用普遍程度有个比较好的把握，指导是否需要进行深度的使用学习。比如最近的比较流行的rxjava，热更新技术等等。\n\n## ClassyShark\n\n\n[ClassyShark](https://github.com/google/android-classyshark)是一款可以查看Android可执行文件的浏览工具，支持.dex, .aar, .so, .apk, .jar, .class, .xml 等文件格式，分析里面的内容包括classes.dex文件，包、方法数量、类、字符串、使用的NativeLibrary等。\n\n### 使用方法\n\n1. 打开apk文件``java -jar ClassyShark.jar -open <YOUR_APK.apk>`` \n2. 将生成的所有数据导出到文本文件里``java -jar ClassyShark.jar -dump <BINARY_FILE>``\n3. 将指定类生成的文件导出到文本文件里``java -jar ClassyShark.jar -dump <BINARY_FILE> <FULLY_QUALIFIED_CLASS_NAME>``\n4. 打开ClassyShark，在GUI界面展示某特定的类\n5. ``java -jar ClassyShark.jar -open <BINARY_FILE> <FULLY_QUALIFIED_CLASS_NAME>``\n5. 检测APK``java -jar ClassyShark.jar -inspect <YOUR_APK.apk>\n``\n6. 导出所有的字符串 ``java -jar ClassyShark.jar -stringdump <YOUR_APK.apk>``\n\n### 具体使用\n以美团项目为例，让我们看看能得到什么有用的信息\n\n\n``java -jar ClassyShark.jar -open ~/Downloads/group-351_3-meituan_.apk``\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/Classy_group.png)\n\n美团项目中使用了MultiDex,并且classes.dex文件有3个，说明方法数肯定非常多。\n美团的编译版本非常新, 紧跟时代, 23版本(Android 6.0)。\n并且TargetSdkVersion也是23版本，紧跟技术方向。\n最低版本是16(Android 4.1), 4.1以下的手机无法运行。\n而且有好多的so库，有美团自己的，也有好多是第三方的库。\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/Classy_group_2.png)\n\n可以看到9万多个方法，怪不得会有3个classes.dex文件。\n项目中应用了大量的第三方库，并且一般都是主流的比较稳定的开源库。\n我们来看下都用到了哪些库\n\n* [ZXing](https://github.com/zxing/zxing)二维码识别库;\namap: 高德地图;\n* [PullToRefresh](https://github.com/chrisbanes/Android-PullToRefresh)使用最广的下拉刷新组件；\n* [jackson](https://github.com/FasterXML/jackson-dataformat-smile), json解析库;\n* [NineOldAndroids](https://github.com/JakeWharton/NineOldAndroids) Jake大神的android兼容库\n* [fresco](https://github.com/facebook/fresco),facebook出品的图片处理库，图片加载节省很多内存，避免OOM。\n* [RxJava](https://github.com/ReactiveX/RxJava)java响应式编程库，再加上``Square``的``Retrofit``库的支持，可以说未来就是``rxjava``的天下，目前市面上已经有很多基于rxjava的项目；我们团队也将基于rxjava来开发项目；\n圈内最牛逼的开源公司[Square](https://github.com/square)，Jake大神所在的公司，可以毫不夸张的说，[Square](https://github.com/square)的开源项目使得Android开发提速了好几年\n* [okhttp](https://github.com/square/okhttp)网络请求库，已被官方采用;\n* [retrofit](https://github.com/square/retrofit)非常牛逼的网络请求库，配合``rxjava``和lambda使用，代码量减少90%;\n* [otto](https://github.com/square/otto)事件总线;\n* [picasso](https://github.com/square/picasso)图片加载库；\n* [dagger](https://github.com/square/dagger)依赖注入框架；\n* [ExpandableTextView](https://github.com/Manabu-GT/ExpandableTextView)可折叠的TextView\n* iflytek, 科大讯飞的语音集成;\n* [ViewPagerIndicator](https://github.com/JakeWharton/ViewPagerIndicator)还是Jake大神的项目，viewpager的滚动控件；\n* [actionbarsherlock](http://actionbarsherlock.com/)依然是Jake大神的项目，Actionbar的适配库，不过已经过时了；\n* [华为推送](http://developer.huawei.com/push)\n* [SystemBarTint](https://github.com/jgilfelt/SystemBarTint)状态栏沉浸效果库\n* 百度地图\n* 新浪微博\n* 腾讯的QQ和微信\n* 大众点评,已经合并一家,东西也得用;\n* [umpay](http://www.umpay.com/umpay_cms/), 联动优势支付;\n* 支付宝；\n* [andfix](https://github.com/alibaba/AndFix)阿里出品的android热更新框架；\n* [flurry](http://www.flurry.com/)统计库；\n* [小米推送](http://dev.xiaomi.com/doc/?page_id=1670)\n* [http-request](https://github.com/kevinsawicki/http-request)网络请求库；\n* [EventBus](https://github.com/greenrobot/EventBus)事件总线库；\n* [PhotoView](https://github.com/chrisbanes/PhotoView)放大缩小的图片处理库；\n* [roboguice](https://github.com/roboguice/roboguice)依赖注入框架，类似``Dagger``；\n* [zip4j](http://www.lingala.net/zip4j/)处理zip压缩的库;\n[link](https://github.com/BoltsFramework/Bolts-Android)异步task关联库,很像``rxjava``；\n\n## 总结\n从上面分析我们可见看出，美团是一个技术很开放的公司，对于框架的使用比较多，使用的基本都是主流的开发框架，减少开发成本，增强app的稳定性和体验，对于我们来说，有很大的借鉴意义。比如，目前都在试水的热更新框架，美团选择了阿里的``andfix``,那么该技术方案肯定是得到了美团团队的验证；另外，美团团队也是比较潮流的，``Retrofit``+``Rxjava``的潮流趋势已经不可阻挡，美团已经开始使用；但是，从项目引用库中我们也可以看到一些不足之处；比如，同一种框架引用了多种第三方库，如网络库(``okhttp``,``http-request``),图片加载库(``fresco``,``picasso``),事件总线(``EventBus``, ``Otto``),依赖注入(``Dagger``,``roboguice``)，推送相关的库等很多重复的库，如果去掉重复的库那么可以节省很多的编译时间和apk包的大小；还有就是，我们基本可以断定，美团团队的内部并不能很好的统一，没有有效的沟通，代码开发很混乱，导致项目结构上的臃肿，重复库的使用等等问题。\n\n通过分析App的项目结构和引用库的信息，我们大致掌握了该项目的架构，一些开发中的经验和不足，拓宽下开发视野，发现一些好用的开源库，增强我们的武器，这些都是我们在开发中可以借鉴的东西。\n\n参考\n\n* [分析应用使用的技术框架和开源库](http://www.jianshu.com/p/8e8b88ea2197)","source":"_posts/ClassyShark——分析apk利器.md","raw":"---\ntitle: ClassyShark——apk分析利器\ndate: 2016-02-15 14:32:15\ntags: [工具,apk反编辑,逆向]\n\n---\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/ClassyShark.png)\n\n## 背景\n对于一个感兴趣的android非开源项目，通常使用逆向工程查看apk中的内容，俗称反编译。工具大概包括[dex2jar](https://github.com/pxb1988/dex2jar)、[JD-GUI](http://jd.benow.ca/)、[apktool](http://ibotpeaches.github.io/Apktool/install/)、[procyon](https://bitbucket.org/mstrobel/procyon),这些工具使用起来相对比较麻烦，如果我们只想知道该项目的基本框架、使用到哪些开源项目的话，那么就有些浪费时间。\n对于一些大厂的项目，我们还比较关心的是用到了哪些新的框架和技术，对于新技术的流行程度和使用普遍程度有个比较好的把握，指导是否需要进行深度的使用学习。比如最近的比较流行的rxjava，热更新技术等等。\n\n## ClassyShark\n\n\n[ClassyShark](https://github.com/google/android-classyshark)是一款可以查看Android可执行文件的浏览工具，支持.dex, .aar, .so, .apk, .jar, .class, .xml 等文件格式，分析里面的内容包括classes.dex文件，包、方法数量、类、字符串、使用的NativeLibrary等。\n\n### 使用方法\n\n1. 打开apk文件``java -jar ClassyShark.jar -open <YOUR_APK.apk>`` \n2. 将生成的所有数据导出到文本文件里``java -jar ClassyShark.jar -dump <BINARY_FILE>``\n3. 将指定类生成的文件导出到文本文件里``java -jar ClassyShark.jar -dump <BINARY_FILE> <FULLY_QUALIFIED_CLASS_NAME>``\n4. 打开ClassyShark，在GUI界面展示某特定的类\n5. ``java -jar ClassyShark.jar -open <BINARY_FILE> <FULLY_QUALIFIED_CLASS_NAME>``\n5. 检测APK``java -jar ClassyShark.jar -inspect <YOUR_APK.apk>\n``\n6. 导出所有的字符串 ``java -jar ClassyShark.jar -stringdump <YOUR_APK.apk>``\n\n### 具体使用\n以美团项目为例，让我们看看能得到什么有用的信息\n\n\n``java -jar ClassyShark.jar -open ~/Downloads/group-351_3-meituan_.apk``\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/Classy_group.png)\n\n美团项目中使用了MultiDex,并且classes.dex文件有3个，说明方法数肯定非常多。\n美团的编译版本非常新, 紧跟时代, 23版本(Android 6.0)。\n并且TargetSdkVersion也是23版本，紧跟技术方向。\n最低版本是16(Android 4.1), 4.1以下的手机无法运行。\n而且有好多的so库，有美团自己的，也有好多是第三方的库。\n\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/Classy_group_2.png)\n\n可以看到9万多个方法，怪不得会有3个classes.dex文件。\n项目中应用了大量的第三方库，并且一般都是主流的比较稳定的开源库。\n我们来看下都用到了哪些库\n\n* [ZXing](https://github.com/zxing/zxing)二维码识别库;\namap: 高德地图;\n* [PullToRefresh](https://github.com/chrisbanes/Android-PullToRefresh)使用最广的下拉刷新组件；\n* [jackson](https://github.com/FasterXML/jackson-dataformat-smile), json解析库;\n* [NineOldAndroids](https://github.com/JakeWharton/NineOldAndroids) Jake大神的android兼容库\n* [fresco](https://github.com/facebook/fresco),facebook出品的图片处理库，图片加载节省很多内存，避免OOM。\n* [RxJava](https://github.com/ReactiveX/RxJava)java响应式编程库，再加上``Square``的``Retrofit``库的支持，可以说未来就是``rxjava``的天下，目前市面上已经有很多基于rxjava的项目；我们团队也将基于rxjava来开发项目；\n圈内最牛逼的开源公司[Square](https://github.com/square)，Jake大神所在的公司，可以毫不夸张的说，[Square](https://github.com/square)的开源项目使得Android开发提速了好几年\n* [okhttp](https://github.com/square/okhttp)网络请求库，已被官方采用;\n* [retrofit](https://github.com/square/retrofit)非常牛逼的网络请求库，配合``rxjava``和lambda使用，代码量减少90%;\n* [otto](https://github.com/square/otto)事件总线;\n* [picasso](https://github.com/square/picasso)图片加载库；\n* [dagger](https://github.com/square/dagger)依赖注入框架；\n* [ExpandableTextView](https://github.com/Manabu-GT/ExpandableTextView)可折叠的TextView\n* iflytek, 科大讯飞的语音集成;\n* [ViewPagerIndicator](https://github.com/JakeWharton/ViewPagerIndicator)还是Jake大神的项目，viewpager的滚动控件；\n* [actionbarsherlock](http://actionbarsherlock.com/)依然是Jake大神的项目，Actionbar的适配库，不过已经过时了；\n* [华为推送](http://developer.huawei.com/push)\n* [SystemBarTint](https://github.com/jgilfelt/SystemBarTint)状态栏沉浸效果库\n* 百度地图\n* 新浪微博\n* 腾讯的QQ和微信\n* 大众点评,已经合并一家,东西也得用;\n* [umpay](http://www.umpay.com/umpay_cms/), 联动优势支付;\n* 支付宝；\n* [andfix](https://github.com/alibaba/AndFix)阿里出品的android热更新框架；\n* [flurry](http://www.flurry.com/)统计库；\n* [小米推送](http://dev.xiaomi.com/doc/?page_id=1670)\n* [http-request](https://github.com/kevinsawicki/http-request)网络请求库；\n* [EventBus](https://github.com/greenrobot/EventBus)事件总线库；\n* [PhotoView](https://github.com/chrisbanes/PhotoView)放大缩小的图片处理库；\n* [roboguice](https://github.com/roboguice/roboguice)依赖注入框架，类似``Dagger``；\n* [zip4j](http://www.lingala.net/zip4j/)处理zip压缩的库;\n[link](https://github.com/BoltsFramework/Bolts-Android)异步task关联库,很像``rxjava``；\n\n## 总结\n从上面分析我们可见看出，美团是一个技术很开放的公司，对于框架的使用比较多，使用的基本都是主流的开发框架，减少开发成本，增强app的稳定性和体验，对于我们来说，有很大的借鉴意义。比如，目前都在试水的热更新框架，美团选择了阿里的``andfix``,那么该技术方案肯定是得到了美团团队的验证；另外，美团团队也是比较潮流的，``Retrofit``+``Rxjava``的潮流趋势已经不可阻挡，美团已经开始使用；但是，从项目引用库中我们也可以看到一些不足之处；比如，同一种框架引用了多种第三方库，如网络库(``okhttp``,``http-request``),图片加载库(``fresco``,``picasso``),事件总线(``EventBus``, ``Otto``),依赖注入(``Dagger``,``roboguice``)，推送相关的库等很多重复的库，如果去掉重复的库那么可以节省很多的编译时间和apk包的大小；还有就是，我们基本可以断定，美团团队的内部并不能很好的统一，没有有效的沟通，代码开发很混乱，导致项目结构上的臃肿，重复库的使用等等问题。\n\n通过分析App的项目结构和引用库的信息，我们大致掌握了该项目的架构，一些开发中的经验和不足，拓宽下开发视野，发现一些好用的开源库，增强我们的武器，这些都是我们在开发中可以借鉴的东西。\n\n参考\n\n* [分析应用使用的技术框架和开源库](http://www.jianshu.com/p/8e8b88ea2197)","slug":"ClassyShark——分析apk利器","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif7b001nwhs69y3stqo0"},{"title":"AsyncTask解析","date":"2016-07-29T07:44:19.000Z","_content":"\n# AsyncTask用法\n\n```java\n    private class SaveImageTask extends AsyncTask<Bitmap, String, String> {\n        @Override\n        protected void onPreExecute() {\n            Helper.showToast(\"正在分享，请稍等...\");\n        }\n        \n        @Override\n        protected String doInBackground(Bitmap... params) {\n            //耗时操作\n            return String; \n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n        }\n    }\n    \n    //使用\n    new SaveImageTask().execute(loadedImage);\n```\n\n# 源码分析\n\nAsyncTask类总共600行左右，大概看下内部实现。初始化：\n\n```java\n    private static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {\n        Params[] mParams;\n    }\n    \n    public AsyncTask() {\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                Result result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n                return postResult(result);\n            }\n        };\n\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                try {\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                            e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n        };\n    }\n```\n\n初始化了两个变量，一个Callable mWorker，一个FutureTask mFuture，FutureTask实现了Runnable和Future。将mWorker作为参数传递给了mFuture的构造方法，关于FutureTask和Callable，简单的来说就是Future里面封装了Callable，执行Future实际上执行的是Callable的call方法，Future的get()可以从Callable拿到执行的结果。Callable的Call()会去执行抽象方法doInBackground(mParams);并把传进来的mParams带过去，doInBackground需要我们自己实现，去做一些耗时的操作。然后拿到结果执行postResult(result)方法，这个待会再说。继续往下看\n\n```java\nFutureTask的run方法\npublic void run() {\n        try {\n            //构造方法里的Callable参数\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);//可以通过get()拿到结果\n            }\n        } finally {\n        }\n    }\n```\n\n执行AsyncTask的方法\n\n```java\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n        Params... params) {\n    if (mStatus != Status.PENDING) {\n        switch (mStatus) {\n            case RUNNING:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task is already running.\");\n            case FINISHED:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task has already been executed \"\n                        + \"(a task can be executed only once)\");\n        }\n    }\n\n    mStatus = Status.RUNNING;\n\n    onPreExecute();\n\n    mWorker.mParams = params;\n    exec.execute(mFuture);\n\n    return this;\n}\n```\n\n每个任务在完成前只能执行一次，然后执行onPreExecute();的抽象方法，在使用的AsyncTask中实现做一些准备操作，然后将传进来的params参数付给mWorker的mParams，还记得mWorker吗，是一个Callable。exec.execute(mFuture);实际上被调用的是mWorker的call()。这里有个默认的Executor sDefaultExecutor，看下实现\n\n```java\n    \n    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n    private static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n    \n```\n\nmTasks是一个先进先出的队列存储Runnable对象，offer方法加到队尾，poll()从队头取。第一次mActive肯定是null，所以走到scheduleNext取出一个用THREAD_POOL_EXECUTOR去执行。下一次再调用execute()，这是mActive不为空，所以就不会执行scheduleNext()，但是由于有try finally的存在，所以下一次scheduleNext();是在本次run方法执行完，也就是说要等待本次耗时操作执行完才可以进行下一次耗时操作。也对应了SerialExecutor这个名字，串行执行。实际的Executor是THREAD_POOL_EXECUTOR，看下实现\n    \n```java\n    \n    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n    private static final int CORE_POOL_SIZE = CPU_COUNT + 1;\n    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;\n    private static final int KEEP_ALIVE = 1;\n\n    private static final ThreadFactory sThreadFactory = new ThreadFactory() {\n        private final AtomicInteger mCount = new AtomicInteger(1);\n\n        public Thread newThread(Runnable r) {\n            return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement());\n        }\n    };\n\n    private static final BlockingQueue<Runnable> sPoolWorkQueue =\n            new LinkedBlockingQueue<Runnable>(128);\n\n    public static final Executor THREAD_POOL_EXECUTOR\n            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,\n                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);\n```\n\n定义了一个线程池，同时运行线程数CPU数+1，线程池总大小CPU数 * 2 + 1，在之前的版本这两个数字分别是5和128。虽然定义了可以同时运行那么多线程，但是由于SerialExecutor的存在，它会强制串行并发，所以实际上只有一个线程在跑，所以也就不存在任务数超过线程池总大小会蹦的问题了。SerialExecutor是AsyncTask提供给开发者的一种默认实现，我们也可以通过``public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,Params... params)``方法传进去一个自己定义的线程池，这样就可以并行并发了。\n\n刚才说到最终的执行时在mWorker的call()去执行具体的耗时操作，执行完了调用postResult()方法，看下实现\n\n```java\n    private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n                new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n```\n\n这就很明了了，通过Handler把result结果发出去。看下Handler的实现\n\n```java\n\n    private static class InternalHandler extends Handler {\n        public InternalHandler() {\n            super(Looper.getMainLooper());\n        }\n\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n```\n\nInternalHandler是一个主线程上的Handler，也就是发消息到主线程，刚才发过来的Result就被发送的主线程了，最后调用AsyncTask的finish方法，看下\n\n```java\n    private void finish(Result result) {\n        if (isCancelled()) {\n            onCancelled(result);\n        } else {\n            onPostExecute(result);\n        }\n        mStatus = Status.FINISHED;\n    }\n```\n\n如果取消了执行onCancelled(result)回调，否则执行onPostExecute(result)。并把状态置为FINISHED。整个流程也就走完了。\n\n# 总结\n\n本文分析了AsyncTask的原理，一句话概括，AsyncTask封装了线程池和Handler，线程池跑耗时任务、Handler向主线程发消息。如果不是很多任务的话就用HandlerThread来做就行了；任务多并且不是那么耗时的可以考虑用用AsyncTask，不过还是建议自己写线程池。\n\n","source":"_posts/AsyncTask.md","raw":"---\ntitle: AsyncTask解析\ndate: 2016-07-29 15:44:19\ntags: [Android]\n---\n\n# AsyncTask用法\n\n```java\n    private class SaveImageTask extends AsyncTask<Bitmap, String, String> {\n        @Override\n        protected void onPreExecute() {\n            Helper.showToast(\"正在分享，请稍等...\");\n        }\n        \n        @Override\n        protected String doInBackground(Bitmap... params) {\n            //耗时操作\n            return String; \n        }\n\n        @Override\n        protected void onPostExecute(String result) {\n            super.onPostExecute(result);\n        }\n    }\n    \n    //使用\n    new SaveImageTask().execute(loadedImage);\n```\n\n# 源码分析\n\nAsyncTask类总共600行左右，大概看下内部实现。初始化：\n\n```java\n    private static abstract class WorkerRunnable<Params, Result> implements Callable<Result> {\n        Params[] mParams;\n    }\n    \n    public AsyncTask() {\n        mWorker = new WorkerRunnable<Params, Result>() {\n            public Result call() throws Exception {\n                mTaskInvoked.set(true);\n\n                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n                //noinspection unchecked\n                Result result = doInBackground(mParams);\n                Binder.flushPendingCommands();\n                return postResult(result);\n            }\n        };\n\n        mFuture = new FutureTask<Result>(mWorker) {\n            @Override\n            protected void done() {\n                try {\n                    postResultIfNotInvoked(get());\n                } catch (InterruptedException e) {\n                    android.util.Log.w(LOG_TAG, e);\n                } catch (ExecutionException e) {\n                    throw new RuntimeException(\"An error occurred while executing doInBackground()\",\n                            e.getCause());\n                } catch (CancellationException e) {\n                    postResultIfNotInvoked(null);\n                }\n            }\n        };\n    }\n```\n\n初始化了两个变量，一个Callable mWorker，一个FutureTask mFuture，FutureTask实现了Runnable和Future。将mWorker作为参数传递给了mFuture的构造方法，关于FutureTask和Callable，简单的来说就是Future里面封装了Callable，执行Future实际上执行的是Callable的call方法，Future的get()可以从Callable拿到执行的结果。Callable的Call()会去执行抽象方法doInBackground(mParams);并把传进来的mParams带过去，doInBackground需要我们自己实现，去做一些耗时的操作。然后拿到结果执行postResult(result)方法，这个待会再说。继续往下看\n\n```java\nFutureTask的run方法\npublic void run() {\n        try {\n            //构造方法里的Callable参数\n            Callable<V> c = callable;\n            if (c != null && state == NEW) {\n                V result;\n                boolean ran;\n                try {\n                    result = c.call();\n                    ran = true;\n                } catch (Throwable ex) {\n                    result = null;\n                    ran = false;\n                    setException(ex);\n                }\n                if (ran)\n                    set(result);//可以通过get()拿到结果\n            }\n        } finally {\n        }\n    }\n```\n\n执行AsyncTask的方法\n\n```java\n    public final AsyncTask<Params, Progress, Result> execute(Params... params) {\n        return executeOnExecutor(sDefaultExecutor, params);\n    }\n    public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,\n        Params... params) {\n    if (mStatus != Status.PENDING) {\n        switch (mStatus) {\n            case RUNNING:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task is already running.\");\n            case FINISHED:\n                throw new IllegalStateException(\"Cannot execute task:\"\n                        + \" the task has already been executed \"\n                        + \"(a task can be executed only once)\");\n        }\n    }\n\n    mStatus = Status.RUNNING;\n\n    onPreExecute();\n\n    mWorker.mParams = params;\n    exec.execute(mFuture);\n\n    return this;\n}\n```\n\n每个任务在完成前只能执行一次，然后执行onPreExecute();的抽象方法，在使用的AsyncTask中实现做一些准备操作，然后将传进来的params参数付给mWorker的mParams，还记得mWorker吗，是一个Callable。exec.execute(mFuture);实际上被调用的是mWorker的call()。这里有个默认的Executor sDefaultExecutor，看下实现\n\n```java\n    \n    private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;\n    private static class SerialExecutor implements Executor {\n        final ArrayDeque<Runnable> mTasks = new ArrayDeque<Runnable>();\n        Runnable mActive;\n\n        public synchronized void execute(final Runnable r) {\n            mTasks.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (mActive == null) {\n                scheduleNext();\n            }\n        }\n\n        protected synchronized void scheduleNext() {\n            if ((mActive = mTasks.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(mActive);\n            }\n        }\n    }\n    \n```\n\nmTasks是一个先进先出的队列存储Runnable对象，offer方法加到队尾，poll()从队头取。第一次mActive肯定是null，所以走到scheduleNext取出一个用THREAD_POOL_EXECUTOR去执行。下一次再调用execute()，这是mActive不为空，所以就不会执行scheduleNext()，但是由于有try finally的存在，所以下一次scheduleNext();是在本次run方法执行完，也就是说要等待本次耗时操作执行完才可以进行下一次耗时操作。也对应了SerialExecutor这个名字，串行执行。实际的Executor是THREAD_POOL_EXECUTOR，看下实现\n    \n```java\n    \n    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n    private static final int CORE_POOL_SIZE = CPU_COUNT + 1;\n    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;\n    private static final int KEEP_ALIVE = 1;\n\n    private static final ThreadFactory sThreadFactory = new ThreadFactory() {\n        private final AtomicInteger mCount = new AtomicInteger(1);\n\n        public Thread newThread(Runnable r) {\n            return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement());\n        }\n    };\n\n    private static final BlockingQueue<Runnable> sPoolWorkQueue =\n            new LinkedBlockingQueue<Runnable>(128);\n\n    public static final Executor THREAD_POOL_EXECUTOR\n            = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE,\n                    TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory);\n```\n\n定义了一个线程池，同时运行线程数CPU数+1，线程池总大小CPU数 * 2 + 1，在之前的版本这两个数字分别是5和128。虽然定义了可以同时运行那么多线程，但是由于SerialExecutor的存在，它会强制串行并发，所以实际上只有一个线程在跑，所以也就不存在任务数超过线程池总大小会蹦的问题了。SerialExecutor是AsyncTask提供给开发者的一种默认实现，我们也可以通过``public final AsyncTask<Params, Progress, Result> executeOnExecutor(Executor exec,Params... params)``方法传进去一个自己定义的线程池，这样就可以并行并发了。\n\n刚才说到最终的执行时在mWorker的call()去执行具体的耗时操作，执行完了调用postResult()方法，看下实现\n\n```java\n    private Result postResult(Result result) {\n        @SuppressWarnings(\"unchecked\")\n        Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,\n                new AsyncTaskResult<Result>(this, result));\n        message.sendToTarget();\n        return result;\n    }\n```\n\n这就很明了了，通过Handler把result结果发出去。看下Handler的实现\n\n```java\n\n    private static class InternalHandler extends Handler {\n        public InternalHandler() {\n            super(Looper.getMainLooper());\n        }\n\n        @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"})\n        @Override\n        public void handleMessage(Message msg) {\n            AsyncTaskResult<?> result = (AsyncTaskResult<?>) msg.obj;\n            switch (msg.what) {\n                case MESSAGE_POST_RESULT:\n                    // There is only one result\n                    result.mTask.finish(result.mData[0]);\n                    break;\n                case MESSAGE_POST_PROGRESS:\n                    result.mTask.onProgressUpdate(result.mData);\n                    break;\n            }\n        }\n    }\n```\n\nInternalHandler是一个主线程上的Handler，也就是发消息到主线程，刚才发过来的Result就被发送的主线程了，最后调用AsyncTask的finish方法，看下\n\n```java\n    private void finish(Result result) {\n        if (isCancelled()) {\n            onCancelled(result);\n        } else {\n            onPostExecute(result);\n        }\n        mStatus = Status.FINISHED;\n    }\n```\n\n如果取消了执行onCancelled(result)回调，否则执行onPostExecute(result)。并把状态置为FINISHED。整个流程也就走完了。\n\n# 总结\n\n本文分析了AsyncTask的原理，一句话概括，AsyncTask封装了线程池和Handler，线程池跑耗时任务、Handler向主线程发消息。如果不是很多任务的话就用HandlerThread来做就行了；任务多并且不是那么耗时的可以考虑用用AsyncTask，不过还是建议自己写线程池。\n\n","slug":"AsyncTask","published":1,"updated":"2016-07-31T11:12:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif7g001twhs6xyn4krj5"},{"title":"Apk包瘦身笔记","date":"2016-04-10T11:11:51.000Z","_content":"\n# 背景\n\n随着业务功能的不断更迭，apk安装包的体积越来越大，最新的薄荷app android版本的安装包大小已经达到了22.5M，过大的安装包对于用户的体验来说会造成不好的影响，所以减小apk包的大小就显得尤为重要。\n\n# 问题原因\n\n[NimbleDroid](https://nimbledroid.com/)网站可以分析出apk安装包的各种大文件排行和各种依赖包的方法数，我们比较关注的是大文件的大小。上图\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/large_file1.png)\n\n不看不知道，一看真是吓一跳，超过100k的图片文件就那么多，而且超过300k的就有7个之多。\n还有两个MP3文件也很大。\n\n# 解决办法\n\n## 资源混淆\n\n资源混淆的方案采用的微信团队的[AndResGuard](https://github.com/shwenzhang/AndResGuard?spm=a313e.7916648.0.0.wwht7B)。使用方法输入一个apk文件，压缩混淆后输出一个apk包，采用引用gradle插件的方式集成到项目中，但是插件并不支持，所以就需要适配多渠道打包。薄荷项目中多渠道打包使用的是美团的方案，参考[Android批量打包提速](http://www.open-open.com/lib/view/open1418262988402.html)\n方法如下\n\n```gradle\n    project.afterEvaluate {\n        //在Release后执行资源混淆，然后多渠道打包\n        //打包命令 ./gradlew resguard\n        tasks.getByName(\"resguard\") {\n            it.doLast {\n                print 'channel package task begin'\n                def fileName = \"one_v${defaultConfig.versionName}_${releaseTime()}_signed_7zip_aligned.apk\"\n                def rApk = new File(\"app/build/outputs/apk/AndResProguard/\" + fileName)\n                if (rApk.exists()) {\n                    print 'resGuard apk exits begin channel package'\n                    packageChannel(rApk.absolutePath)\n                }\n            }\n        }\n    }\n```\n执行完resguard混淆压缩后生成apk文件，调用python脚本执行多渠道打包。\n还有一点需要注意的是，使用该方案要注意动态查找id导致找不到id的问题。需要添加白名单，项目中有明确的说明。但是对于引用第三方项目较多的来说，挨个添加id就很不现实了。\n所以在白名单中添加所有的id\n```java\n //for all id\n            \"com.boohee.one.R.id.*\"\n```\n\n集成改方案后apk包大概较小了4M。并且资源文件也已经混淆，资源路径长路径变成段路径\n``res/drawable/icon -> res/drawable/a``\n对于反编译apk来说难度增加了。\n\n## 删除无用代码和资源\n\n在Android Studio中使用lint分析无用的文件\nAnalyze -> Run Inspection by Name\n\n```\nunusedResources\n```\n会列出无用资源列表，特别是图片全部干掉。\n另外一点，由于项目更新迭代快，业务功能更改比较频繁，这就导致了项目中的无用代码特别多，但是依靠lint检查就比较有限，需要我们根据项目功能手动删除。删除无用代码后又会引出很多无用的资源文件，lint检查后再删除一遍。\n做完这一步大概减少了1.5M左右。但是还有好多无用的代码还没有删除，以后有时间再处理。\n\n## 去除无用的语言资源\n具体项目具体执行，对于没有国际化的项目比如薄荷，在build.gradle中添加一句\n\n```java\nandroid {\n    defaultConfig {\n        resConfigs \"zh\"\n    }\n}\n```\n只使用中文资源，不光对本项目生效，还会对依赖的项目生效，比如support包。这样打包后只会打包中文资源，大概减小了1M左右。\n\n## 删除多余的so库\n\n薄荷一直以来至保留armable，这一点可以根据具体项目来定。\n\n## 混淆\nProguard是编译时对java代码进行压缩，混淆，优化，预编译等操作的集成化工具。达到删除冗余，增加安全防护，减小大小的功效。薄荷一直以来并没有加入代码混淆，一方面原因是项目越来越大，混淆的话如果测试不充分很容易出问题，另一方面，薄荷一直提倡开源，并且核心并不在app端，并且有很多初学者会反编译薄荷app学习一些开发技巧。但是，对于提升用户体验来说这些都显得微不足道。我们也在着手做相关的混淆工作。\n\n## 其余一些建议\n\n* tiny图片处理 目前所知图片压缩效果最好的网站。蘑菇街写了tiny的gradle[插件](https://github.com/mogujie/TinyPIC_Gradle_Plugin)，薄荷还没有实践\n* 删除音频文件 薄荷项目中有一些音频文件，好在下个版本改业务功能即将下线，所以这些文件可以直接删除；另外一种方法是可以走网络获取，在线化。\n* 用更小的库\n* png转成webp 可能会有点兼容性问题\n\n# 参考\n* [APK瘦身记，如何实现高达53%的压缩效果](http://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.3.T8AIXY&articleid=219)\n* [安装包立减1M--微信Android资源混淆打包工具](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd)\n* [APK瘦身实践](http://www.jayfeng.com/2015/12/29/APK%E7%98%A6%E8%BA%AB%E5%AE%9E%E8%B7%B5/)]\n* [如何将apk大小减少6M的](http://blog.csdn.net/UsherFor/article/details/46827587)","source":"_posts/Apk包瘦身笔记.md","raw":"---\ntitle: Apk包瘦身笔记\ndate: 2016-04-10 19:11:51\ntags: [apk瘦身, 优化]\n---\n\n# 背景\n\n随着业务功能的不断更迭，apk安装包的体积越来越大，最新的薄荷app android版本的安装包大小已经达到了22.5M，过大的安装包对于用户的体验来说会造成不好的影响，所以减小apk包的大小就显得尤为重要。\n\n# 问题原因\n\n[NimbleDroid](https://nimbledroid.com/)网站可以分析出apk安装包的各种大文件排行和各种依赖包的方法数，我们比较关注的是大文件的大小。上图\n![image](https://raw.githubusercontent.com/w4lle/w4lle.github.io/post/source/uploads/large_file1.png)\n\n不看不知道，一看真是吓一跳，超过100k的图片文件就那么多，而且超过300k的就有7个之多。\n还有两个MP3文件也很大。\n\n# 解决办法\n\n## 资源混淆\n\n资源混淆的方案采用的微信团队的[AndResGuard](https://github.com/shwenzhang/AndResGuard?spm=a313e.7916648.0.0.wwht7B)。使用方法输入一个apk文件，压缩混淆后输出一个apk包，采用引用gradle插件的方式集成到项目中，但是插件并不支持，所以就需要适配多渠道打包。薄荷项目中多渠道打包使用的是美团的方案，参考[Android批量打包提速](http://www.open-open.com/lib/view/open1418262988402.html)\n方法如下\n\n```gradle\n    project.afterEvaluate {\n        //在Release后执行资源混淆，然后多渠道打包\n        //打包命令 ./gradlew resguard\n        tasks.getByName(\"resguard\") {\n            it.doLast {\n                print 'channel package task begin'\n                def fileName = \"one_v${defaultConfig.versionName}_${releaseTime()}_signed_7zip_aligned.apk\"\n                def rApk = new File(\"app/build/outputs/apk/AndResProguard/\" + fileName)\n                if (rApk.exists()) {\n                    print 'resGuard apk exits begin channel package'\n                    packageChannel(rApk.absolutePath)\n                }\n            }\n        }\n    }\n```\n执行完resguard混淆压缩后生成apk文件，调用python脚本执行多渠道打包。\n还有一点需要注意的是，使用该方案要注意动态查找id导致找不到id的问题。需要添加白名单，项目中有明确的说明。但是对于引用第三方项目较多的来说，挨个添加id就很不现实了。\n所以在白名单中添加所有的id\n```java\n //for all id\n            \"com.boohee.one.R.id.*\"\n```\n\n集成改方案后apk包大概较小了4M。并且资源文件也已经混淆，资源路径长路径变成段路径\n``res/drawable/icon -> res/drawable/a``\n对于反编译apk来说难度增加了。\n\n## 删除无用代码和资源\n\n在Android Studio中使用lint分析无用的文件\nAnalyze -> Run Inspection by Name\n\n```\nunusedResources\n```\n会列出无用资源列表，特别是图片全部干掉。\n另外一点，由于项目更新迭代快，业务功能更改比较频繁，这就导致了项目中的无用代码特别多，但是依靠lint检查就比较有限，需要我们根据项目功能手动删除。删除无用代码后又会引出很多无用的资源文件，lint检查后再删除一遍。\n做完这一步大概减少了1.5M左右。但是还有好多无用的代码还没有删除，以后有时间再处理。\n\n## 去除无用的语言资源\n具体项目具体执行，对于没有国际化的项目比如薄荷，在build.gradle中添加一句\n\n```java\nandroid {\n    defaultConfig {\n        resConfigs \"zh\"\n    }\n}\n```\n只使用中文资源，不光对本项目生效，还会对依赖的项目生效，比如support包。这样打包后只会打包中文资源，大概减小了1M左右。\n\n## 删除多余的so库\n\n薄荷一直以来至保留armable，这一点可以根据具体项目来定。\n\n## 混淆\nProguard是编译时对java代码进行压缩，混淆，优化，预编译等操作的集成化工具。达到删除冗余，增加安全防护，减小大小的功效。薄荷一直以来并没有加入代码混淆，一方面原因是项目越来越大，混淆的话如果测试不充分很容易出问题，另一方面，薄荷一直提倡开源，并且核心并不在app端，并且有很多初学者会反编译薄荷app学习一些开发技巧。但是，对于提升用户体验来说这些都显得微不足道。我们也在着手做相关的混淆工作。\n\n## 其余一些建议\n\n* tiny图片处理 目前所知图片压缩效果最好的网站。蘑菇街写了tiny的gradle[插件](https://github.com/mogujie/TinyPIC_Gradle_Plugin)，薄荷还没有实践\n* 删除音频文件 薄荷项目中有一些音频文件，好在下个版本改业务功能即将下线，所以这些文件可以直接删除；另外一种方法是可以走网络获取，在线化。\n* 用更小的库\n* png转成webp 可能会有点兼容性问题\n\n# 参考\n* [APK瘦身记，如何实现高达53%的压缩效果](http://jaq.alibaba.com/community/art/show?spm=a313e.7916646.24000001.3.T8AIXY&articleid=219)\n* [安装包立减1M--微信Android资源混淆打包工具](http://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd)\n* [APK瘦身实践](http://www.jayfeng.com/2015/12/29/APK%E7%98%A6%E8%BA%AB%E5%AE%9E%E8%B7%B5/)]\n* [如何将apk大小减少6M的](http://blog.csdn.net/UsherFor/article/details/46827587)","slug":"Apk包瘦身笔记","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif7i001vwhs6pvdf7ijw"},{"title":"Android进程保活之绑定系统服务","date":"2016-07-24T12:25:32.000Z","_content":"\n# 进程保活\n\n有些业务需要service在后台持续的运行，所以就要有后台保活机制，包括lowMemory防杀和自启。\n\n## 防杀机制\n\n基本就是提高进程优先级，保证在低内存时进程不被有限杀死，常用的方法就是利用系统bug提高进程优先级，灰色保活手段。\n\n## 后台自启\n\n大概包括\n\n - Receiver拉起\n - AlarmManager拉起\n - 双进程互相守护\n - 利用推送SDK拉起进程\n \n以上说的这几种是常用的方法，对于原生和没有深度定制的ROM有一定作用，但是对于像小米、魅族等这类深度定制的系统来说效果不是很好。\n\n## 绑定系统服务\n\n系统提供一些系统级的Service，比如AccessibilityService辅助服务、NotificationListenerService用于监听通知消息。这篇文章主要讲下怎样利用NotificationListenerService用于监听通知消息实现进程保活。\n\n首先，如果想使用系统service，必须要用户手动点开权限。我们可以添加一个设置的入口直接跳到系统设置通知权限的界面，显示提示用户需要开启权限。\n\n```java\n    public static void goNLPermission(Context context) {\n        try {\n            Intent intent = new Intent(\"android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS\");\n            context.startActivity(intent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n界面就不截图了，然后我们app中要有一个权限的状态检查用于提示用户是否开启了通知显示权。\n\n```java\n/**\n * 检查通知使用权\n */\npublic static boolean checkNotificationPermission(Context context) {\n    String pkg = context.getPackageName();\n    String flat = Settings.Secure.getString(context.getContentResolver(), \"enabled_notification_listeners\");\n    boolean enabled = flat != null && flat.contains(pkg);\n    return enabled;\n}\n```\n\n注册，声明运行在com.package.pedometer进程中\n\n```java\n<service\n    android:name=\".service.MyListenerService\"\n    android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"\n    android:process=\":pedometer\">\n    <intent-filter>\n        <action android:name=\"android.service.notification.NotificationListenerService\"/>\n    </intent-filter>\n</service>\n```\n\n然后需要继承NotificationListenerService实现两个方法\n\n```java\n/**\n * 监听系统通知，需要用户手动开启权限，那么该进程可以不死\n */\n@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\npublic class MyListenerService extends NotificationListenerService {\n    @Override\n    public void onNotificationPosted(StatusBarNotification sbn) {\n    }\n\n    @Override\n    public void onNotificationRemoved(StatusBarNotification sbn) {\n    }\n}\n```\n\n方法中什么都不用实现，MyListenerService所在的进程就拥有了跟NotificationListenerService一样的权限。可以试下手动强制停止进程会发现怎么都结束不掉，强制停止的按钮一直可以点击。可以使用\n```\nadb shell ps | grep ***\n```\n命令查看进程是否存活。\n\n```java\ncat /proc/12869/oom_adj\n0\n```\n查看进程的oom_adj的值为0，那么我们知道在灰色保活手段上基本就是提高oom_adj的值，越小越不容易被杀死，这种方法一步到位。\n\n那么怎么应用到我们自己的service中呢？很简单，将service跟MyListenerService运行在同一个进程就可以了。\n\n```java\n<service\n    android:name=\".service.StepCounterService\"\n    android:exported=\"true\"\n    android:process=\":pedometer\">\n</service>\n```\n\n这样基本就可以保证service所在的进程不被杀死了。当然，如果ROM厂商在系统级别拦截掉了，这种方法也会无效了。\n\n# 总结\n\n如果要用这种方法进程保活，那么你的app肯定是有显示通知栏的通知，不然用户谁这么傻去给你开这么权限呢。其次，显示通知栏消息就是前台进程了，用户始终可以看到，再配合service自启的几种方法，基本就可以保证我们的进程不死了。当然，这种方法也不能说绝对管用，在深度定制面前，一切都是渣渣。验证下来，魅族基本都好用，小米4c不太好用，小米其他机型没有测试。\n\n# 参考\n\n[论Android应用进程长存的可行性][1]\n[关于 Android 进程保活，你所需要知道的一切][2]\n\n\n  [1]: http://blog.csdn.net/aigestudio/article/details/51348408\n  [2]: http://www.jianshu.com/p/63aafe3c12af#","source":"_posts/Android进程保活之绑定系统服务.md","raw":"---\ntitle: Android进程保活之绑定系统服务\ndate: 2016-07-24 20:25:32\ntags: [Android, 进程保活]\n---\n\n# 进程保活\n\n有些业务需要service在后台持续的运行，所以就要有后台保活机制，包括lowMemory防杀和自启。\n\n## 防杀机制\n\n基本就是提高进程优先级，保证在低内存时进程不被有限杀死，常用的方法就是利用系统bug提高进程优先级，灰色保活手段。\n\n## 后台自启\n\n大概包括\n\n - Receiver拉起\n - AlarmManager拉起\n - 双进程互相守护\n - 利用推送SDK拉起进程\n \n以上说的这几种是常用的方法，对于原生和没有深度定制的ROM有一定作用，但是对于像小米、魅族等这类深度定制的系统来说效果不是很好。\n\n## 绑定系统服务\n\n系统提供一些系统级的Service，比如AccessibilityService辅助服务、NotificationListenerService用于监听通知消息。这篇文章主要讲下怎样利用NotificationListenerService用于监听通知消息实现进程保活。\n\n首先，如果想使用系统service，必须要用户手动点开权限。我们可以添加一个设置的入口直接跳到系统设置通知权限的界面，显示提示用户需要开启权限。\n\n```java\n    public static void goNLPermission(Context context) {\n        try {\n            Intent intent = new Intent(\"android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS\");\n            context.startActivity(intent);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n```\n\n界面就不截图了，然后我们app中要有一个权限的状态检查用于提示用户是否开启了通知显示权。\n\n```java\n/**\n * 检查通知使用权\n */\npublic static boolean checkNotificationPermission(Context context) {\n    String pkg = context.getPackageName();\n    String flat = Settings.Secure.getString(context.getContentResolver(), \"enabled_notification_listeners\");\n    boolean enabled = flat != null && flat.contains(pkg);\n    return enabled;\n}\n```\n\n注册，声明运行在com.package.pedometer进程中\n\n```java\n<service\n    android:name=\".service.MyListenerService\"\n    android:permission=\"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE\"\n    android:process=\":pedometer\">\n    <intent-filter>\n        <action android:name=\"android.service.notification.NotificationListenerService\"/>\n    </intent-filter>\n</service>\n```\n\n然后需要继承NotificationListenerService实现两个方法\n\n```java\n/**\n * 监听系统通知，需要用户手动开启权限，那么该进程可以不死\n */\n@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2)\npublic class MyListenerService extends NotificationListenerService {\n    @Override\n    public void onNotificationPosted(StatusBarNotification sbn) {\n    }\n\n    @Override\n    public void onNotificationRemoved(StatusBarNotification sbn) {\n    }\n}\n```\n\n方法中什么都不用实现，MyListenerService所在的进程就拥有了跟NotificationListenerService一样的权限。可以试下手动强制停止进程会发现怎么都结束不掉，强制停止的按钮一直可以点击。可以使用\n```\nadb shell ps | grep ***\n```\n命令查看进程是否存活。\n\n```java\ncat /proc/12869/oom_adj\n0\n```\n查看进程的oom_adj的值为0，那么我们知道在灰色保活手段上基本就是提高oom_adj的值，越小越不容易被杀死，这种方法一步到位。\n\n那么怎么应用到我们自己的service中呢？很简单，将service跟MyListenerService运行在同一个进程就可以了。\n\n```java\n<service\n    android:name=\".service.StepCounterService\"\n    android:exported=\"true\"\n    android:process=\":pedometer\">\n</service>\n```\n\n这样基本就可以保证service所在的进程不被杀死了。当然，如果ROM厂商在系统级别拦截掉了，这种方法也会无效了。\n\n# 总结\n\n如果要用这种方法进程保活，那么你的app肯定是有显示通知栏的通知，不然用户谁这么傻去给你开这么权限呢。其次，显示通知栏消息就是前台进程了，用户始终可以看到，再配合service自启的几种方法，基本就可以保证我们的进程不死了。当然，这种方法也不能说绝对管用，在深度定制面前，一切都是渣渣。验证下来，魅族基本都好用，小米4c不太好用，小米其他机型没有测试。\n\n# 参考\n\n[论Android应用进程长存的可行性][1]\n[关于 Android 进程保活，你所需要知道的一切][2]\n\n\n  [1]: http://blog.csdn.net/aigestudio/article/details/51348408\n  [2]: http://www.jianshu.com/p/63aafe3c12af#","slug":"Android进程保活之绑定系统服务","published":1,"updated":"2016-07-24T13:23:59.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif7l0020whs6vjcdry7g"},{"title":"Android自定义View之刻度尺","date":"2016-05-15T08:23:43.000Z","_content":"\n\n# 背景\n\n项目中之前用的纵向滚轮用于选择身高体重之类的需求，新版设计要求用横向刻度尺控件来实现，效果图，上面的字不在刻度尺范围内，是一个``TextView``。\n\n![刻度尺](http://7xs23g.com1.z0.glb.clouddn.com/ruler)\n\n自定义控件对于Android开发者来说是必备技能，这篇文章就不讲自定义View的基础知识了，主要谈谈绘制逻辑。\n\n# 实现\n\n遵循自定义View的开发流程，``onMeasure()`` --> ``onSizeChanged()`` --> ``onLayout()`` --> ``onDraw()``。由于我们要自定义的是View而不是ViewGroup，所以onLayout()就不用实现了。\n\n## onMeasure() 测量\n\n``onMeasure()``用于测量``View``的大小，``View``的大小不仅由自身决定，同时也受父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。刻度尺``View``左右是满屏的，偷个懒宽度就不适配了，只做高度测试就好了。高度包括长刻度的高度，加上字和底部间距\n\n```java\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));\n    }\n    \n    private int measureHeight(int heightMeasure) {\n        int measureMode = View.MeasureSpec.getMode(heightMeasure);\n        int measureSize = View.MeasureSpec.getSize(heightMeasure);\n        int result = (int) (bottomPadding + longLineHeight * 2);\n        switch (measureMode) {\n            case View.MeasureSpec.EXACTLY:\n                result = Math.max(result, measureSize);\n                break;\n            case View.MeasureSpec.AT_MOST:\n                result = Math.min(result, measureSize);\n                break;\n            default:\n                break;\n        }\n        height = result;\n        return result;\n    }\n```\n\n## onDraw() 绘制\n\n```java\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.setDrawFilter(pfdf);\n        drawBg(canvas);\n        drawIndicator(canvas);\n        drawRuler(canvas);\n    }\n```\n\n绘制做了三件事情：\n\n1. 绘制背景色\n2. 绘制指示器\n3. 绘制刻度\n\n只看下怎么画刻度，难点在于怎么确定刻度的坐标。首先高度的坐标是一样的，刻度指示器是在屏幕正中，指示某个值，那么该刻度值的x坐标就是确定的。根据这个值去画其他坐标，包括长刻度和短刻度。\n\n首先要确定每个长刻度（和短刻度，如果有的话）的坐标宽度和单位，确定基础单位和基础单位宽度（如果有短刻度以短刻度为基础单位）。那么\n\n```\n第i个刻度x坐标 = 中间刻度x坐标 + i * 基础单位宽度\n```\n\n其中i的取值范围在正负屏幕可绘制多少个基础单位，第0位就是屏幕正中的刻度值。以该值为基础一次画出可以在屏幕中显示的剩余刻度，如果是长刻度单位的整数倍就画长刻度，刻度值只在长刻度下画。\n这样就有一个问题，正中刻度值必须是可以整除基础单位，比如，长刻度 = 1，中间两个短刻度，这样基础单位值就是0.5，currentValue = 0.3，那么下一个值就是0.8，但是这样显示并不是我们想要的，我们想要0、0.5、1、1.5这样的值。所以就是在初始化的时候格式化这些值，使得所有可显示的值都可以整除基础单位值，也就是余数为0。\n由于使用float计算，所以要用到float精确计算，否则取余操作会出现不等于0的误差导致画不出长刻度。\n\n```java\n\t//精度支持2位小数\n    private float format(float vallue) {\n        float result = 0;\n        if (getBaseUnit() < 0.1) {\n            //0.01\n            result = ArithmeticUtil.round(vallue, 2);\n            //float精确计算 取余\n            if (ArithmeticUtil.remainder(result, getBaseUnit(), 2) != 0) {\n                result += 0.01;\n                result = format(result);\n            }\n        } else if (getBaseUnit() < 1) {\n            //0.1\n            result = ArithmeticUtil.round(vallue, 1);\n            if (ArithmeticUtil.remainder(result, getBaseUnit(), 1) != 0) {\n                result += 0.1;\n                result = format(result);\n            }\n        } else if (getBaseUnit() < 10) {\n            //1\n            result = ArithmeticUtil.round(vallue, 0);\n            if (ArithmeticUtil.remainder(result, getBaseUnit(), 0) != 0) {\n                result += 1;\n                result = format(result);\n            }\n        }\n        return result;\n    }\n```\n\n## 处理滑动操作\n\n滑动处理比较简单，以初始化为基础，每次move操作累加x坐标，以此值绘制偏移量，停止滑动时以基础单位宽度为基准四舍五入，开始动画滑动到相应的刻度值上。\n主要方法\n\n```java\nprivate void drawRuler(Canvas canvas) {\n        if (moveX < maxRightOffset) {\n            moveX = maxRightOffset;\n        }\n        if (moveX > maxLeftOffset) {\n            moveX = maxLeftOffset;\n        }\n        int halfCount = (int) (width / 2 / getBaseUnitWidth());\n        float moveValue = (int) (moveX / getBaseUnitWidth()) * getBaseUnit();\n        currentValue = originValue - moveValue;\n        //剩余偏移量\n        offset = moveX - (int) (moveX / getBaseUnitWidth()) * getBaseUnitWidth();\n\n        for (int i = -halfCount - 1; i <= halfCount + 1; i++) {\n            float value = ArithmeticUtil.addWithScale(currentValue, ArithmeticUtil.mulWithScale(i, getBaseUnit(), 2), 2);\n            //只绘出范围内的图形\n            if (value >= startValue && value <= endValue) {\n                //画长的刻度\n                float startx = width / 2 + offset + i * getBaseUnitWidth();\n                if (startx > 0 && startx < width) {\n                    if (microUnitCount != 0) {\n                        if (ArithmeticUtil.remainder(value, unit, 2) == 0) {\n                            drawLongLine(canvas, i, value);\n                        } else {\n                            //画短线\n                            drawShortLine(canvas, i);\n                        }\n                    } else {\n                        //画长线\n                        drawLongLine(canvas, i, value);\n                    }\n                }\n            }\n        }\n\t\t//通知结果\n        notifyValueChange();\n    }\n```\n\n关于刻度的单位，需要给出长刻度单位和中间的短刻度个数，这样中间的短刻度单位就确定了，所以理论上不管中间有几个短刻度计算都是一样的。我在里面封装了三个常用的，2、5、10三种。\n支持的``styleable``\n\n```java\n<declare-styleable name=\"BooheeRulerView\">\n    <attr name=\"ruler_bg_color\" format=\"color|reference\"/>\n    <attr name=\"ruler_line_color\" format=\"color|reference\"/>\n    <attr name=\"ruler_text_size\" format=\"dimension\"/>\n    <attr name=\"ruler_text_color\" format=\"color|reference\"/>\n    <attr name=\"ruler_width_per_unit\" format=\"dimension\"/>\n</declare-styleable>\n```\n\n![效果图](http://7xs23g.com1.z0.glb.clouddn.com/ruler_gif.gif)\n\n![image](http://7xs23g.com1.z0.glb.clouddn.com/ruler1.gif)\n\n[代码在这里](https://gist.github.com/w4lle/2f676f0f2005f6a24ca6c122b7e214b4)\n\n# 总结\n\n实现的效果比较单一，没有做太多的扩展，有时间再完善下。\n\n> 转载请注明地址 w4lle.github.io","source":"_posts/Android自定义View之刻度尺.md","raw":"---\ntitle: Android自定义View之刻度尺\ndate: 2016-05-15 16:23:43\ntags: [自定义View]\n---\n\n\n# 背景\n\n项目中之前用的纵向滚轮用于选择身高体重之类的需求，新版设计要求用横向刻度尺控件来实现，效果图，上面的字不在刻度尺范围内，是一个``TextView``。\n\n![刻度尺](http://7xs23g.com1.z0.glb.clouddn.com/ruler)\n\n自定义控件对于Android开发者来说是必备技能，这篇文章就不讲自定义View的基础知识了，主要谈谈绘制逻辑。\n\n# 实现\n\n遵循自定义View的开发流程，``onMeasure()`` --> ``onSizeChanged()`` --> ``onLayout()`` --> ``onDraw()``。由于我们要自定义的是View而不是ViewGroup，所以onLayout()就不用实现了。\n\n## onMeasure() 测量\n\n``onMeasure()``用于测量``View``的大小，``View``的大小不仅由自身决定，同时也受父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。刻度尺``View``左右是满屏的，偷个懒宽度就不适配了，只做高度测试就好了。高度包括长刻度的高度，加上字和底部间距\n\n```java\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        setMeasuredDimension(measureWidth(widthMeasureSpec), measureHeight(heightMeasureSpec));\n    }\n    \n    private int measureHeight(int heightMeasure) {\n        int measureMode = View.MeasureSpec.getMode(heightMeasure);\n        int measureSize = View.MeasureSpec.getSize(heightMeasure);\n        int result = (int) (bottomPadding + longLineHeight * 2);\n        switch (measureMode) {\n            case View.MeasureSpec.EXACTLY:\n                result = Math.max(result, measureSize);\n                break;\n            case View.MeasureSpec.AT_MOST:\n                result = Math.min(result, measureSize);\n                break;\n            default:\n                break;\n        }\n        height = result;\n        return result;\n    }\n```\n\n## onDraw() 绘制\n\n```java\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        canvas.setDrawFilter(pfdf);\n        drawBg(canvas);\n        drawIndicator(canvas);\n        drawRuler(canvas);\n    }\n```\n\n绘制做了三件事情：\n\n1. 绘制背景色\n2. 绘制指示器\n3. 绘制刻度\n\n只看下怎么画刻度，难点在于怎么确定刻度的坐标。首先高度的坐标是一样的，刻度指示器是在屏幕正中，指示某个值，那么该刻度值的x坐标就是确定的。根据这个值去画其他坐标，包括长刻度和短刻度。\n\n首先要确定每个长刻度（和短刻度，如果有的话）的坐标宽度和单位，确定基础单位和基础单位宽度（如果有短刻度以短刻度为基础单位）。那么\n\n```\n第i个刻度x坐标 = 中间刻度x坐标 + i * 基础单位宽度\n```\n\n其中i的取值范围在正负屏幕可绘制多少个基础单位，第0位就是屏幕正中的刻度值。以该值为基础一次画出可以在屏幕中显示的剩余刻度，如果是长刻度单位的整数倍就画长刻度，刻度值只在长刻度下画。\n这样就有一个问题，正中刻度值必须是可以整除基础单位，比如，长刻度 = 1，中间两个短刻度，这样基础单位值就是0.5，currentValue = 0.3，那么下一个值就是0.8，但是这样显示并不是我们想要的，我们想要0、0.5、1、1.5这样的值。所以就是在初始化的时候格式化这些值，使得所有可显示的值都可以整除基础单位值，也就是余数为0。\n由于使用float计算，所以要用到float精确计算，否则取余操作会出现不等于0的误差导致画不出长刻度。\n\n```java\n\t//精度支持2位小数\n    private float format(float vallue) {\n        float result = 0;\n        if (getBaseUnit() < 0.1) {\n            //0.01\n            result = ArithmeticUtil.round(vallue, 2);\n            //float精确计算 取余\n            if (ArithmeticUtil.remainder(result, getBaseUnit(), 2) != 0) {\n                result += 0.01;\n                result = format(result);\n            }\n        } else if (getBaseUnit() < 1) {\n            //0.1\n            result = ArithmeticUtil.round(vallue, 1);\n            if (ArithmeticUtil.remainder(result, getBaseUnit(), 1) != 0) {\n                result += 0.1;\n                result = format(result);\n            }\n        } else if (getBaseUnit() < 10) {\n            //1\n            result = ArithmeticUtil.round(vallue, 0);\n            if (ArithmeticUtil.remainder(result, getBaseUnit(), 0) != 0) {\n                result += 1;\n                result = format(result);\n            }\n        }\n        return result;\n    }\n```\n\n## 处理滑动操作\n\n滑动处理比较简单，以初始化为基础，每次move操作累加x坐标，以此值绘制偏移量，停止滑动时以基础单位宽度为基准四舍五入，开始动画滑动到相应的刻度值上。\n主要方法\n\n```java\nprivate void drawRuler(Canvas canvas) {\n        if (moveX < maxRightOffset) {\n            moveX = maxRightOffset;\n        }\n        if (moveX > maxLeftOffset) {\n            moveX = maxLeftOffset;\n        }\n        int halfCount = (int) (width / 2 / getBaseUnitWidth());\n        float moveValue = (int) (moveX / getBaseUnitWidth()) * getBaseUnit();\n        currentValue = originValue - moveValue;\n        //剩余偏移量\n        offset = moveX - (int) (moveX / getBaseUnitWidth()) * getBaseUnitWidth();\n\n        for (int i = -halfCount - 1; i <= halfCount + 1; i++) {\n            float value = ArithmeticUtil.addWithScale(currentValue, ArithmeticUtil.mulWithScale(i, getBaseUnit(), 2), 2);\n            //只绘出范围内的图形\n            if (value >= startValue && value <= endValue) {\n                //画长的刻度\n                float startx = width / 2 + offset + i * getBaseUnitWidth();\n                if (startx > 0 && startx < width) {\n                    if (microUnitCount != 0) {\n                        if (ArithmeticUtil.remainder(value, unit, 2) == 0) {\n                            drawLongLine(canvas, i, value);\n                        } else {\n                            //画短线\n                            drawShortLine(canvas, i);\n                        }\n                    } else {\n                        //画长线\n                        drawLongLine(canvas, i, value);\n                    }\n                }\n            }\n        }\n\t\t//通知结果\n        notifyValueChange();\n    }\n```\n\n关于刻度的单位，需要给出长刻度单位和中间的短刻度个数，这样中间的短刻度单位就确定了，所以理论上不管中间有几个短刻度计算都是一样的。我在里面封装了三个常用的，2、5、10三种。\n支持的``styleable``\n\n```java\n<declare-styleable name=\"BooheeRulerView\">\n    <attr name=\"ruler_bg_color\" format=\"color|reference\"/>\n    <attr name=\"ruler_line_color\" format=\"color|reference\"/>\n    <attr name=\"ruler_text_size\" format=\"dimension\"/>\n    <attr name=\"ruler_text_color\" format=\"color|reference\"/>\n    <attr name=\"ruler_width_per_unit\" format=\"dimension\"/>\n</declare-styleable>\n```\n\n![效果图](http://7xs23g.com1.z0.glb.clouddn.com/ruler_gif.gif)\n\n![image](http://7xs23g.com1.z0.glb.clouddn.com/ruler1.gif)\n\n[代码在这里](https://gist.github.com/w4lle/2f676f0f2005f6a24ca6c122b7e214b4)\n\n# 总结\n\n实现的效果比较单一，没有做太多的扩展，有时间再完善下。\n\n> 转载请注明地址 w4lle.github.io","slug":"Android自定义View之刻度尺","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif7n0024whs6274uxdax"},{"title":"Android热补丁之AndFix原理解析","date":"2016-03-03T06:43:44.000Z","_content":"\n# 背景\n\n2015年下半年开源了很多Android热更新的项目，其中大部分是以QQ空间技术团队写的那篇[文章](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a&scene=1&srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect)为依据写出的基于``multidex``的热更新框架，包括[Nuwa](https://github.com/jasonross/Nuwa)、[HotFix](https://github.com/dodola/HotFix)、[DroidFix](https://github.com/bunnyblue/DroidFix)等；还有这篇文章的主角，阿里开源的[AndFix](https://github.com/alibaba/AndFix)。\n\n在这之前，热补丁框架并没有那么火，原因无非就是要么用起来太重，要么不支持ART。比如携程出品的[DynamicAPK](https://github.com/CtripMobile/DynamicAPK),这种框架是为了解决平台级的产品相关业务开发之间的解耦，热补丁只是其附属功能，对于量级没有那么大的项目，没有必要采用这种很重的框架。另外就是基于阿里出品的基于[Xposed](https://github.com/rovo89/Xposed)的AOP框架[dexposed](https://github.com/alibaba/dexposed)，剥离掉``Xposed``的root部分功能，主要应该与AOP编程、插桩 (如测试、性能监控等)、在线热补丁、SDK hooking等，用起来比较重并且不支持``ART``。\n众多的热补丁框架为开发者带来了福利，不用发版本就可以紧急修复线上版本的bug。\n\n这篇文章主要是分析AndFix的实现原理。\n\n# AndFix\n\n## 使用方法\n\n引用\n\n```gradle\ndependencies {\n    compile 'com.alipay.euler:andfix:0.3.1@aar'\n}\n```\n初始化\n\n```java\npatchManager = new PatchManager(context);\npatchManager.init(appversion);//current version\n```\n加载补丁，尽量在``Application``的``onCreate``方法中使用\n\n```java\npatchManager.loadPatch();\n```\n应用补丁\n\n```java\npatchManager.addPatch(path);//path of the patch file that was downloaded\n```\n项目中提供了一个生成补丁(后缀为``.apatch``)的工具``apkpatch``\n用法：\n\n```shell\nusage: apkpatch -f <new> -t <old> -o <output> -k <keystore> -p <***> -a <alias> -e <***>\n -a,--alias <alias>     keystore entry alias.\n -e,--epassword <***>   keystore entry password.\n -f,--from <loc>        new Apk file path.\n -k,--keystore <loc>    keystore path.\n -n,--name <name>       patch name.\n -o,--out <dir>         output dir.\n -p,--kpassword <***>   keystore password.\n -t,--to <loc>          old Apk file path.\n ```\n 如下生成补丁文件\n \n ```shell\n./apkpatch.sh -f new.apk -t old.apk -o ./ -k ../one.keystore -p *** -a one -e ***\n```\n## apkPatch工具解析\n\n``apkpatch``是一个jar包，并没有开源出来，我们可以用``JD-GUI``或者``procyon``来看下它的源码,版本1.0.3。\n首先找到``Main.class``，位于``com.euler.patch``包下，找到``Main()``方法\n\n```java\npublic static void main(final String[] args) {\n        .....\n        //根据上面命令输入拿到参数        \n       final ApkPatch apkPatch = new ApkPatch(from, to, name, out, keystore, password, alias, entry);\n       apkPatch.doPatch();\n  }\n```\n``ApkPatch``的``doPatch``方法\n\n```java\npublic void doPatch() {\n        try {\n        //生成smali文件夹\n            final File smaliDir = new File(this.out, \"smali\");\n            if (!smaliDir.exists()) {\n                smaliDir.mkdir();\n            }\n            //新建diff.dex文件\n            final File dexFile = new File(this.out, \"diff.dex\");\n            //新建diff.apatch文件\n            final File outFile = new File(this.out, \"diff.apatch\");\n            //第一步，拿到两个apk文件对比，对比信息写入DiffInfo\n            final DiffInfo info = new DexDiffer().diff(this.from, this.to);\n            //第二步，将对比结果info写入.smali文件中，然后打包成dex文件\n            this.classes = buildCode(smaliDir, dexFile, info);\n            //第三步，将生成的dex文件写入jar包，并根据输入的签名信息进行签名,生成diff.apatch文件\n            this.build(outFile, dexFile);\n            //第四步，将diff.apatch文件重命名，结束\n            this.release(this.out, dexFile, outFile);\n        }\n        catch (Exception e2) {\n            e2.printStackTrace();\n        }\n    }\n```\n\n以上可以简单描述为两步\n\n1. 对比apk文件，得到需要的信息\n2. 将结果打包为apatch文件\n\n### 对比apk文件\n\n``DexDiffer().diff()``方法\n\n```java\npublic DiffInfo diff(final File newFile, final File oldFile) throws IOException {\n\t\t//提取新apk的dex文件\n        final DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, true);\n        //提取旧apk的dex文件\n        final DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19, true);\n        final DiffInfo info = DiffInfo.getInstance();\n        boolean contains = false;\n        for (final DexBackedClassDef newClazz : newDexFile.getClasses()) {\n            final Set<? extends DexBackedClassDef> oldclasses = oldDexFile.getClasses();\n            for (final DexBackedClassDef oldClazz : oldclasses) {\n            \t //对比相同的方法,存储为修改的方法\n                if (newClazz.equals(oldClazz)) {\n                \t //对比class文件的变量\n                    this.compareField(newClazz, oldClazz, info);\n                    //对比class文件的方法，如果同一个类中没有相同的方法\n                    //则判定为新增方法\n                    this.compareMethod(newClazz, oldClazz, info);\n                    contains = true;\n                    break;\n                }\n            }\n            if (!contains) {\n            \t //否则是新增的类\n                info.addAddedClasses(newClazz);\n            }\n        }\n        //返回包含diff信息的DiffInfo对象\n        return info;\n    }\n```\n其原理就是根据 ``dex diff``得到两个apk文件的差别信息。对比方法过程中对比两个``dex``文件中同时存在的方法，如果方法实现不同则**存储为修改过的方法**；如果方法名不同，**存储为新增的方法**，也就是说**AndFix支持增加新的方法**，这一点已经测试证明。另外，在比较``Field``的时候有如下代码\n\n```java\n  public void addAddedFields(DexBackedField field) {\n    addedFields.add(field);\n    throw new RuntimeException(\"can,t add new Field:\" + \n      field.getName() + \"(\" + field.getType() + \"), \" + \"in class :\" + \n      field.getDefiningClass());\n  }\n  \n  public void addModifiedFields(DexBackedField field) {\n    modifiedFields.add(field);\n    throw new RuntimeException(\"can,t modified Field:\" + \n      field.getName() + \"(\" + field.getType() + \"), \" + \"in class :\" + \n      field.getDefiningClass());\n  }\n```\n也就是说**``AndFix``不支持增加成员变量，但是支持在新增方法中增加的局部变量**。**也不支持修改成员变量**。已经测试证明这一点。\n还有一个地方要注意，就是提取``dex``文件的地方，在``DexFileFactory``类中\n\n```java\npublic static DexBackedDexFile loadDexFile(File dexFile, int api, boolean experimental) throws IOException\n  {\n    return loadDexFile(dexFile, \"classes.dex\", new Opcodes(api, experimental));\n  }\n```\n可以看到，只提取出了``classes.dex``这个文件，所以源生工具并**不支持multidex**，如果使用了``multidex``方案，并且修复的类不在同一个``dex``文件中，那么补丁就不会生效。所以这里并不像作者在issue中提到的支持``multidex``那样，不过我们可以通过``JavaAssist``工具**修改``apkpatch``这个jar包，来达到支持multidex的目的**，后续我们会讲到。\n\n### 将对比结果打包\n\n这一步我们重点关注拿到``DiffInfo``后将其存入``smali``文件的过程\n``ApkPatch.buildCode()``方法\n\n```java\nprivate static Set<String> buildCode(final File smaliDir, final File dexFile, final DiffInfo info) throws IOException, RecognitionException, FileNotFoundException {\n        final ClassFileNameHandler outFileNameHandler = new ClassFileNameHandler(smaliDir, \".smali\");\n        final ClassFileNameHandler inFileNameHandler = new ClassFileNameHandler(smaliDir, \".smali\");\n        final DexBuilder dexBuilder = DexBuilder.makeDexBuilder();\n        for (final DexBackedClassDef classDef : list) {\n            final String className = classDef.getType();\n            baksmali.disassembleClass(classDef, outFileNameHandler, options);\n            final File smaliFile = inFileNameHandler.getUniqueFilenameForClass(TypeGenUtil.newType(className));\n            classes.add(TypeGenUtil.newType(className).substring(1, TypeGenUtil.newType(className).length() - 1).replace('/', '.'));\n            SmaliMod.assembleSmaliFile(smaliFile, dexBuilder, true, true);\n        }\n        dexBuilder.writeTo(new FileDataStore(dexFile));\n        return classes;\n    }\n```\n将上一步得到的``diff``信息写入``smali``文件，并且生成``diff.dex``文件。``smali``文件的命名以``_CF.smali``结尾，并且在修改的地方用自定义的**Annotation**(``MethodReplace``)标注，用于在替换之前查找修复的变量或方法，如下。\n\n```smali\n.method private getUserProfile()V\n    .locals 2\n    .annotation runtime Lcom/alipay/euler/andfix/annotation/MethodReplace;\n        clazz = \"com.boohee.account.UserProfileActivity\"\n        method = \"getUserProfile\"\n    .end annotation\n\n```\n在打包生成的``diff.dex``文件中，反编译出来可以看到这段代码\n\n```java\n//生成的注解\n@MethodReplace(clazz=\"com.boohee.account.UserProfileActivity\", method=\"onCreate\")\n  public void onCreate(Bundle paramBundle)\n  {\n    super.onCreate(paramBundle);\n    getUserProfile();\n    addPatch();\n  }\n```\n\n然后就是签名，打包，加密的流程，就不具体分析了。注意，``apkPatch``在生成``.apatch``补丁文件的时候会加入签名信息，并且会进行加密操作，在应用补丁的时候会验证签名信息是否正确。\n\n\n## 打补丁原理\n\n### Java层\n\n``PatchManager.init()``方法\n\n```java\npublic void init(String appVersion) {\n\t\tSharedPreferences sp = mContext.getSharedPreferences(SP_NAME,\n\t\t\t\tContext.MODE_PRIVATE);\n\t\tString ver = sp.getString(SP_VERSION, null);\n\t\t//根据版本号加载补丁文件，版本号不同清空缓存目录\n\t\tif (ver == null || !ver.equalsIgnoreCase(appVersion)) {\n\t\t\tcleanPatch();\n\t\t\tsp.edit().putString(SP_VERSION, appVersion).commit();\n\t\t} else {\n\t\t\tinitPatchs();\n\t\t}\n\t}\n\n\tprivate void initPatchs() {\n\t\t// 缓存目录data/data/package/file/apatch/会缓存补丁文件\n\t\t// 即使原目录被删除也可以打补丁\n\t\tFile[] files = mPatchDir.listFiles();\n\t\tfor (File file : files) {\n\t\t\taddPatch(file);\n\t\t}\n\t}\n```\n\n``addPatch``和``loadPatch()``方法\n\n```java\n\tpublic void addPatch(String path) throws IOException {\n\t\t...\n\t\tFileUtil.copyFile(src, dest);// copy to patch's directory\n\t\tPatch patch = addPatch(dest);\n\t\tif (patch != null) {\n\t\t\tloadPatch(patch);\n\t\t}\n\t}\n\t\n\tprivate void loadPatch(Patch patch) {\n\t\tSet<String> patchNames = patch.getPatchNames();\n\t\tClassLoader cl;\n\t\tList<String> classes;\n\t\tfor (String patchName : patchNames) {\n\t\t\tif (mLoaders.containsKey(\"*\")) {\n\t\t\t\tcl = mContext.getClassLoader();\n\t\t\t} else {\n\t\t\t\tcl = mLoaders.get(patchName);\n\t\t\t}\n\t\t\tif (cl != null) {\n\t\t\t\tclasses = patch.getClasses(patchName);\n\t\t\t\tmAndFixManager.fix(patch.getFile(), cl, classes);\n\t\t\t}\n\t\t}\n\t}\n```\n\n再看下``AndFixManager``的``fix()``方法\n\t\n```java\n...\n//省略掉验证签名信息、安全检查的代码，安全方面做得很好\n...\n\nprivate void fixClass(Class<?> clazz, ClassLoader classLoader) {\n\t\t...\n\t\tfor (Method method : methods) {\n\t\t\t//还记得对比过程中生成的Annotation注解吗\n\t\t\t//这里通过注解找到需要替换掉的方法\n\t\t\tmethodReplace = method.getAnnotation(MethodReplace.class);\n\t\t\tif (methodReplace == null)\n\t\t\t\tcontinue;\n\t\t\t//标记的类\n\t\t\tclz = methodReplace.clazz();\n\t\t\t//需要替换的方法\n\t\t\tmeth = methodReplace.method();\n\t\t\tif (!isEmpty(clz) && !isEmpty(meth)) {\n\t\t\t\t//所有找到的方法，循环替换\n\t\t\t\treplaceMethod(classLoader, clz, meth, method);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static native void replaceMethod(Method dest, Method src);\n\tprivate static native void setFieldFlag(Field field);\n\n\tpublic static void addReplaceMethod(Method src, Method dest) {\n\t\ttry {\n\t\t\treplaceMethod(src, dest);\n\t\t\tinitFields(dest.getDeclaringClass());\n\t\t} catch (Throwable e) {\n\t\t\tLog.e(TAG, \"addReplaceMethod\", e);\n\t\t}\n\t}\n```\n后面就是调用``native``层的方法，写在``jni``中，打包为``.so``文件供``java``层调用。\n\n总结一下，``java``层的功能就是找到补丁文件，根据补丁中的注解找到将要替换的方法然后交给jni层去处理替换方法的操作。好了，继续往下看。\n\n### Native层\n\n在``jni``的代码中支持``Dalvik``与``ART``，那么这是怎么区分的呢?在``AndFixManager``的构造方法中有这么一句\n\n```java\nmSupport = Compat.isSupport();\n```\n\n```java\npublic static synchronized boolean isSupport() {\n\tif (isChecked)\n\t\treturn isSupport;\n\n\t\tisChecked = true;\n\t\t// not support alibaba's YunOs\n\t\t//SDK android 2.3 to android 6.0\n\t\tif (!isYunOS() && AndFix.setup() && isSupportSDKVersion()) {\n\t\t\tisSupport = true;\n\t\t}\n\treturn isSupport;\n}\n```\n\n``AndFix``的`setUp()``方法\n\n```java\npublic static boolean setup() {\n\ttry {\n\t\tfinal String vmVersion = System.getProperty(\"java.vm.version\");\n\t\t//判断是否是ART\n\t\tboolean isArt = vmVersion != null && vmVersion.startsWith(\"2\");\n\t\tint apilevel = Build.VERSION.SDK_INT;\n\t\t//这里也是native方法\n\t\treturn setup(isArt, apilevel);\n\t} catch (Exception e) {\n\t\tLog.e(TAG, \"setup\", e);\n\t\treturn false;\n\t}\n}\n```\n最后调用``setup(isArt, apilevel);``的``native``方法，在``andfix.cpp``中注册``jni``方法\n\n```c++\nstatic JNINativeMethod gMethods[] = {\n/* name, signature, funcPtr */\n{ \"setup\", \"(ZI)Z\", (void*) setup }, \n{ \"replaceMethod\",\n\t\t\"(Ljava/lang/reflect/Method;Ljava/lang/reflect/Method;)V\",(void*) replaceMethod },\n{ \"setFieldFlag\",\n\t\t\"(Ljava/lang/reflect/Field;)V\", (void*) setFieldFlag }, };\n```\n\n``native``实现\n\n```c++\nstatic jboolean setup(JNIEnv* env, jclass clazz, jboolean isart,\n\t\tjint apilevel) {\n\tisArt = isart;\n\tLOGD(\"vm is: %s , apilevel is: %i\", (isArt ? \"art\" : \"dalvik\"),\n\t\t\t(int )apilevel);\n\tif (isArt) {\n\t\treturn art_setup(env, (int) apilevel);\n\t} else {\n\t\treturn dalvik_setup(env, (int) apilevel);\n\t}\n}\n\nstatic void replaceMethod(JNIEnv* env, jclass clazz, jobject src,\n\t\tjobject dest) {\n\tif (isArt) {\n\t\tart_replaceMethod(env, src, dest);\n\t} else {\n\t\tdalvik_replaceMethod(env, src, dest);\n\t}\n}\n```\n根据上层传过来的``isArt``判断调用``Dalvik``还是``Art``的方法。\n以``Dalvik``为例,继续往下分析,代码在``dalvik_method_replace.cpp``中\n``dalvik_setup``方法\n\n```c++\nextern jboolean __attribute__ ((visibility (\"hidden\"))) dalvik_setup(\n\t\tJNIEnv* env, int apilevel) {\n\tjni_env = env;\n\tvoid* dvm_hand = dlopen(\"libdvm.so\", RTLD_NOW);\n\tif (dvm_hand) {\n\t\t...\n\t\t//使用dlsym方法将dvmCallMethod_fnPtr函数指针指向libdvm.so中的\t\t//dvmCallMethod方法，也就是说可以通过调用该函数指针执行其指向的方法\n\t\t//下面会用到dvmCallMethod_fnPtr\n\t\tdvmCallMethod_fnPtr = dvm_dlsym(dvm_hand,\n\t\t\tapilevel > 10 ?\n\t\t\t\"_Z13dvmCallMethodP6ThreadPK6MethodP6ObjectP6JValuez\" :\n\t\t\t\"dvmCallMethod\");\n\t\t...\n\t\t}\n}\n\n```\n替换方法的关键在于``native``层怎么影响内存里的java代码，我们知道``java``代码里将一个方法声明为``native``方法时,对此函数的调用就会到``native``世界里找，AndFix原理就是将一个不是native的方法修改成native方法，然后在``native``层进行替换，通过``dvmCallMethod_fnPtr``函数指针来调用``libdvm.so``中的``dvmCallMethod()``来加载替换后的新方法，达到替换方法的目的。``Jni``反射调用``java``方法时要用到一个``jmethodID``指针,这个指针在``Dalvik``里其实就是``Method``类,通过修改这个类的一些属性就可以实现在运行时将一个方法修改成``native``方法。\n\n看下``dalvik_replaceMethod(env, src, dest);``\n\n```c++\nextern void __attribute__ ((visibility (\"hidden\"))) dalvik_replaceMethod(\n\t\tJNIEnv* env, jobject src, jobject dest) {\n\tjobject clazz = env->CallObjectMethod(dest, jClassMethod);\n\tClassObject* clz = (ClassObject*) dvmDecodeIndirectRef_fnPtr(\n\t\t\tdvmThreadSelf_fnPtr(), clazz);\n\t//设置为初始化完毕\n\tclz->status = CLASS_INITIALIZED;\n\t//meth是将要被替换的方法\n\tMethod* meth = (Method*) env->FromReflectedMethod(src);\n\t//target是新的方法\n\tMethod* target = (Method*) env->FromReflectedMethod(dest);\n\tLOGD(\"dalvikMethod: %s\", meth->name);\n\n\tmeth->jniArgInfo = 0x80000000;\n\t//修改method的属性，将meth设置为native方法\n\tmeth->accessFlags |= ACC_NATIVE;\n\n\tint argsSize = dvmComputeMethodArgsSize_fnPtr(meth);\n\tif (!dvmIsStaticMethod(meth))\n\t\targsSize++;\n\tmeth->registersSize = meth->insSize = argsSize;\n\t//将新的方法信息保存到insns\n\tmeth->insns = (void*) target;\n\t//绑定桥接函数，java方法的跳转函数\n\tmeth->nativeFunc = dalvik_dispatcher;\n}\n\nstatic void dalvik_dispatcher(const u4* args, jvalue* pResult,\n\t\tconst Method* method, void* self) {\n\t\t\n\tMethod* meth = (Method*) method->insns;\n\tmeth->accessFlags = meth->accessFlags | ACC_PUBLIC;\n\tif (!dvmIsStaticMethod(meth)) {\n\t\tObject* thisObj = (Object*) args[0];\n\t\tClassObject* tmp = thisObj->clazz;\n\t\tthisObj->clazz = meth->clazz;\n\t\targArray = boxMethodArgs(meth, args + 1);\n\t\tif (dvmCheckException_fnPtr(self))\n\t\t\tgoto bail;\n\n\t\tdvmCallMethod_fnPtr(self, (Method*) jInvokeMethod,\n\t\t\t\tdvmCreateReflectMethodObject_fnPtr(meth), &result, thisObj,\n\t\t\t\targArray);\n\n\t\tthisObj->clazz = tmp;\n\t} else {\n\t\targArray = boxMethodArgs(meth, args);\n\t\tif (dvmCheckException_fnPtr(self))\n\t\t\tgoto bail;\n\n\t\tdvmCallMethod_fnPtr(self, (Method*) jInvokeMethod,\n\t\t\t\tdvmCreateReflectMethodObject_fnPtr(meth), &result, NULL,\n\t\t\t\targArray);\n\t}\n\tbail: dvmReleaseTrackedAlloc_fnPtr((Object*) argArray, self);\n}\n```\n通过``dalvik_dispatcher``这个跳转函数完成最后的替换工作，到这里就完成了两个方法的替换，有问题的方法就可以被修复后的方法取代。ART的替换方法就不讲了，原理上差别不大。\n\n## 总结\nAndFix热补丁原理就是在``native``动态替换方法``java``层的代码，通过``native``层hook ``java``层的代码。\n### 优点\n* 因为是动态的，所以不需要重启应用就可以生效\n* 支持ART与Dalvik\n* 与multidex方案相比，性能会有所提升(Multi Dex需要修改所有class的class_ispreverified标志位，导致运行时性能有所损失)\n* 支持新增加方法\n* 支持在新增方法中新增局部变量\n* 足够轻量，生成补丁文件简单\n* 安全性够高，验证签名\n\n### 缺点\n* 因为是动态的，跳过了类的初始化，设置为初始化完毕，所以对于静态方法、静态成员变量、构造方法或者class.forname()的处理可能会有问题\n* 不支持新增成员变量和修改成员变量\n* 官方apkPatch工具不支持multidex,但是可以通过修改工具来达到支持multidex的目的\n* 由于是在native层替换方法，某些缺心眼厂商可能会修改源生关键部分的native层实现，导致可能在某些特定ROM支持不够好\n\n## 参考\n* [注入安卓进程,并hook java世界的方法](http://bbs.pediy.com/showthread.php?t=186054)\n* [Hook Java的的一个改进版本](http://blog.csdn.net/l173864930/article/details/39667355)\n* [关于Android APP在线热修复bug方案的调研(一)(AndFix)](http://blog.csdn.net/xxooyc/article/details/50317455)\n* [各大热补丁方案分析和比较](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/)\n\n\n项目地址：[AndFix](https://github.com/alibaba/AndFix)，本文分析版本：[AndFix:0.3.1](https://github.com/alibaba/AndFix/tree/c68d9811bd756ee418fce761ca113376ec9c4e66)","source":"_posts/Android热补丁之AndFix原理解析.md","raw":"---\ntitle: Android热补丁之AndFix原理解析\ndate: 2016-03-03 14:43:44\ntags: [热补丁, AndFix, 源码分析]\n---\n\n# 背景\n\n2015年下半年开源了很多Android热更新的项目，其中大部分是以QQ空间技术团队写的那篇[文章](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400118620&idx=1&sn=b4fdd5055731290eef12ad0d17f39d4a&scene=1&srcid=1106Imu9ZgwybID13e7y2nEi#wechat_redirect)为依据写出的基于``multidex``的热更新框架，包括[Nuwa](https://github.com/jasonross/Nuwa)、[HotFix](https://github.com/dodola/HotFix)、[DroidFix](https://github.com/bunnyblue/DroidFix)等；还有这篇文章的主角，阿里开源的[AndFix](https://github.com/alibaba/AndFix)。\n\n在这之前，热补丁框架并没有那么火，原因无非就是要么用起来太重，要么不支持ART。比如携程出品的[DynamicAPK](https://github.com/CtripMobile/DynamicAPK),这种框架是为了解决平台级的产品相关业务开发之间的解耦，热补丁只是其附属功能，对于量级没有那么大的项目，没有必要采用这种很重的框架。另外就是基于阿里出品的基于[Xposed](https://github.com/rovo89/Xposed)的AOP框架[dexposed](https://github.com/alibaba/dexposed)，剥离掉``Xposed``的root部分功能，主要应该与AOP编程、插桩 (如测试、性能监控等)、在线热补丁、SDK hooking等，用起来比较重并且不支持``ART``。\n众多的热补丁框架为开发者带来了福利，不用发版本就可以紧急修复线上版本的bug。\n\n这篇文章主要是分析AndFix的实现原理。\n\n# AndFix\n\n## 使用方法\n\n引用\n\n```gradle\ndependencies {\n    compile 'com.alipay.euler:andfix:0.3.1@aar'\n}\n```\n初始化\n\n```java\npatchManager = new PatchManager(context);\npatchManager.init(appversion);//current version\n```\n加载补丁，尽量在``Application``的``onCreate``方法中使用\n\n```java\npatchManager.loadPatch();\n```\n应用补丁\n\n```java\npatchManager.addPatch(path);//path of the patch file that was downloaded\n```\n项目中提供了一个生成补丁(后缀为``.apatch``)的工具``apkpatch``\n用法：\n\n```shell\nusage: apkpatch -f <new> -t <old> -o <output> -k <keystore> -p <***> -a <alias> -e <***>\n -a,--alias <alias>     keystore entry alias.\n -e,--epassword <***>   keystore entry password.\n -f,--from <loc>        new Apk file path.\n -k,--keystore <loc>    keystore path.\n -n,--name <name>       patch name.\n -o,--out <dir>         output dir.\n -p,--kpassword <***>   keystore password.\n -t,--to <loc>          old Apk file path.\n ```\n 如下生成补丁文件\n \n ```shell\n./apkpatch.sh -f new.apk -t old.apk -o ./ -k ../one.keystore -p *** -a one -e ***\n```\n## apkPatch工具解析\n\n``apkpatch``是一个jar包，并没有开源出来，我们可以用``JD-GUI``或者``procyon``来看下它的源码,版本1.0.3。\n首先找到``Main.class``，位于``com.euler.patch``包下，找到``Main()``方法\n\n```java\npublic static void main(final String[] args) {\n        .....\n        //根据上面命令输入拿到参数        \n       final ApkPatch apkPatch = new ApkPatch(from, to, name, out, keystore, password, alias, entry);\n       apkPatch.doPatch();\n  }\n```\n``ApkPatch``的``doPatch``方法\n\n```java\npublic void doPatch() {\n        try {\n        //生成smali文件夹\n            final File smaliDir = new File(this.out, \"smali\");\n            if (!smaliDir.exists()) {\n                smaliDir.mkdir();\n            }\n            //新建diff.dex文件\n            final File dexFile = new File(this.out, \"diff.dex\");\n            //新建diff.apatch文件\n            final File outFile = new File(this.out, \"diff.apatch\");\n            //第一步，拿到两个apk文件对比，对比信息写入DiffInfo\n            final DiffInfo info = new DexDiffer().diff(this.from, this.to);\n            //第二步，将对比结果info写入.smali文件中，然后打包成dex文件\n            this.classes = buildCode(smaliDir, dexFile, info);\n            //第三步，将生成的dex文件写入jar包，并根据输入的签名信息进行签名,生成diff.apatch文件\n            this.build(outFile, dexFile);\n            //第四步，将diff.apatch文件重命名，结束\n            this.release(this.out, dexFile, outFile);\n        }\n        catch (Exception e2) {\n            e2.printStackTrace();\n        }\n    }\n```\n\n以上可以简单描述为两步\n\n1. 对比apk文件，得到需要的信息\n2. 将结果打包为apatch文件\n\n### 对比apk文件\n\n``DexDiffer().diff()``方法\n\n```java\npublic DiffInfo diff(final File newFile, final File oldFile) throws IOException {\n\t\t//提取新apk的dex文件\n        final DexBackedDexFile newDexFile = DexFileFactory.loadDexFile(newFile, 19, true);\n        //提取旧apk的dex文件\n        final DexBackedDexFile oldDexFile = DexFileFactory.loadDexFile(oldFile, 19, true);\n        final DiffInfo info = DiffInfo.getInstance();\n        boolean contains = false;\n        for (final DexBackedClassDef newClazz : newDexFile.getClasses()) {\n            final Set<? extends DexBackedClassDef> oldclasses = oldDexFile.getClasses();\n            for (final DexBackedClassDef oldClazz : oldclasses) {\n            \t //对比相同的方法,存储为修改的方法\n                if (newClazz.equals(oldClazz)) {\n                \t //对比class文件的变量\n                    this.compareField(newClazz, oldClazz, info);\n                    //对比class文件的方法，如果同一个类中没有相同的方法\n                    //则判定为新增方法\n                    this.compareMethod(newClazz, oldClazz, info);\n                    contains = true;\n                    break;\n                }\n            }\n            if (!contains) {\n            \t //否则是新增的类\n                info.addAddedClasses(newClazz);\n            }\n        }\n        //返回包含diff信息的DiffInfo对象\n        return info;\n    }\n```\n其原理就是根据 ``dex diff``得到两个apk文件的差别信息。对比方法过程中对比两个``dex``文件中同时存在的方法，如果方法实现不同则**存储为修改过的方法**；如果方法名不同，**存储为新增的方法**，也就是说**AndFix支持增加新的方法**，这一点已经测试证明。另外，在比较``Field``的时候有如下代码\n\n```java\n  public void addAddedFields(DexBackedField field) {\n    addedFields.add(field);\n    throw new RuntimeException(\"can,t add new Field:\" + \n      field.getName() + \"(\" + field.getType() + \"), \" + \"in class :\" + \n      field.getDefiningClass());\n  }\n  \n  public void addModifiedFields(DexBackedField field) {\n    modifiedFields.add(field);\n    throw new RuntimeException(\"can,t modified Field:\" + \n      field.getName() + \"(\" + field.getType() + \"), \" + \"in class :\" + \n      field.getDefiningClass());\n  }\n```\n也就是说**``AndFix``不支持增加成员变量，但是支持在新增方法中增加的局部变量**。**也不支持修改成员变量**。已经测试证明这一点。\n还有一个地方要注意，就是提取``dex``文件的地方，在``DexFileFactory``类中\n\n```java\npublic static DexBackedDexFile loadDexFile(File dexFile, int api, boolean experimental) throws IOException\n  {\n    return loadDexFile(dexFile, \"classes.dex\", new Opcodes(api, experimental));\n  }\n```\n可以看到，只提取出了``classes.dex``这个文件，所以源生工具并**不支持multidex**，如果使用了``multidex``方案，并且修复的类不在同一个``dex``文件中，那么补丁就不会生效。所以这里并不像作者在issue中提到的支持``multidex``那样，不过我们可以通过``JavaAssist``工具**修改``apkpatch``这个jar包，来达到支持multidex的目的**，后续我们会讲到。\n\n### 将对比结果打包\n\n这一步我们重点关注拿到``DiffInfo``后将其存入``smali``文件的过程\n``ApkPatch.buildCode()``方法\n\n```java\nprivate static Set<String> buildCode(final File smaliDir, final File dexFile, final DiffInfo info) throws IOException, RecognitionException, FileNotFoundException {\n        final ClassFileNameHandler outFileNameHandler = new ClassFileNameHandler(smaliDir, \".smali\");\n        final ClassFileNameHandler inFileNameHandler = new ClassFileNameHandler(smaliDir, \".smali\");\n        final DexBuilder dexBuilder = DexBuilder.makeDexBuilder();\n        for (final DexBackedClassDef classDef : list) {\n            final String className = classDef.getType();\n            baksmali.disassembleClass(classDef, outFileNameHandler, options);\n            final File smaliFile = inFileNameHandler.getUniqueFilenameForClass(TypeGenUtil.newType(className));\n            classes.add(TypeGenUtil.newType(className).substring(1, TypeGenUtil.newType(className).length() - 1).replace('/', '.'));\n            SmaliMod.assembleSmaliFile(smaliFile, dexBuilder, true, true);\n        }\n        dexBuilder.writeTo(new FileDataStore(dexFile));\n        return classes;\n    }\n```\n将上一步得到的``diff``信息写入``smali``文件，并且生成``diff.dex``文件。``smali``文件的命名以``_CF.smali``结尾，并且在修改的地方用自定义的**Annotation**(``MethodReplace``)标注，用于在替换之前查找修复的变量或方法，如下。\n\n```smali\n.method private getUserProfile()V\n    .locals 2\n    .annotation runtime Lcom/alipay/euler/andfix/annotation/MethodReplace;\n        clazz = \"com.boohee.account.UserProfileActivity\"\n        method = \"getUserProfile\"\n    .end annotation\n\n```\n在打包生成的``diff.dex``文件中，反编译出来可以看到这段代码\n\n```java\n//生成的注解\n@MethodReplace(clazz=\"com.boohee.account.UserProfileActivity\", method=\"onCreate\")\n  public void onCreate(Bundle paramBundle)\n  {\n    super.onCreate(paramBundle);\n    getUserProfile();\n    addPatch();\n  }\n```\n\n然后就是签名，打包，加密的流程，就不具体分析了。注意，``apkPatch``在生成``.apatch``补丁文件的时候会加入签名信息，并且会进行加密操作，在应用补丁的时候会验证签名信息是否正确。\n\n\n## 打补丁原理\n\n### Java层\n\n``PatchManager.init()``方法\n\n```java\npublic void init(String appVersion) {\n\t\tSharedPreferences sp = mContext.getSharedPreferences(SP_NAME,\n\t\t\t\tContext.MODE_PRIVATE);\n\t\tString ver = sp.getString(SP_VERSION, null);\n\t\t//根据版本号加载补丁文件，版本号不同清空缓存目录\n\t\tif (ver == null || !ver.equalsIgnoreCase(appVersion)) {\n\t\t\tcleanPatch();\n\t\t\tsp.edit().putString(SP_VERSION, appVersion).commit();\n\t\t} else {\n\t\t\tinitPatchs();\n\t\t}\n\t}\n\n\tprivate void initPatchs() {\n\t\t// 缓存目录data/data/package/file/apatch/会缓存补丁文件\n\t\t// 即使原目录被删除也可以打补丁\n\t\tFile[] files = mPatchDir.listFiles();\n\t\tfor (File file : files) {\n\t\t\taddPatch(file);\n\t\t}\n\t}\n```\n\n``addPatch``和``loadPatch()``方法\n\n```java\n\tpublic void addPatch(String path) throws IOException {\n\t\t...\n\t\tFileUtil.copyFile(src, dest);// copy to patch's directory\n\t\tPatch patch = addPatch(dest);\n\t\tif (patch != null) {\n\t\t\tloadPatch(patch);\n\t\t}\n\t}\n\t\n\tprivate void loadPatch(Patch patch) {\n\t\tSet<String> patchNames = patch.getPatchNames();\n\t\tClassLoader cl;\n\t\tList<String> classes;\n\t\tfor (String patchName : patchNames) {\n\t\t\tif (mLoaders.containsKey(\"*\")) {\n\t\t\t\tcl = mContext.getClassLoader();\n\t\t\t} else {\n\t\t\t\tcl = mLoaders.get(patchName);\n\t\t\t}\n\t\t\tif (cl != null) {\n\t\t\t\tclasses = patch.getClasses(patchName);\n\t\t\t\tmAndFixManager.fix(patch.getFile(), cl, classes);\n\t\t\t}\n\t\t}\n\t}\n```\n\n再看下``AndFixManager``的``fix()``方法\n\t\n```java\n...\n//省略掉验证签名信息、安全检查的代码，安全方面做得很好\n...\n\nprivate void fixClass(Class<?> clazz, ClassLoader classLoader) {\n\t\t...\n\t\tfor (Method method : methods) {\n\t\t\t//还记得对比过程中生成的Annotation注解吗\n\t\t\t//这里通过注解找到需要替换掉的方法\n\t\t\tmethodReplace = method.getAnnotation(MethodReplace.class);\n\t\t\tif (methodReplace == null)\n\t\t\t\tcontinue;\n\t\t\t//标记的类\n\t\t\tclz = methodReplace.clazz();\n\t\t\t//需要替换的方法\n\t\t\tmeth = methodReplace.method();\n\t\t\tif (!isEmpty(clz) && !isEmpty(meth)) {\n\t\t\t\t//所有找到的方法，循环替换\n\t\t\t\treplaceMethod(classLoader, clz, meth, method);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate static native void replaceMethod(Method dest, Method src);\n\tprivate static native void setFieldFlag(Field field);\n\n\tpublic static void addReplaceMethod(Method src, Method dest) {\n\t\ttry {\n\t\t\treplaceMethod(src, dest);\n\t\t\tinitFields(dest.getDeclaringClass());\n\t\t} catch (Throwable e) {\n\t\t\tLog.e(TAG, \"addReplaceMethod\", e);\n\t\t}\n\t}\n```\n后面就是调用``native``层的方法，写在``jni``中，打包为``.so``文件供``java``层调用。\n\n总结一下，``java``层的功能就是找到补丁文件，根据补丁中的注解找到将要替换的方法然后交给jni层去处理替换方法的操作。好了，继续往下看。\n\n### Native层\n\n在``jni``的代码中支持``Dalvik``与``ART``，那么这是怎么区分的呢?在``AndFixManager``的构造方法中有这么一句\n\n```java\nmSupport = Compat.isSupport();\n```\n\n```java\npublic static synchronized boolean isSupport() {\n\tif (isChecked)\n\t\treturn isSupport;\n\n\t\tisChecked = true;\n\t\t// not support alibaba's YunOs\n\t\t//SDK android 2.3 to android 6.0\n\t\tif (!isYunOS() && AndFix.setup() && isSupportSDKVersion()) {\n\t\t\tisSupport = true;\n\t\t}\n\treturn isSupport;\n}\n```\n\n``AndFix``的`setUp()``方法\n\n```java\npublic static boolean setup() {\n\ttry {\n\t\tfinal String vmVersion = System.getProperty(\"java.vm.version\");\n\t\t//判断是否是ART\n\t\tboolean isArt = vmVersion != null && vmVersion.startsWith(\"2\");\n\t\tint apilevel = Build.VERSION.SDK_INT;\n\t\t//这里也是native方法\n\t\treturn setup(isArt, apilevel);\n\t} catch (Exception e) {\n\t\tLog.e(TAG, \"setup\", e);\n\t\treturn false;\n\t}\n}\n```\n最后调用``setup(isArt, apilevel);``的``native``方法，在``andfix.cpp``中注册``jni``方法\n\n```c++\nstatic JNINativeMethod gMethods[] = {\n/* name, signature, funcPtr */\n{ \"setup\", \"(ZI)Z\", (void*) setup }, \n{ \"replaceMethod\",\n\t\t\"(Ljava/lang/reflect/Method;Ljava/lang/reflect/Method;)V\",(void*) replaceMethod },\n{ \"setFieldFlag\",\n\t\t\"(Ljava/lang/reflect/Field;)V\", (void*) setFieldFlag }, };\n```\n\n``native``实现\n\n```c++\nstatic jboolean setup(JNIEnv* env, jclass clazz, jboolean isart,\n\t\tjint apilevel) {\n\tisArt = isart;\n\tLOGD(\"vm is: %s , apilevel is: %i\", (isArt ? \"art\" : \"dalvik\"),\n\t\t\t(int )apilevel);\n\tif (isArt) {\n\t\treturn art_setup(env, (int) apilevel);\n\t} else {\n\t\treturn dalvik_setup(env, (int) apilevel);\n\t}\n}\n\nstatic void replaceMethod(JNIEnv* env, jclass clazz, jobject src,\n\t\tjobject dest) {\n\tif (isArt) {\n\t\tart_replaceMethod(env, src, dest);\n\t} else {\n\t\tdalvik_replaceMethod(env, src, dest);\n\t}\n}\n```\n根据上层传过来的``isArt``判断调用``Dalvik``还是``Art``的方法。\n以``Dalvik``为例,继续往下分析,代码在``dalvik_method_replace.cpp``中\n``dalvik_setup``方法\n\n```c++\nextern jboolean __attribute__ ((visibility (\"hidden\"))) dalvik_setup(\n\t\tJNIEnv* env, int apilevel) {\n\tjni_env = env;\n\tvoid* dvm_hand = dlopen(\"libdvm.so\", RTLD_NOW);\n\tif (dvm_hand) {\n\t\t...\n\t\t//使用dlsym方法将dvmCallMethod_fnPtr函数指针指向libdvm.so中的\t\t//dvmCallMethod方法，也就是说可以通过调用该函数指针执行其指向的方法\n\t\t//下面会用到dvmCallMethod_fnPtr\n\t\tdvmCallMethod_fnPtr = dvm_dlsym(dvm_hand,\n\t\t\tapilevel > 10 ?\n\t\t\t\"_Z13dvmCallMethodP6ThreadPK6MethodP6ObjectP6JValuez\" :\n\t\t\t\"dvmCallMethod\");\n\t\t...\n\t\t}\n}\n\n```\n替换方法的关键在于``native``层怎么影响内存里的java代码，我们知道``java``代码里将一个方法声明为``native``方法时,对此函数的调用就会到``native``世界里找，AndFix原理就是将一个不是native的方法修改成native方法，然后在``native``层进行替换，通过``dvmCallMethod_fnPtr``函数指针来调用``libdvm.so``中的``dvmCallMethod()``来加载替换后的新方法，达到替换方法的目的。``Jni``反射调用``java``方法时要用到一个``jmethodID``指针,这个指针在``Dalvik``里其实就是``Method``类,通过修改这个类的一些属性就可以实现在运行时将一个方法修改成``native``方法。\n\n看下``dalvik_replaceMethod(env, src, dest);``\n\n```c++\nextern void __attribute__ ((visibility (\"hidden\"))) dalvik_replaceMethod(\n\t\tJNIEnv* env, jobject src, jobject dest) {\n\tjobject clazz = env->CallObjectMethod(dest, jClassMethod);\n\tClassObject* clz = (ClassObject*) dvmDecodeIndirectRef_fnPtr(\n\t\t\tdvmThreadSelf_fnPtr(), clazz);\n\t//设置为初始化完毕\n\tclz->status = CLASS_INITIALIZED;\n\t//meth是将要被替换的方法\n\tMethod* meth = (Method*) env->FromReflectedMethod(src);\n\t//target是新的方法\n\tMethod* target = (Method*) env->FromReflectedMethod(dest);\n\tLOGD(\"dalvikMethod: %s\", meth->name);\n\n\tmeth->jniArgInfo = 0x80000000;\n\t//修改method的属性，将meth设置为native方法\n\tmeth->accessFlags |= ACC_NATIVE;\n\n\tint argsSize = dvmComputeMethodArgsSize_fnPtr(meth);\n\tif (!dvmIsStaticMethod(meth))\n\t\targsSize++;\n\tmeth->registersSize = meth->insSize = argsSize;\n\t//将新的方法信息保存到insns\n\tmeth->insns = (void*) target;\n\t//绑定桥接函数，java方法的跳转函数\n\tmeth->nativeFunc = dalvik_dispatcher;\n}\n\nstatic void dalvik_dispatcher(const u4* args, jvalue* pResult,\n\t\tconst Method* method, void* self) {\n\t\t\n\tMethod* meth = (Method*) method->insns;\n\tmeth->accessFlags = meth->accessFlags | ACC_PUBLIC;\n\tif (!dvmIsStaticMethod(meth)) {\n\t\tObject* thisObj = (Object*) args[0];\n\t\tClassObject* tmp = thisObj->clazz;\n\t\tthisObj->clazz = meth->clazz;\n\t\targArray = boxMethodArgs(meth, args + 1);\n\t\tif (dvmCheckException_fnPtr(self))\n\t\t\tgoto bail;\n\n\t\tdvmCallMethod_fnPtr(self, (Method*) jInvokeMethod,\n\t\t\t\tdvmCreateReflectMethodObject_fnPtr(meth), &result, thisObj,\n\t\t\t\targArray);\n\n\t\tthisObj->clazz = tmp;\n\t} else {\n\t\targArray = boxMethodArgs(meth, args);\n\t\tif (dvmCheckException_fnPtr(self))\n\t\t\tgoto bail;\n\n\t\tdvmCallMethod_fnPtr(self, (Method*) jInvokeMethod,\n\t\t\t\tdvmCreateReflectMethodObject_fnPtr(meth), &result, NULL,\n\t\t\t\targArray);\n\t}\n\tbail: dvmReleaseTrackedAlloc_fnPtr((Object*) argArray, self);\n}\n```\n通过``dalvik_dispatcher``这个跳转函数完成最后的替换工作，到这里就完成了两个方法的替换，有问题的方法就可以被修复后的方法取代。ART的替换方法就不讲了，原理上差别不大。\n\n## 总结\nAndFix热补丁原理就是在``native``动态替换方法``java``层的代码，通过``native``层hook ``java``层的代码。\n### 优点\n* 因为是动态的，所以不需要重启应用就可以生效\n* 支持ART与Dalvik\n* 与multidex方案相比，性能会有所提升(Multi Dex需要修改所有class的class_ispreverified标志位，导致运行时性能有所损失)\n* 支持新增加方法\n* 支持在新增方法中新增局部变量\n* 足够轻量，生成补丁文件简单\n* 安全性够高，验证签名\n\n### 缺点\n* 因为是动态的，跳过了类的初始化，设置为初始化完毕，所以对于静态方法、静态成员变量、构造方法或者class.forname()的处理可能会有问题\n* 不支持新增成员变量和修改成员变量\n* 官方apkPatch工具不支持multidex,但是可以通过修改工具来达到支持multidex的目的\n* 由于是在native层替换方法，某些缺心眼厂商可能会修改源生关键部分的native层实现，导致可能在某些特定ROM支持不够好\n\n## 参考\n* [注入安卓进程,并hook java世界的方法](http://bbs.pediy.com/showthread.php?t=186054)\n* [Hook Java的的一个改进版本](http://blog.csdn.net/l173864930/article/details/39667355)\n* [关于Android APP在线热修复bug方案的调研(一)(AndFix)](http://blog.csdn.net/xxooyc/article/details/50317455)\n* [各大热补丁方案分析和比较](http://blog.zhaiyifan.cn/2015/11/20/HotPatchCompare/)\n\n\n项目地址：[AndFix](https://github.com/alibaba/AndFix)，本文分析版本：[AndFix:0.3.1](https://github.com/alibaba/AndFix/tree/c68d9811bd756ee418fce761ca113376ec9c4e66)","slug":"Android热补丁之AndFix原理解析","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif830027whs6vb4mrwn0"},{"title":"Android关闭通知消息权限无法弹出Toast的解决方案","date":"2016-03-27T11:47:28.000Z","_content":"\n\n# 背景\n\n在之前一段时间里经常有用户反馈无法看到薄荷app弹出的消息提示，导致用户对一些使用场景感到很困惑。猜测可能是由于用户关闭了薄荷app的通知消息的权限导致的问题，测试后发现果真如此。\n\n# 原因\n\n跟踪Toast的源代码，``make``方法省略，做了一些初始化的工作，``show``方法\n\n```java\npublic void show() {\n　　if (mNextView == null) {\n　　　　throw new RuntimeException(\"setView must have been called\");\n　　}\n\n　　INotificationManager service = getService();\n　　String pkg = mContext.getPackageName();\n　　TN tn = mTN;\n　　tn.mNextView = mNextView;\n\n　　try {\n　　　　service.enqueueToast(pkg, tn, mDuration);\n　　} catch (RemoteException e) {\n　　　　// Empty\n　　}\n}\n\nstatic private INotificationManager getService() {\n    if (sService != null) {\n      return sService;\n    }\n    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(\"notification\"));\n     return sService;\n}\n```\n\n熟悉``binder``通讯的同学应该都知道，其实调用了``NotificationManagerService.service.enqueueToast``方法进入toast队列，进行相应的逻辑处理后回调给Toast中的``TN``，``TN``其实就是一个``aidl``的``stub``实现，相当于``Client``端，用来接收``Service``端发来的消息。看下``TN``中的show方法\n\n```java\npublic void handleShow() { \n\t\t\t... \n            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);  \n            mWM.removeView(mView);  \n            mWM.addView(mView, mParams);  \n            trySendAccessibilityEvent();  \n            ...\n            }  \n        }  \n```\n\n通过``WinwodManager``添加一个``view``显示提示消息。\n总结来说就是toast的显示过程通过IPC通讯由``NotificationManagerService``维护一个toast队列，然后通知给Toast中的客户端``TN``调用``WindowManager``添加view。\n那么，如果关闭通知栏消息权限，会影响``NotificationManagerService``队列的逻辑处理过程，导致不能通知``TN``显示出视图。\n\n# 解决\n\n通过上面的分析，我们可以绕过``NotificationManagerService``，我们自己维护一个toast队列，处理相关的逻辑，进行显示，定时取消。关键代码\n\n```java\n    private static void activeQueue() {\n        BooheeToast toast = mQueue.peek();\n        if (toast == null) {\n            mAtomicInteger.decrementAndGet();\n        } else {\n            mHanlder.post(toast.mShow);\n            mHanlder.postDelayed(toast.mHide, toast.mDuration);\n            mHanlder.postDelayed(mActivite, toast.mDuration);\n        }\n    }\n```\n``mQueue``维护了``Toast``的队列，队列采用``FIFO``调度，每次调用``show()``方法触发``activeQueue()``方法，从队列中取出toast进行显示，然后定时取消。\n\n# 总结\n\nGoogle把Toast视为系统级别的消息通知，其实是不合理的，在app前台可见的情况下，有些关键信息需要提供给用户，如果关闭了消息通知权限，那么用户就会看不到这些关键的提示就会很困惑，直接影响用户体验，并且在Android5.0之后在设置中就可以关闭app的消息权限，Toast作为一个系统级别的消息提示设计者真的挺缺心眼的。虽然MD中有SnackBar作为消息提示，其原理就是在当前界面找到根视图，在根视图``addView()``，达到弹出提示的目的，但是请原谅我的审美不够高，SnackBar真的很丑，并且最近Google又支持BottomSheet，两个叠加到一起，我的天，画面太美，我不敢看。还有就是必须要拿到当前的content，对于用Application的context弹出toast的方案来说适配起来修改比较麻烦。很明显，Toast就应该是app级的消息提示，我们的解决方案也正是这么做的。\n\n# 参考\n\n* 《Android开发艺术探索》第八章 理解Window和WindowManager\n* [解决小米MIUI系统上后台应用没法弹Toast的问题](http://caizhitao.com/2016/02/09/android-toast-compat/)\n* [Toast](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/widget/Toast.java)\n* [NotificationManagerService](http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java)\n","source":"_posts/Android关闭通知消息权限无法弹出Toast的问题解决方案.md","raw":"---\ntitle: Android关闭通知消息权限无法弹出Toast的解决方案\ndate: 2016-03-27 19:47:28\ntags: [Android, 通知消息权限, Toast]\n---\n\n\n# 背景\n\n在之前一段时间里经常有用户反馈无法看到薄荷app弹出的消息提示，导致用户对一些使用场景感到很困惑。猜测可能是由于用户关闭了薄荷app的通知消息的权限导致的问题，测试后发现果真如此。\n\n# 原因\n\n跟踪Toast的源代码，``make``方法省略，做了一些初始化的工作，``show``方法\n\n```java\npublic void show() {\n　　if (mNextView == null) {\n　　　　throw new RuntimeException(\"setView must have been called\");\n　　}\n\n　　INotificationManager service = getService();\n　　String pkg = mContext.getPackageName();\n　　TN tn = mTN;\n　　tn.mNextView = mNextView;\n\n　　try {\n　　　　service.enqueueToast(pkg, tn, mDuration);\n　　} catch (RemoteException e) {\n　　　　// Empty\n　　}\n}\n\nstatic private INotificationManager getService() {\n    if (sService != null) {\n      return sService;\n    }\n    sService = INotificationManager.Stub.asInterface(ServiceManager.getService(\"notification\"));\n     return sService;\n}\n```\n\n熟悉``binder``通讯的同学应该都知道，其实调用了``NotificationManagerService.service.enqueueToast``方法进入toast队列，进行相应的逻辑处理后回调给Toast中的``TN``，``TN``其实就是一个``aidl``的``stub``实现，相当于``Client``端，用来接收``Service``端发来的消息。看下``TN``中的show方法\n\n```java\npublic void handleShow() { \n\t\t\t... \n            mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);  \n            mWM.removeView(mView);  \n            mWM.addView(mView, mParams);  \n            trySendAccessibilityEvent();  \n            ...\n            }  \n        }  \n```\n\n通过``WinwodManager``添加一个``view``显示提示消息。\n总结来说就是toast的显示过程通过IPC通讯由``NotificationManagerService``维护一个toast队列，然后通知给Toast中的客户端``TN``调用``WindowManager``添加view。\n那么，如果关闭通知栏消息权限，会影响``NotificationManagerService``队列的逻辑处理过程，导致不能通知``TN``显示出视图。\n\n# 解决\n\n通过上面的分析，我们可以绕过``NotificationManagerService``，我们自己维护一个toast队列，处理相关的逻辑，进行显示，定时取消。关键代码\n\n```java\n    private static void activeQueue() {\n        BooheeToast toast = mQueue.peek();\n        if (toast == null) {\n            mAtomicInteger.decrementAndGet();\n        } else {\n            mHanlder.post(toast.mShow);\n            mHanlder.postDelayed(toast.mHide, toast.mDuration);\n            mHanlder.postDelayed(mActivite, toast.mDuration);\n        }\n    }\n```\n``mQueue``维护了``Toast``的队列，队列采用``FIFO``调度，每次调用``show()``方法触发``activeQueue()``方法，从队列中取出toast进行显示，然后定时取消。\n\n# 总结\n\nGoogle把Toast视为系统级别的消息通知，其实是不合理的，在app前台可见的情况下，有些关键信息需要提供给用户，如果关闭了消息通知权限，那么用户就会看不到这些关键的提示就会很困惑，直接影响用户体验，并且在Android5.0之后在设置中就可以关闭app的消息权限，Toast作为一个系统级别的消息提示设计者真的挺缺心眼的。虽然MD中有SnackBar作为消息提示，其原理就是在当前界面找到根视图，在根视图``addView()``，达到弹出提示的目的，但是请原谅我的审美不够高，SnackBar真的很丑，并且最近Google又支持BottomSheet，两个叠加到一起，我的天，画面太美，我不敢看。还有就是必须要拿到当前的content，对于用Application的context弹出toast的方案来说适配起来修改比较麻烦。很明显，Toast就应该是app级的消息提示，我们的解决方案也正是这么做的。\n\n# 参考\n\n* 《Android开发艺术探索》第八章 理解Window和WindowManager\n* [解决小米MIUI系统上后台应用没法弹Toast的问题](http://caizhitao.com/2016/02/09/android-toast-compat/)\n* [Toast](http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/widget/Toast.java)\n* [NotificationManagerService](http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/notification/NotificationManagerService.java)\n","slug":"Android关闭通知消息权限无法弹出Toast的问题解决方案","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif88002dwhs6cc4dmo3r"},{"title":"Android Color位移操作","date":"2016-05-22T09:53:01.000Z","_content":"\n# 背景\n\n之前项目中有个改变颜色的透明度的需求，大概的意思是滑动动态的改变透明度，但是不可以改变``View``的透明度，必须改变颜色值得透明度，功能虽然是实现了，但是代码太ugly，所以重新写了一下，复习了下``Color``的相关知识和位移的操作。\n\n# Color简介\n\n我们知道``Color``的每个颜色通道（``channel``）的组成由8位（``bit``）为一个单位，即1个字节（``byte``），10进制的取值范围0~255，我们一般用16进制表示，以``0x``开头，取值范围在0x00~0xFF。\n\nAndroid中颜色一般有两种表示方法\n\n1. rgb：每8``bit``表示rgb中的一个颜色通道。\n2. argb：相比上第一种表示方法多出8``bit``用于表示``alpha``通道\n所以Color的表示是这样的：0xffff00ff。\n\n题外话，讲到这里又想到了``Bitmap.Config``，熟悉``bitmap``操作的同学应该对此不陌生，创建``bitmap``时的配置参数。包括：\n\n1. ALPHA_8：只有一个``alpha``颜色通道，图形参数由一个字节来表示,是一种8位的位图。\n2. ARGB_4444：图形颜色通道argb分别占用4、4、4、4bit，也就是每个像素暂用2``byte``的内存空间，是一种16``bit``的视图。\n3. ARGB_8888：同上，每个像素占用4``byte``的内存空间。是一种32``bit``的视图。\n4. RGB_565：没有``alpha``颜色通道，占用16``bit``。\n所以在创建视图的时候加入使用ARGB_8888，800*480的视图，那么大概占用的空间就可以算出来了：800*400*4byte/1024=1250kb。\n\n# 实现\n\n之前说了，我们的需求是提取出``alpha``值然后改变它的值，再生成一个新的``color``，为什么说之前的那种实现方式很丑呢，看代码：\n\n```java\nif (vertical >= 0) {\n    float toolBarAlpha = vertical * 1.0f / ivTop.getHeight();\n    if (toolBarAlpha > 1) {\n        toolBarAlpha = 1;\n    } else if (toolBarAlpha < 0) {\n        toolBarAlpha = 0;\n    }\n    int tmp = (int) (0xff * toolBarAlpha);\n    String alpha = Integer.toHexString(tmp);\n    if (alpha.length() < 2) {\n        alpha = \"0\" + alpha;\n    }\n    toolBarColor = Color.parseColor(\"#\" + alpha + \"ff4c4b\");\n    ((MainActivity) getActivity()).setToolBarColor(toolBarColor);\n}\n```\n``toolBarAlpha``是一个变化系数，乘以0xff得到一个新的``alpha``值然后拼接字符串生成一个新的``color``。\n想法是好的，但是实现起来太丑陋的，现在我们提供一种更好的实现方法\n\n```java\n    public static int getColorWithAlpha(int color, float ratio) {\n        int newColor = 0;\n        int alpha = Math.round(Color.alpha(color) * ratio);\n        int r = Color.red(color);\n        int g = Color.green(color);\n        int b = Color.blue(color);\n        newColor = Color.argb(alpha, r, g, b);\n        return newColor;\n    }\n```\n\nAndroid SDK已经给我们提供了提取颜色通道的方法，直接提取就好了。而我们关注的不仅仅是好看的代码，而是怎么实现的。\n\n# Color组成\n\n先看``color``的组成代码：\n\n```java\npublic static int argb(int alpha, int red, int green, int blue) {\n        return (alpha << 24) | (red << 16) | (green << 8) | blue;\n    }\n```\n\n什么意思呢？一张图看懂\n\n![color](http://images.cnitblog.com/blog/325852/201308/12233846-b676cad0e08e4e98a5cc5c85eb78155f.png)\nr的二进制向左移动16位，r << 16，g的二进制向左移动8位，而b的二进制则不需要移位操作。如果需要``alpha``通道，那么a的二进制向左移动24位。\n\n# 提取颜色\n\n知道了怎么组成也就好容易理解提取颜色通道\n\n 1. ``blue``：不需要移位，color&0xFF，由于高位还有其余通道值，所以高位要取0 &0xFF，剩余取blue。\n 2. ``green``：右移8位，相当于移位到blue的位置，原blue已经移出，然后与0xff相，(color >> 8) & 0xFF。\n 3. ``red``：原理同上 (color >> 16) & 0xFF;\n 4. ``alpha``：由于``alpha``在最高位，``alpha``移位操作如下\n \n```java\n0xff000000,那其实二进制是\ncolor :1111  1111  0000  0000  0000  0000  0000  0000\n\ncolor >>24结果 :1111  1111  1111  1111  1111  1111  1111  1111\n\ncolor >>>24结果:0000  0000  0000  0000  0000  0000  1111  1111      \n```\n\n右移如果最高位为1那么左侧都补1，这样就导致生成的结果有问题，所以我们要用无符号右移操作，color >>> 24，右移完高位都补0，所以也不用&0xff。\n\n# 总结\n\n简单来说，``Color``都是位操作，在计算机的世界里，位移操作是最快的运算方式，并且对于内存的占用相对于基本数据类型也要有优势，比如表示状态，我们一般声明几个int值，但是有没有想过一个int类型就要占4``byte``=32``bit``，如果用位操作的话32``bit``基本就够用了，可以节省一些内存。\n\n熟练掌握位移操作对于开发效率来说也会有相应的提高。在Android的代码中也是频繁的用到位移操作运用，比如刚刚收的一些状态操作，color操作等等。\n\n# 参考\n\n* [位操作也疯狂](http://m.oschina.net/blog/104123)\n* [Color](https://developer.android.com/reference/android/graphics/Color.html)","source":"_posts/Android-Color.md","raw":"---\ntitle: Android Color位移操作\ndate: 2016-05-22 17:53:01\ntags: [Android]\n---\n\n# 背景\n\n之前项目中有个改变颜色的透明度的需求，大概的意思是滑动动态的改变透明度，但是不可以改变``View``的透明度，必须改变颜色值得透明度，功能虽然是实现了，但是代码太ugly，所以重新写了一下，复习了下``Color``的相关知识和位移的操作。\n\n# Color简介\n\n我们知道``Color``的每个颜色通道（``channel``）的组成由8位（``bit``）为一个单位，即1个字节（``byte``），10进制的取值范围0~255，我们一般用16进制表示，以``0x``开头，取值范围在0x00~0xFF。\n\nAndroid中颜色一般有两种表示方法\n\n1. rgb：每8``bit``表示rgb中的一个颜色通道。\n2. argb：相比上第一种表示方法多出8``bit``用于表示``alpha``通道\n所以Color的表示是这样的：0xffff00ff。\n\n题外话，讲到这里又想到了``Bitmap.Config``，熟悉``bitmap``操作的同学应该对此不陌生，创建``bitmap``时的配置参数。包括：\n\n1. ALPHA_8：只有一个``alpha``颜色通道，图形参数由一个字节来表示,是一种8位的位图。\n2. ARGB_4444：图形颜色通道argb分别占用4、4、4、4bit，也就是每个像素暂用2``byte``的内存空间，是一种16``bit``的视图。\n3. ARGB_8888：同上，每个像素占用4``byte``的内存空间。是一种32``bit``的视图。\n4. RGB_565：没有``alpha``颜色通道，占用16``bit``。\n所以在创建视图的时候加入使用ARGB_8888，800*480的视图，那么大概占用的空间就可以算出来了：800*400*4byte/1024=1250kb。\n\n# 实现\n\n之前说了，我们的需求是提取出``alpha``值然后改变它的值，再生成一个新的``color``，为什么说之前的那种实现方式很丑呢，看代码：\n\n```java\nif (vertical >= 0) {\n    float toolBarAlpha = vertical * 1.0f / ivTop.getHeight();\n    if (toolBarAlpha > 1) {\n        toolBarAlpha = 1;\n    } else if (toolBarAlpha < 0) {\n        toolBarAlpha = 0;\n    }\n    int tmp = (int) (0xff * toolBarAlpha);\n    String alpha = Integer.toHexString(tmp);\n    if (alpha.length() < 2) {\n        alpha = \"0\" + alpha;\n    }\n    toolBarColor = Color.parseColor(\"#\" + alpha + \"ff4c4b\");\n    ((MainActivity) getActivity()).setToolBarColor(toolBarColor);\n}\n```\n``toolBarAlpha``是一个变化系数，乘以0xff得到一个新的``alpha``值然后拼接字符串生成一个新的``color``。\n想法是好的，但是实现起来太丑陋的，现在我们提供一种更好的实现方法\n\n```java\n    public static int getColorWithAlpha(int color, float ratio) {\n        int newColor = 0;\n        int alpha = Math.round(Color.alpha(color) * ratio);\n        int r = Color.red(color);\n        int g = Color.green(color);\n        int b = Color.blue(color);\n        newColor = Color.argb(alpha, r, g, b);\n        return newColor;\n    }\n```\n\nAndroid SDK已经给我们提供了提取颜色通道的方法，直接提取就好了。而我们关注的不仅仅是好看的代码，而是怎么实现的。\n\n# Color组成\n\n先看``color``的组成代码：\n\n```java\npublic static int argb(int alpha, int red, int green, int blue) {\n        return (alpha << 24) | (red << 16) | (green << 8) | blue;\n    }\n```\n\n什么意思呢？一张图看懂\n\n![color](http://images.cnitblog.com/blog/325852/201308/12233846-b676cad0e08e4e98a5cc5c85eb78155f.png)\nr的二进制向左移动16位，r << 16，g的二进制向左移动8位，而b的二进制则不需要移位操作。如果需要``alpha``通道，那么a的二进制向左移动24位。\n\n# 提取颜色\n\n知道了怎么组成也就好容易理解提取颜色通道\n\n 1. ``blue``：不需要移位，color&0xFF，由于高位还有其余通道值，所以高位要取0 &0xFF，剩余取blue。\n 2. ``green``：右移8位，相当于移位到blue的位置，原blue已经移出，然后与0xff相，(color >> 8) & 0xFF。\n 3. ``red``：原理同上 (color >> 16) & 0xFF;\n 4. ``alpha``：由于``alpha``在最高位，``alpha``移位操作如下\n \n```java\n0xff000000,那其实二进制是\ncolor :1111  1111  0000  0000  0000  0000  0000  0000\n\ncolor >>24结果 :1111  1111  1111  1111  1111  1111  1111  1111\n\ncolor >>>24结果:0000  0000  0000  0000  0000  0000  1111  1111      \n```\n\n右移如果最高位为1那么左侧都补1，这样就导致生成的结果有问题，所以我们要用无符号右移操作，color >>> 24，右移完高位都补0，所以也不用&0xff。\n\n# 总结\n\n简单来说，``Color``都是位操作，在计算机的世界里，位移操作是最快的运算方式，并且对于内存的占用相对于基本数据类型也要有优势，比如表示状态，我们一般声明几个int值，但是有没有想过一个int类型就要占4``byte``=32``bit``，如果用位操作的话32``bit``基本就够用了，可以节省一些内存。\n\n熟练掌握位移操作对于开发效率来说也会有相应的提高。在Android的代码中也是频繁的用到位移操作运用，比如刚刚收的一些状态操作，color操作等等。\n\n# 参考\n\n* [位操作也疯狂](http://m.oschina.net/blog/104123)\n* [Color](https://developer.android.com/reference/android/graphics/Color.html)","slug":"Android-Color","published":1,"updated":"2016-06-06T10:13:15.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"civvtif8b002jwhs6825on61k"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"civvtif5k0000whs6jvlwkjkf","tag_id":"civvtif5q0001whs6xsqj7tcb","_id":"civvtif5s0004whs6lhe0iby1"},{"post_id":"civvtif5k0000whs6jvlwkjkf","tag_id":"civvtif5s0002whs6237pbq69","_id":"civvtif5t0005whs6c15i06mn"},{"post_id":"civvtif5k0000whs6jvlwkjkf","tag_id":"civvtif5s0003whs66wcdzuq0","_id":"civvtif5t0006whs697is1mxz"},{"post_id":"civvtif6e000hwhs6rifs23zz","tag_id":"civvtif6g000iwhs6hb9jughv","_id":"civvtif6h000kwhs6513ylrhj"},{"post_id":"civvtif6e000hwhs6rifs23zz","tag_id":"civvtif6g000jwhs6hjjtc3tj","_id":"civvtif6h000lwhs6uvvgk7rg"},{"post_id":"civvtif6i000mwhs6s17wf7uv","tag_id":"civvtif6j000nwhs60yzbirnx","_id":"civvtif6j000pwhs6g72omo50"},{"post_id":"civvtif6i000mwhs6s17wf7uv","tag_id":"civvtif6j000owhs6maxuegvn","_id":"civvtif6j000qwhs65r01t8g6"},{"post_id":"civvtif6l000rwhs6prj1zjxw","tag_id":"civvtif6n000swhs6izsiyfm2","_id":"civvtif6o000uwhs6b3mht73z"},{"post_id":"civvtif6l000rwhs6prj1zjxw","tag_id":"civvtif6o000twhs6iiomz0ir","_id":"civvtif6o000vwhs61r3u495x"},{"post_id":"civvtif6q000wwhs6sbe9pkn4","tag_id":"civvtif6o000twhs6iiomz0ir","_id":"civvtif6r000xwhs6yqsj06re"},{"post_id":"civvtif6q000wwhs6sbe9pkn4","tag_id":"civvtif6n000swhs6izsiyfm2","_id":"civvtif6r000ywhs62vrzj994"},{"post_id":"civvtif6s000zwhs6hjmg2qiv","tag_id":"civvtif6t0010whs6rfbwqhkw","_id":"civvtif6u0013whs61kxpabwz"},{"post_id":"civvtif6s000zwhs6hjmg2qiv","tag_id":"civvtif6t0011whs6aur17vl4","_id":"civvtif6u0014whs6491exchh"},{"post_id":"civvtif6s000zwhs6hjmg2qiv","tag_id":"civvtif5s0002whs6237pbq69","_id":"civvtif6u0015whs680618t5f"},{"post_id":"civvtif6s000zwhs6hjmg2qiv","tag_id":"civvtif6t0012whs68upptujx","_id":"civvtif6u0016whs63gbspyy0"},{"post_id":"civvtif6v0017whs6yiyf28rr","tag_id":"civvtif6t0010whs6rfbwqhkw","_id":"civvtif6w0018whs6u5czhchm"},{"post_id":"civvtif6y0019whs648aistmc","tag_id":"civvtif6z001awhs6d7riykep","_id":"civvtif6z001bwhs6bn6amedj"},{"post_id":"civvtif74001dwhs6auoo8d5a","tag_id":"civvtif6n000swhs6izsiyfm2","_id":"civvtif76001fwhs6gdd12so5"},{"post_id":"civvtif74001dwhs6auoo8d5a","tag_id":"civvtif75001ewhs6jrck9dff","_id":"civvtif76001gwhs6gr4rs731"},{"post_id":"civvtif77001hwhs6twgivlwd","tag_id":"civvtif6z001awhs6d7riykep","_id":"civvtif78001iwhs6ock6r8sg"},{"post_id":"civvtif79001jwhs6u5hgbnet","tag_id":"civvtif6n000swhs6izsiyfm2","_id":"civvtif7a001lwhs6g5t1x373"},{"post_id":"civvtif79001jwhs6u5hgbnet","tag_id":"civvtif79001kwhs6w1920ytj","_id":"civvtif7a001mwhs60bib3fg9"},{"post_id":"civvtif7b001nwhs69y3stqo0","tag_id":"civvtif6g000iwhs6hb9jughv","_id":"civvtif7e001qwhs64sahvyw0"},{"post_id":"civvtif7b001nwhs69y3stqo0","tag_id":"civvtif7d001owhs64nxg8j3q","_id":"civvtif7e001rwhs68hck195j"},{"post_id":"civvtif7b001nwhs69y3stqo0","tag_id":"civvtif7d001pwhs6b7ppa661","_id":"civvtif7e001swhs65kcaxmw8"},{"post_id":"civvtif7g001twhs6xyn4krj5","tag_id":"civvtif6t0010whs6rfbwqhkw","_id":"civvtif7h001uwhs6x2039fj9"},{"post_id":"civvtif7i001vwhs6pvdf7ijw","tag_id":"civvtif7j001wwhs624t1bz81","_id":"civvtif7k001ywhs6aure2bb9"},{"post_id":"civvtif7i001vwhs6pvdf7ijw","tag_id":"civvtif7j001xwhs670td69l8","_id":"civvtif7k001zwhs6vdc6c91l"},{"post_id":"civvtif7l0020whs6vjcdry7g","tag_id":"civvtif6t0010whs6rfbwqhkw","_id":"civvtif7m0022whs6vv5rezp8"},{"post_id":"civvtif7l0020whs6vjcdry7g","tag_id":"civvtif7m0021whs6ezsgs1mq","_id":"civvtif7n0023whs6flnkolcl"},{"post_id":"civvtif7n0024whs6274uxdax","tag_id":"civvtif7p0025whs6hiewegq8","_id":"civvtif7q0026whs6hjr5yqx2"},{"post_id":"civvtif830027whs6vb4mrwn0","tag_id":"civvtif840028whs6oi2ohhne","_id":"civvtif86002awhs6rpnyj2xg"},{"post_id":"civvtif830027whs6vb4mrwn0","tag_id":"civvtif5q0001whs6xsqj7tcb","_id":"civvtif86002bwhs6n1ggc1x1"},{"post_id":"civvtif830027whs6vb4mrwn0","tag_id":"civvtif860029whs6vo0cqryj","_id":"civvtif86002cwhs6rqq79utt"},{"post_id":"civvtif88002dwhs6cc4dmo3r","tag_id":"civvtif6t0010whs6rfbwqhkw","_id":"civvtif89002gwhs6el71nhb7"},{"post_id":"civvtif88002dwhs6cc4dmo3r","tag_id":"civvtif89002ewhs6kvo1bx59","_id":"civvtif89002hwhs6xyrm5e9d"},{"post_id":"civvtif88002dwhs6cc4dmo3r","tag_id":"civvtif89002fwhs6g8pgg0kp","_id":"civvtif89002iwhs6q1xpilap"},{"post_id":"civvtif8b002jwhs6825on61k","tag_id":"civvtif6t0010whs6rfbwqhkw","_id":"civvtif8k002kwhs62sfd7rue"}],"Tag":[{"name":"AndFix","_id":"civvtif5q0001whs6xsqj7tcb"},{"name":"热更新","_id":"civvtif5s0002whs6237pbq69"},{"name":"multidex","_id":"civvtif5s0003whs66wcdzuq0"},{"name":"工具","_id":"civvtif6g000iwhs6hb9jughv"},{"name":"Zsh","_id":"civvtif6g000jwhs6hjjtc3tj"},{"name":"算法","_id":"civvtif6j000nwhs60yzbirnx"},{"name":"排序","_id":"civvtif6j000owhs6maxuegvn"},{"name":"前端","_id":"civvtif6n000swhs6izsiyfm2"},{"name":"CSS","_id":"civvtif6o000twhs6iiomz0ir"},{"name":"Android","_id":"civvtif6t0010whs6rfbwqhkw"},{"name":"动态加载","_id":"civvtif6t0011whs6aur17vl4"},{"name":"Install run","_id":"civvtif6t0012whs68upptujx"},{"name":"Hexo","_id":"civvtif6z001awhs6d7riykep"},{"name":"JavaScript","_id":"civvtif75001ewhs6jrck9dff"},{"name":"Flexbox","_id":"civvtif79001kwhs6w1920ytj"},{"name":"apk反编辑","_id":"civvtif7d001owhs64nxg8j3q"},{"name":"逆向","_id":"civvtif7d001pwhs6b7ppa661"},{"name":"apk瘦身","_id":"civvtif7j001wwhs624t1bz81"},{"name":"优化","_id":"civvtif7j001xwhs670td69l8"},{"name":"进程保活","_id":"civvtif7m0021whs6ezsgs1mq"},{"name":"自定义View","_id":"civvtif7p0025whs6hiewegq8"},{"name":"热补丁","_id":"civvtif840028whs6oi2ohhne"},{"name":"源码分析","_id":"civvtif860029whs6vo0cqryj"},{"name":"通知消息权限","_id":"civvtif89002ewhs6kvo1bx59"},{"name":"Toast","_id":"civvtif89002fwhs6g8pgg0kp"}]}}